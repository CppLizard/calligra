/* This file is part of the Calligra project, made within the KDE community.

   Copyright 2012 Friedrich W. H. Kossebau <kossebau@kde.org>

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public License
   along with this library; see the file COPYING.LIB.  If not, write to
   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
*/

#include "cheadergenerator.h"

// generator
#include "formatdocument.h"
// Qt
#include <QtCore/QIODevice>
#include <QtCore/QStringList>
#include <QtCore/QSet>

bool
CHeaderGenerator::write( FormatDocument* document, QIODevice* device )
{
    CHeaderGenerator generator( document, device );

    return true; // TODO: how to learn about error?
}

CHeaderGenerator::CHeaderGenerator( FormatDocument* document, QIODevice* device )
  : mDocument( document)
  , mTextStream( device )
{
    // header
    mTextStream << QLatin1String("// Generated by cheadergenerator\n");
    // include guards begin
    const QString upperName = QString::fromLatin1("cdr4structs").toUpper() + QLatin1String("_H");
    mTextStream << QLatin1String("#ifndef ")<<upperName<<QLatin1Char('\n');
    mTextStream << QLatin1String("#define ")<<upperName<<QLatin1Char('\n');

    QSet<QString> includes;
    foreach( const IncludedType& includedType, mDocument->includedTypes() )
        includes.insert(includedType.includeName());
    writeIncludes( includes.toList() );

    writeTypeDefs( mDocument->typeDefByName() );

    foreach( const Enumeration& enumeration, mDocument->enumerations() )
        writeEnums( enumeration );


    foreach( const Record* record, mDocument->records() )
        writeRecord( record );

    // include guards end
    mTextStream << QLatin1String("#endif\n");
}

void
CHeaderGenerator::writeIncludes( const QStringList& fileNames )
{
    foreach( const QString& fileName, fileNames )
        mTextStream << QLatin1String("#include <") << fileName << QLatin1String(">\n");
}

void
CHeaderGenerator::writeTypeDefs( const QHash<QString,QString>& typeDefByName )
{
    QHash<QString,QString>::ConstIterator begin = typeDefByName.constBegin();
    QHash<QString,QString>::ConstIterator end = typeDefByName.constEnd();
    QHash<QString,QString>::ConstIterator it = begin;
    for( ; it != end; ++it )
    {
        mTextStream << QLatin1String("typedef ") << it.value() << QLatin1String(" ") << it.key() << QLatin1String(";\n");;
    }
}

void
CHeaderGenerator::writeEnums( const Enumeration& enumeration )
{
    mTextStream << QLatin1String("enum ") << enumeration.name() << QLatin1String("\n{");

    const QMap<int,QString>& items = enumeration.items();
    QMap<int,QString>::ConstIterator begin = items.constBegin();
    QMap<int,QString>::ConstIterator end = items.constEnd();
    QMap<int,QString>::ConstIterator it = begin;
    for( ; it != end; ++it )
    {
        const char* lineBreak = (it!=begin)?",\n":"\n";
        mTextStream << QLatin1String(lineBreak)
                    << QLatin1String("    ") << it.value() << QLatin1String(" = ") << it.key();
    }

    mTextStream << QLatin1String("\n};\n");
}

void
CHeaderGenerator::writeRecord( const Record* record )
{
    mTextStream << QLatin1String("struct ") << record->name();
    if( ! record->baseName().isEmpty() )
        mTextStream << QLatin1String(" : public ") << record->baseName();
    mTextStream << QLatin1String("\n{\n");

    QStringList getters;
    QStringList members;

    // methods
    foreach( const QString& method, record->methods() )
        mTextStream << QLatin1String("    ") << method << QLatin1Char('\n');

    // members
    foreach( const AbstractRecordField* field, record->fields() )
    {
        if( field->typeId() == PlainFieldId )
        {
            const PlainRecordField* plainField = static_cast<const PlainRecordField*>( field );

            // member
            members.append( QLatin1String("    ")+plainField->typeId()+QLatin1String(" __")+plainField->name()+
                            QLatin1String(";\n") );
            // access method, TODO: for POD return by value
            getters.append( QLatin1String("    const ")+plainField->typeId()+QLatin1String("& ")+plainField->name() +
                            QLatin1String("() const { return __")+plainField->name()+QLatin1String("; }\n") );
        }
        else if( field->typeId() == ArrayFieldId )
        {
            const ArrayRecordField* arrayField = static_cast<const ArrayRecordField*>( field );

            // member
            members.append( QLatin1String("    ")+arrayField->typeId()+QLatin1String(" __")+arrayField->name()+
                            QLatin1Char('[')+QString::number(arrayField->arraySize())+QLatin1String("];\n") );
            // access method
            getters.append( QLatin1String("    const ")+arrayField->typeId()+QLatin1String("* ")+arrayField->name() +
                            QLatin1String("() const { return __")+arrayField->name()+QLatin1String("; }\n") );
        }
        else if( field->typeId() == DynArrayFieldId )
        {
            const DynArrayRecordField* arrayField = static_cast<const DynArrayRecordField*>( field );

            // member
            members.append( QLatin1String("    ")+arrayField->typeId()+QLatin1String(" __")+arrayField->name()+
                            QLatin1String(";\n") );
            // access method
            getters.append( arrayField->typeId()+QLatin1Char(' ')+arrayField->name()+
                            QLatin1String("( int i ) const { return (&__")+arrayField->name()+
                            QLatin1String(")[i]; }\n") );
        }
        else if( field->typeId() == Text8BitFieldId )
        {
            const Text8BitRecordField* textField = static_cast<const Text8BitRecordField*>( field );

            // member
            members.append( QLatin1String("    char __")+textField->name()+
                            QLatin1Char('[')+QString::number(textField->length())+QLatin1String("];\n") );
            // access method, TODO: add check for length and no \0
            getters.append( QLatin1String("    const char* ")+textField->name()+
                            QLatin1String("() const { return __")+textField->name()+QLatin1String("; }\n") );
        }
        else if( field->typeId() == DynText8BitFieldId )
        {
            const DynText8BitRecordField* textField = static_cast<const DynText8BitRecordField*>( field );

            // member
            members.append( QLatin1String("    char __")+textField->name()+QLatin1String(";\n") );
            // access method
            getters.append( QLatin1String("    const char* ")+textField->name()+
                            QLatin1String("() const { return &__")+textField->name()+QLatin1String("; }\n") );
        }
        else if( field->typeId() == UnionFieldId )
        {
            const UnionRecordField* unionField = static_cast<const UnionRecordField*>( field );

            // member
            members.append( QLatin1String("    char __")+unionField->name()+QLatin1String(";\n") );
            // access methods
            foreach( const RecordFieldUnionVariant& variant, unionField->variants() )
            {
                getters.append( QLatin1String("    const ")+variant.typeId()+QLatin1String("& ")+variant.name() +
                                QLatin1String("() const { return reinterpret_cast<const ")+variant.typeId()+
                                ("&>(__")+unionField->name()+QLatin1String("); }\n") );
            }
        }
    }

    mTextStream << QLatin1String("public:\n");
    foreach( const QString& getter, getters )
        mTextStream << getter;
    mTextStream << QLatin1String("private:\n");
    foreach( const QString& member, members )
        mTextStream << member;
    mTextStream << QLatin1String("};\n");
}
