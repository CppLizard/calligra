diff --git a/filters/libmsooxml/MsooXmlImport.cpp b/filters/libmsooxml/MsooXmlImport.cpp
index 5cb25a2..9ff7f82 100644
--- a/filters/libmsooxml/MsooXmlImport.cpp
+++ b/filters/libmsooxml/MsooXmlImport.cpp
@@ -759,6 +759,15 @@ KoFilter::ConversionStatus MsooXmlImport::openFile(KoOdfWriters *writers, QStrin
         kDebug() << Content_Types_xml << "could not be parsed correctly! Aborting!";
         return status;
     }
+
+    //m_outputStore = 0;
+    //m_zip = 0;
+    //m_contentTypesXML = KoXmlDocument();
+    m_contentTypes.clear();
+    m_documentProperties.clear();
+    //m_documentXML = KoXmlDocument();
+    m_imageSizes.clear();
+
     RETURN_IF_ERROR( Utils::loadContentTypes(m_contentTypesXML, m_contentTypes) )
 
     static const char *docPropy_core_xml = "docProps/core.xml";
diff --git a/filters/words/msword-odf/wv2/src/textconverter.cpp b/filters/words/msword-odf/wv2/src/textconverter.cpp
index e701ba0..f2c24c2 100644
--- a/filters/words/msword-odf/wv2/src/textconverter.cpp
+++ b/filters/words/msword-odf/wv2/src/textconverter.cpp
@@ -25,12 +25,7 @@
 #include <config.h>
 #endif
 
-#ifdef HAVE_ICONV_H
-#include <iconv.h>
-#endif
-#ifdef HAVE_SYS_ICONV_H
-#include <sys/iconv.h>
-#endif
+#include <QTextCodec>
 
 #include "wvlog.h"
 #include <errno.h>
@@ -41,7 +36,7 @@ class TextConverter::Private
 {
 public:
     Private( const std::string& toCode, const std::string& fromCode ) :
-        m_toCode( toCode ), m_fromCode( fromCode ), m_iconv( reinterpret_cast<iconv_t>( -1 ) ) {}
+        m_toCode( toCode ), m_fromCode( fromCode ), m_iconvFrom( 0 ), m_iconvTo( 0 ) {}
 
     Private( const std::string& fromCode ) :
 #ifdef WORDS_BIGENDIAN
@@ -49,7 +44,7 @@ public:
 #else
         m_toCode( "UCS-2LE" ),
 #endif
-        m_fromCode( fromCode ), m_iconv( reinterpret_cast<iconv_t>( -1 ) ) {}
+        m_fromCode( fromCode ), m_iconvFrom( 0 ), m_iconvTo( 0 ) {}
 
     Private( U16 lid ) :
 #ifdef WORDS_BIGENDIAN
@@ -58,11 +53,10 @@ public:
         m_toCode( "UCS-2LE" ),
 #endif
         m_fromCode( TextConverter::LID2Codepage( lid ) ),
-        m_iconv( reinterpret_cast<iconv_t>( -1 ) ) {}
-
+        m_iconvFrom( 0 ), m_iconvTo( 0 ) {}
 
     std::string m_toCode, m_fromCode;
-    iconv_t m_iconv;
+    QTextCodec *m_iconvFrom, *m_iconvTo;
     bool m_swap;
 };
 
@@ -90,7 +84,7 @@ TextConverter::~TextConverter()
 
 bool TextConverter::isOk() const
 {
-    return d->m_iconv != reinterpret_cast<iconv_t>( -1 );
+    return d->m_iconvFrom && d->m_iconvTo;
 }
 
 void TextConverter::setToCode( const std::string& toCode )
@@ -122,6 +116,12 @@ UString TextConverter::convert( const std::string& input ) const
     return convert( input.c_str(), input.size() );
 }
 
+static inline unsigned long readU16(const void* p)
+{
+    const unsigned char* ptr = (const unsigned char*) p;
+    return ptr[0] + (ptr[1] << 8);
+}
+
 UString TextConverter::convert( const char* input, unsigned int length ) const
 {
     if ( !isOk() ) {
@@ -129,36 +129,19 @@ UString TextConverter::convert( const char* input, unsigned int length ) const
         return UString();
     }
 
-    // WinWord doesn't have multi-byte characters encoded in compressed-unicode
-    // sections, right?
-    UChar *output = new UChar[ length ];
-    char *p_output = reinterpret_cast<char*>( output );
-    size_t outputLen = length << 1;
-
-    const char* p_input = input;
-    size_t inputLen = length;
-
-    if ( static_cast<size_t>( -1 ) == iconv( d->m_iconv, const_cast<ICONV_CONST char**>( &p_input ), &inputLen, &p_output, &outputLen ) ) {
-        delete [] output;
-        // If we got more than one character, try to return as much text as possible...
-        // To convert the text with as few iconv calls as possible we are using a divide
-        // and conquer approach.
-        if ( length > 1 )  {
-            UString ustring( convert( input, length / 2 ) );
-            ustring += convert( input + length / 2, ( length + 1 ) / 2 );
-            return ustring;
-        }
-        else {
-            wvlog << "Error: The conversion was not successful: " << errno << endl;
-            return UString();
-        }
-    }
+    char *p_output = const_cast<char*>(input);
+    size_t outputLen = length;
 
-    if ( outputLen != 0 || ( outputLen & 0x00000001 ) == 1 )
-        wvlog << "Strange, got an outputLen of " << outputLen << endl;
+    QByteArray output;
+    if (d->m_iconvFrom && d->m_iconvTo) {
+        QString uc = d->m_iconvFrom->toUnicode(QByteArray(input, length));
+        QTextCodec::ConverterState state(QTextCodec::IgnoreHeader);
+        output = d->m_iconvTo->fromUnicode(uc.data(), uc.length(), &state);
+        p_output = output.data();
+        //outputLen = output.length();
+    }
 
-    UString ustring( output, length - ( outputLen >> 1 ), true );
-    delete [] output;
+    UString ustring( reinterpret_cast<UChar*>( p_output ), outputLen, true );
     return ustring;
 }
 
@@ -304,14 +287,12 @@ const char* TextConverter::LID2Codepage( U16 lid )
 
 void TextConverter::close()
 {
-    if ( d->m_iconv != reinterpret_cast<iconv_t>( -1 ) )
-        iconv_close( d->m_iconv );
-    d->m_iconv = reinterpret_cast<iconv_t>( -1 );
+    d->m_iconvFrom = d->m_iconvTo = 0;
 }
 
 void TextConverter::open()
 {
-    if ( d->m_iconv != reinterpret_cast<iconv_t>( -1 ) ) {
+    if ( d->m_iconvFrom || d->m_iconvTo ) {
         wvlog << "Warning: Do you really want to get rid of the current converter?" << endl;
         close();
     }
@@ -325,8 +306,23 @@ void TextConverter::open()
     if ( d->m_fromCode == "not known" )
         wvlog << "Warning: We don't know the current charset you want to convert from!" << endl;
 
-    if ( !d->m_toCode.empty() && !d->m_fromCode.empty() )
-        d->m_iconv = iconv_open( d->m_toCode.c_str(), d->m_fromCode.c_str() );
+    if ( !d->m_toCode.empty() && !d->m_fromCode.empty() ) {
+        QByteArray toCode = d->m_toCode.c_str();
+        QByteArray fromCode = d->m_fromCode.c_str();
+        if (fromCode.toLower() == "ucs2" || fromCode == "UCS-2BE" || fromCode == "UCS-2LE" || fromCode == "ISO 10646-UCS-2")
+            fromCode = "UTF-16";
+        if (toCode.toLower() == "ucs2" || toCode == "UCS-2BE" || toCode == "UCS-2LE" || toCode == "ISO 10646-UCS-2")
+            toCode = "UTF-16";
+        d->m_iconvTo = QTextCodec::codecForName( toCode );
+        d->m_iconvFrom = QTextCodec::codecForName( fromCode );
+        Q_ASSERT_X(d->m_iconvTo && d->m_iconvFrom, __FUNCTION__,
+                    qPrintable(QString("TextCodec error fromName=%1 toName=%2 fromCodec=%3 toCodec=%4")
+                        .arg(QString::fromUtf8(fromCode))
+                        .arg(QString::fromUtf8(toCode))
+                        .arg(QString::fromUtf8(d->m_iconvFrom ? d->m_iconvFrom->name() : QByteArray()))
+                        .arg(QString::fromUtf8(d->m_iconvTo ? d->m_iconvTo->name() : QByteArray()))
+                    ) );
+    }
 }
 
 U16 TextConverter::fixLID( U16 nLocale )
diff --git a/libs/flake/KoImageData.cpp b/libs/flake/KoImageData.cpp
index 2b909e6..81cda27 100644
--- a/libs/flake/KoImageData.cpp
+++ b/libs/flake/KoImageData.cpp
@@ -65,9 +65,9 @@ KoImageData::~KoImageData()
         delete d;
 }
 
-QPixmap KoImageData::pixmap(const QSize &size)
+QImage KoImageData::pixmap(const QSize &size)
 {
-    if (!d) return QPixmap();
+    if (!d) return QImage();
     QSize wantedSize = size;
     if (! wantedSize.isValid()) {
         if (d->pixmap.isNull()) // we have a problem, Houston..
@@ -80,14 +80,14 @@ QPixmap KoImageData::pixmap(const QSize &size)
         case KoImageDataPrivate::StateEmpty: {
 #if 0       // this is not possible as it gets called during the paint method
             // and will crash. Therefore create a tmp pixmap and return it.
-            d->pixmap = QPixmap(1, 1);
+            d->pixmap = QImage(1, 1, QImage::Format_ARGB32);
             QPainter p(&d->pixmap);
             p.setPen(QPen(Qt::gray));
             p.drawPoint(0, 0);
             p.end();
             break;
 #endif
-            QPixmap tmp(1, 1);
+            QImage tmp(1, 1, QImage::Format_ARGB32);
             tmp.fill(Qt::gray);
             return tmp;
         }
@@ -99,7 +99,7 @@ QPixmap KoImageData::pixmap(const QSize &size)
             if (!d->image.isNull()) {
                 // create pixmap from image.
                 // this is the highest quality and lowest memory usage way of doing the conversion.
-                d->pixmap = QPixmap::fromImage(d->image.scaled(wantedSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation));
+                d->pixmap = d->image.scaled(wantedSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
             }
         }
 
diff --git a/libs/flake/KoImageData.h b/libs/flake/KoImageData.h
index 3556100..888422c 100644
--- a/libs/flake/KoImageData.h
+++ b/libs/flake/KoImageData.h
@@ -29,7 +29,6 @@
 #include <KoShapeUserData.h>
 
 class QIODevice;
-class QPixmap;
 class QImage;
 class QSizeF;
 class QUrl;
@@ -78,7 +77,7 @@ public:
      * @returns the cached pixmap
      * @see isValid(), hasCachedPixmap()
      */
-    QPixmap pixmap(const QSize &targetSize = QSize());
+    QImage pixmap(const QSize &targetSize = QSize());
 
     /// returns true only if pixmap() would return immediately with a cached pixmap
     bool hasCachedPixmap() const;
diff --git a/libs/flake/KoImageData_p.cpp b/libs/flake/KoImageData_p.cpp
index 5a1901b..7705255 100644
--- a/libs/flake/KoImageData_p.cpp
+++ b/libs/flake/KoImageData_p.cpp
@@ -154,7 +154,7 @@ void KoImageDataPrivate::clear()
     imageSize = QSizeF();
     key = 0;
     image = QImage();
-    pixmap = QPixmap();
+    //pixmap = QPixmap();
 }
 
 qint64 KoImageDataPrivate::generateKey(const QByteArray &bytes)
diff --git a/libs/flake/KoImageData_p.h b/libs/flake/KoImageData_p.h
index 46480d0..419ac21 100644
--- a/libs/flake/KoImageData_p.h
+++ b/libs/flake/KoImageData_p.h
@@ -82,7 +82,7 @@ public:
     QUrl imageLocation;
     QImage image;
     /// screen optimized cached version.
-    QPixmap pixmap;
+    QImage pixmap;
 
     KTemporaryFile *temporaryFile;
 };
diff --git a/libs/flake/KoPatternBackground.cpp b/libs/flake/KoPatternBackground.cpp
index 09ada1f..80b8cce 100644
--- a/libs/flake/KoPatternBackground.cpp
+++ b/libs/flake/KoPatternBackground.cpp
@@ -310,13 +310,12 @@ void KoPatternBackground::paint(QPainter &painter, const KoViewConverter &conver
 
         painter.setClipPath(fillPath);
         painter.setWorldTransform(matrix, true);
-        painter.drawTiledPixmap(targetRect, d->imageData->pixmap(imageSize.toSize()), -offset);
+        painter.fillRect(targetRect, QBrush(d->imageData->pixmap(imageSize.toSize())) /* , -offset */ );
     } else if (d->repeat == Original) {
         QRectF sourceRect(QPointF(0, 0), d->imageData->imageSize());
         QRectF targetRect(QPoint(0, 0), d->targetSize());
         targetRect.moveCenter(fillPath.boundingRect().center());
         painter.setClipPath(fillPath);
-        painter.drawPixmap(targetRect, d->imageData->pixmap(sourceRect.size().toSize()), sourceRect);
     } else if (d->repeat == Stretched) {
         painter.setClipPath(fillPath);
         // undo conversion of the scaling so that we can use a nicely scaled image of the correct size
@@ -327,7 +326,7 @@ void KoPatternBackground::paint(QPainter &painter, const KoViewConverter &conver
         painter.scale(zoomX, zoomY);
 
         QRectF targetRect = converter.documentToView(fillPath.boundingRect());
-        painter.drawPixmap(targetRect.topLeft(), d->imageData->pixmap(targetRect.size().toSize()));
+        painter.drawImage(targetRect.topLeft(), d->imageData->pixmap(targetRect.size().toSize()));
     }
 
     painter.restore();
diff --git a/libs/flake/KoUnavailShape.cpp b/libs/flake/KoUnavailShape.cpp
index 008b669..4279763 100644
--- a/libs/flake/KoUnavailShape.cpp
+++ b/libs/flake/KoUnavailShape.cpp
@@ -607,7 +607,7 @@ void KoUnavailShape::Private::storeXmlRecursive(const KoXmlElement &el, KoXmlWri
 void KoUnavailShape::Private::storeFile(const QString &fileName, KoShapeLoadingContext &context)
 {
     kDebug(30006) << "Saving file: " << fileName;
-
+return;
     // Directories need to be saved too, but they don't have any file contents.
     if (fileName.endsWith('/')) {
         FileEntry *entry = new FileEntry;
diff --git a/libs/main/KoDocument.cpp b/libs/main/KoDocument.cpp
index c5605bd..5545fc4 100644
--- a/libs/main/KoDocument.cpp
+++ b/libs/main/KoDocument.cpp
@@ -1219,71 +1219,7 @@ bool KoDocument::openFile()
         importedFile = d->filterManager->importDocument(d->parentPart->localFilePath(), typeName, status);
         if (status != KoFilter::OK) {
             QApplication::restoreOverrideCursor();
-
-            QString msg;
-            switch (status) {
-            case KoFilter::OK: break;
-
-            case KoFilter::FilterCreationError:
-                msg = i18n("Could not create the filter plugin"); break;
-
-            case KoFilter::CreationError:
-                msg = i18n("Could not create the output document"); break;
-
-            case KoFilter::FileNotFound:
-                msg = i18n("File not found"); break;
-
-            case KoFilter::StorageCreationError:
-                msg = i18n("Cannot create storage"); break;
-
-            case KoFilter::BadMimeType:
-                msg = i18n("Bad MIME type"); break;
-
-            case KoFilter::EmbeddedDocError:
-                msg = i18n("Error in embedded document"); break;
-
-            case KoFilter::WrongFormat:
-                msg = i18n("Format not recognized"); break;
-
-            case KoFilter::NotImplemented:
-                msg = i18n("Not implemented"); break;
-
-            case KoFilter::ParsingError:
-                msg = i18n("Parsing error"); break;
-
-            case KoFilter::PasswordProtected:
-                msg = i18n("Document is password protected"); break;
-
-            case KoFilter::InvalidFormat:
-                msg = i18n("Invalid file format"); break;
-
-            case KoFilter::InternalError:
-            case KoFilter::UnexpectedEOF:
-            case KoFilter::UnexpectedOpcode:
-            case KoFilter::StupidError: // ?? what is this ??
-            case KoFilter::UsageError:
-                msg = i18n("Internal error"); break;
-
-            case KoFilter::OutOfMemory:
-                msg = i18n("Out of memory"); break;
-
-            case KoFilter::FilterEntryNull:
-                msg = i18n("Empty Filter Plugin"); break;
-
-            case KoFilter::NoDocumentCreated:
-                msg = i18n("Trying to load into the wrong kind of document"); break;
-
-            case KoFilter::DownloadFailed:
-                msg = i18n("Failed to download remote file"); break;
-
-            case KoFilter::UserCancelled:
-            case KoFilter::BadConversionGraph:
-                // intentionally we do not prompt the error message here
-                break;
-
-            default: msg = i18n("Unknown error"); break;
-            }
-
+            QString msg = KoFilterManager::statusText(status);
             if (d->autoErrorHandlingEnabled && !msg.isEmpty()) {
 #ifndef Q_OS_WIN
                 QString errorMsg(i18n("Could not open\n%2.\nReason: %1", msg, prettyPathOrUrl()));
@@ -1292,7 +1228,6 @@ bool KoDocument::openFile()
                 QString errorMsg(i18n("Could not open\n%1.\nThe filter plugins have not been properly registered. Please reboot Windows. Krita Sketch will now close.", prettyPathOrUrl()));
                 KMessageBox::error(0, errorMsg);
 #endif
-
             }
 
             d->isLoading = false;
@@ -1910,6 +1845,7 @@ KService::Ptr KoDocument::nativeService()
 
 QByteArray KoDocument::nativeFormatMimeType() const
 {
+#if 0
     KService::Ptr service = const_cast<KoDocument *>(this)->nativeService();
     if (!service) {
         kWarning(30003) << "No native service defined to read NativeMimeType from desktop file!";
@@ -1928,6 +1864,9 @@ QByteArray KoDocument::nativeFormatMimeType() const
     }
 #endif
     return nativeMimeType;
+#else
+    return "application/vnd.oasis.opendocument.text";
+#endif
 }
 
 QByteArray KoDocument::nativeOasisMimeType() const
diff --git a/libs/main/KoDocument.h b/libs/main/KoDocument.h
index 3372060..6653b30 100644
--- a/libs/main/KoDocument.h
+++ b/libs/main/KoDocument.h
@@ -145,7 +145,7 @@ public:
      * delivers.
      * This comes from the X-KDE-NativeMimeType key in the .desktop file.
      */
-    QByteArray nativeFormatMimeType() const;
+    virtual QByteArray nativeFormatMimeType() const;
 
     /**
      * Returns the OASIS OpenDocument mimetype of the document, if supported
@@ -154,7 +154,7 @@ public:
      *
      * @return the oasis mimetype or, if it hasn't one, the nativeformatmimetype.
      */
-    QByteArray nativeOasisMimeType() const;
+    virtual QByteArray nativeOasisMimeType() const;
 
     enum ImportExportType {
         ForExport,
diff --git a/libs/main/KoDocumentSectionView.cpp b/libs/main/KoDocumentSectionView.cpp
index 29467ea..48a4ef4 100644
--- a/libs/main/KoDocumentSectionView.cpp
+++ b/libs/main/KoDocumentSectionView.cpp
@@ -439,5 +439,5 @@ void KoDocumentSectionView::setDraggingFlag(bool flag)
     m_draggingFlag = flag;
 }
 
-#include <KoDocumentSectionPropertyAction_p.moc>
+//#include <KoDocumentSectionPropertyAction_p.moc>
 #include <KoDocumentSectionView.moc>
diff --git a/libs/main/KoFilter.h b/libs/main/KoFilter.h
index 8ed43ae..ce089f5 100644
--- a/libs/main/KoFilter.h
+++ b/libs/main/KoFilter.h
@@ -97,6 +97,8 @@ public:
      */
     void setUpdater(const QPointer<KoUpdater>& updater);
 
+    void setFilterChain(KoFilterChain *chain) { m_chain = chain; }
+
 signals:
     /**
      * Emit this signal with a value in the range of 1...100 to have some
diff --git a/libs/main/KoFilterChain.cpp b/libs/main/KoFilterChain.cpp
index 3456ee1..708cdae 100644
--- a/libs/main/KoFilterChain.cpp
+++ b/libs/main/KoFilterChain.cpp
@@ -399,6 +399,7 @@ void KoFilterChain::inputFileHelper(KoDocument* document, const QString& alterna
 
 void KoFilterChain::outputFileHelper(bool autoDelete)
 {
+if (!m_outputFile.isEmpty()) return;
     if (!createTempFile(&m_outputTempFile, autoDelete)) {
         delete m_outputTempFile;
         m_outputTempFile = 0;
diff --git a/libs/main/KoFilterChain.h b/libs/main/KoFilterChain.h
index a37c8b1..b4c0a8c 100644
--- a/libs/main/KoFilterChain.h
+++ b/libs/main/KoFilterChain.h
@@ -62,6 +62,7 @@ class KOMAIN_EXPORT KoFilterChain : public KShared
 public:
     typedef KSharedPtr<KoFilterChain> Ptr;
 
+    explicit KoFilterChain(const KoFilterManager* manager);
     virtual ~KoFilterChain();
 
     /**
@@ -130,6 +131,9 @@ public:
     // debugging
     void dump();
 
+    void setInputFile(const QString &inputFile) { m_inputFile = inputFile; m_inputQueried = File; }
+    void setOutputFile(const QString &outputFile) { m_outputFile = outputFile; m_outputQueried = File; }
+
 private:
     // ### API for Calligra::Graph:
     // Construct a filter chain belonging to some KoFilterManager.
@@ -137,8 +141,6 @@ private:
 
     friend class CalligraFilter::Graph;
 
-    explicit KoFilterChain(const KoFilterManager* manager);
-
     void appendChainLink(KoFilterEntry::Ptr filterEntry, const QByteArray& from, const QByteArray& to);
     void prependChainLink(KoFilterEntry::Ptr filterEntry, const QByteArray& from, const QByteArray& to);
 
diff --git a/libs/main/KoFilterManager.cpp b/libs/main/KoFilterManager.cpp
index 2648885..2ce9320 100644
--- a/libs/main/KoFilterManager.cpp
+++ b/libs/main/KoFilterManager.cpp
@@ -170,7 +170,6 @@ QString KoFilterManager::importDocument(const QString& url,
     status = chain->invokeChain();
 
     m_importUrl.clear();  // Reset the import URL
-
     if (status == KoFilter::OK)
         return chain->chainOutput();
     return QString();
@@ -239,7 +238,6 @@ KoFilter::ConversionStatus KoFilterManager::exportDocument(const QString& url, Q
         if (!d->batch) KMessageBox::error(0, i18n("Could not export file."), i18n("Missing Export Filter"));
         return KoFilter::BadConversionGraph;
     }
-
     return chain->invokeChain();
 }
 
@@ -523,6 +521,56 @@ bool KoFilterManager::filterAvailable(KoFilterEntry::Ptr entry)
     return m_filterAvailable[key];
 }
 
+QString KoFilterManager::statusText(KoFilter::ConversionStatus status)
+{
+    switch (status) {
+    case KoFilter::OK: break;
+    case KoFilter::FilterCreationError:
+        return i18n("Could not create the filter plugin");
+    case KoFilter::CreationError:
+        return i18n("Could not create the output document");
+    case KoFilter::FileNotFound:
+        return i18n("File not found");
+    case KoFilter::StorageCreationError:
+        return i18n("Cannot create storage");
+    case KoFilter::BadMimeType:
+        return i18n("Bad MIME type");
+    case KoFilter::EmbeddedDocError:
+        return i18n("Error in embedded document");
+    case KoFilter::WrongFormat:
+        return i18n("Format not recognized");
+    case KoFilter::NotImplemented:
+        return i18n("Not implemented");
+    case KoFilter::ParsingError:
+        return i18n("Parsing error");
+    case KoFilter::PasswordProtected:
+        return i18n("Document is password protected");
+    case KoFilter::InvalidFormat:
+        return i18n("Invalid file format");
+    case KoFilter::InternalError:
+    case KoFilter::UnexpectedEOF:
+    case KoFilter::UnexpectedOpcode:
+    case KoFilter::StupidError: // ?? what is this ??
+    case KoFilter::UsageError:
+        return i18n("Internal error");
+    case KoFilter::OutOfMemory:
+        return i18n("Out of memory");
+    case KoFilter::FilterEntryNull:
+        return i18n("Empty Filter Plugin");
+    case KoFilter::NoDocumentCreated:
+        return i18n("Trying to load into the wrong kind of document");
+    case KoFilter::DownloadFailed:
+        return i18n("Failed to download remote file");
+    case KoFilter::UserCancelled:
+    case KoFilter::BadConversionGraph:
+        // intentionally we do not prompt the error message here
+        break;
+    default:
+        return i18n("Unknown error");
+    }
+    return QString();
+}
+
 void KoFilterManager::importErrorHelper(const QString& mimeType, const bool suppressDialog)
 {
     QString tmp = i18n("Could not import file of type\n%1", mimeType);
diff --git a/libs/main/KoFilterManager.h b/libs/main/KoFilterManager.h
index 3fbef5c..774df84 100644
--- a/libs/main/KoFilterManager.h
+++ b/libs/main/KoFilterManager.h
@@ -134,6 +134,11 @@ public:
      */
     static bool filterAvailable(KoFilterEntry::Ptr entry);
 
+    /**
+     * Returns the translated description for the \p status .
+     */
+    static QString statusText(KoFilter::ConversionStatus status);
+
     //@}
 
     /**
@@ -153,6 +158,9 @@ public:
      **/
     KoProgressUpdater *progressUpdater() const;
 
+    void setImportFile(const QString &file) { m_importUrl = file; }
+    void setExportFile(const QString &file) { m_exportUrl = file; }
+
 private:
     // === API for KoFilterChains === (internal)
     // The friend methods are private in KoFilterChain and
diff --git a/libs/main/KoView.cpp b/libs/main/KoView.cpp
index 1b4a722..7f0a9a2 100644
--- a/libs/main/KoView.cpp
+++ b/libs/main/KoView.cpp
@@ -647,5 +647,5 @@ QList<QAction*> KoView::createChangeUnitActions()
     return unitActions->actions();
 }
 
-#include <KoView_p.moc>
+//#include <KoView_p.moc>
 #include <KoView.moc>
diff --git a/libs/textlayout/KoTextLayoutArea_paint.cpp b/libs/textlayout/KoTextLayoutArea_paint.cpp
index e94cc71..806da57 100644
--- a/libs/textlayout/KoTextLayoutArea_paint.cpp
+++ b/libs/textlayout/KoTextLayoutArea_paint.cpp
@@ -477,7 +477,7 @@ void KoTextLayoutArea::drawListItem(QPainter *painter, QTextBlock &block)
             qreal y = blockData.counterPosition().y() + fm.ascent() - fm.xHeight()/2 - height/2; // centered
             KoImageData *idata = listFormat.property(KoListStyle::BulletImage).value<KoImageData *>();
             if (idata) {
-                painter->drawPixmap(x, y, width, height, idata->pixmap());
+                painter->drawImage(QRectF(x, y, width, height), idata->pixmap());
             }
         }
     }
diff --git a/plugins/pictureshape/PictureShape.cpp b/plugins/pictureshape/PictureShape.cpp
index 976fadd..287c620 100644
--- a/plugins/pictureshape/PictureShape.cpp
+++ b/plugins/pictureshape/PictureShape.cpp
@@ -52,10 +52,13 @@
 
 #include <QPainter>
 #include <QTimer>
-#include <QPixmapCache>
 #include <QThreadPool>
 #include <QImage>
 #include <QColor>
+#include <QCache>
+
+typedef QMap<QString,QImage> ImageCache;
+Q_GLOBAL_STATIC(ImageCache, s_imageCache)
 
 QString generate_key(qint64 key, const QSize & size)
 {
@@ -90,7 +93,7 @@ void _Private::PixmapScaler::run()
 
 void _Private::PictureShapeProxy::setImage(const QString &key, const QImage &image)
 {
-    QPixmapCache::insert(key, QPixmap::fromImage(image));
+    s_imageCache()->insert(key, image);
     m_pictureShape->update();
 }
 
@@ -330,17 +333,18 @@ void PictureShape::paint(QPainter &painter, const KoViewConverter &converter, Ko
         m_printQualityImage = QImage(); // free memory
     }
     else {
-        QPixmap pixmap;
         QString key(generate_key(imageData()->key(), pixmapSize));
 
         // If the required pixmap is not in the cache
         // launch a task in a background thread that scales
         // the source image to the required size
-        if (!QPixmapCache::find(key, &pixmap)) {
+        ImageCache::ConstIterator it = s_imageCache()->constFind(key);
+        if (it == s_imageCache()->constEnd()) {
             QThreadPool::globalInstance()->start(new _Private::PixmapScaler(this, pixmapSize));
             painter.fillRect(viewRect, QColor(Qt::gray)); // just paint a gray rect as long as we don't have the required pixmap
         }
         else {
+            QImage pixmap = it.value();
             QRectF cropRect(
                 pixmapSize.width()  * m_clippingRect.left,
                 pixmapSize.height() * m_clippingRect.top,
@@ -348,7 +352,7 @@ void PictureShape::paint(QPainter &painter, const KoViewConverter &converter, Ko
                 pixmapSize.height() * m_clippingRect.height()
             );
 
-            painter.drawPixmap(viewRect, pixmap, cropRect);
+            painter.drawImage(viewRect, pixmap, cropRect);
         }
     }
 }
@@ -376,9 +380,9 @@ void PictureShape::waitUntilReady(const KoViewConverter &converter, bool asynchr
     else {
         QSize pixmapSize = calcOptimalPixmapSize(converter.documentToView(QRectF(QPointF(0,0), size())).size(), imageData->image().size());
         QString key(generate_key(imageData->key(), pixmapSize));
-        if (QPixmapCache::find(key) == 0) {
-            QPixmap pixmap = imageData->pixmap(pixmapSize);
-            QPixmapCache::insert(key, pixmap);
+        if (!s_imageCache()->contains(key)) {
+            QImage pixmap = imageData->pixmap(pixmapSize);
+            s_imageCache()->insert(key, pixmap);
         }
     }
 }
diff --git a/plugins/pictureshape/PictureShapeFactory.cpp b/plugins/pictureshape/PictureShapeFactory.cpp
index c7786cb..9cd8b20 100644
--- a/plugins/pictureshape/PictureShapeFactory.cpp
+++ b/plugins/pictureshape/PictureShapeFactory.cpp
@@ -22,7 +22,7 @@
 #include "PictureShapeFactory.h"
 
 #include "PictureShape.h"
-#include "PictureShapeConfigWidget.h"
+//#include "PictureShapeConfigWidget.h"
 
 #include <QByteArray>
 #include <QBuffer>
@@ -114,7 +114,7 @@ bool PictureShapeFactory::supports(const KoXmlElement &e, KoShapeLoadingContext
 QList<KoShapeConfigWidgetBase*> PictureShapeFactory::createShapeOptionPanels()
 {
     QList<KoShapeConfigWidgetBase*> panels;
-    panels.append( new PictureShapeConfigWidget() );
+    //panels.append( new PictureShapeConfigWidget() );
     return panels;
 }
 
diff --git a/plugins/pictureshape/Plugin.cpp b/plugins/pictureshape/Plugin.cpp
index b167d2e..3f992ba 100644
--- a/plugins/pictureshape/Plugin.cpp
+++ b/plugins/pictureshape/Plugin.cpp
@@ -18,9 +18,9 @@
  */
 #include "Plugin.h"
 #include "PictureShapeFactory.h"
-#include "PictureToolFactory.h"
+//#include "PictureToolFactory.h"
 
-#include <QPixmapCache>
+//#include <QPixmapCache>
 
 #include <KoToolRegistry.h>
 #include <KoShapeRegistry.h>
@@ -35,12 +35,12 @@ K_EXPORT_PLUGIN(PluginFactory("PictureShape"))
 Plugin::Plugin(QObject *parent, const QVariantList &)
     : QObject(parent)
 {
-    if(QPixmapCache::cacheLimit() < CACHE_SIZE) {
-        QPixmapCache::setCacheLimit(CACHE_SIZE);
-    }
+    //if(QPixmapCache::cacheLimit() < CACHE_SIZE) {
+    //    QPixmapCache::setCacheLimit(CACHE_SIZE);
+    //}
 
     KoShapeRegistry::instance()->add( new PictureShapeFactory() );
-    KoToolRegistry::instance()->add( new PictureToolFactory() );
+    //KoToolRegistry::instance()->add( new PictureToolFactory() );
 }
 
 #include <Plugin.moc>
diff --git a/plugins/textshape/TextPlugin.cpp b/plugins/textshape/TextPlugin.cpp
index b99243f..bafee04 100644
--- a/plugins/textshape/TextPlugin.cpp
+++ b/plugins/textshape/TextPlugin.cpp
@@ -17,9 +17,9 @@
  * Boston, MA 02110-1301, USA.
  */
 #include "TextPlugin.h"
-#include "TextToolFactory.h"
-#include "ReferencesToolFactory.h"
-#include "ReviewToolFactory.h"
+// #include "TextToolFactory.h"
+// #include "ReferencesToolFactory.h"
+// #include "ReviewToolFactory.h"
 #ifdef CREATE_TEXTDOCUMENT_INSPECTOR
 #include "TextDocumentInspectionPlugin.h"
 #endif
@@ -46,9 +46,9 @@ K_EXPORT_PLUGIN(TextPluginFactory("TextShape"))
 TextPlugin::TextPlugin(QObject * parent, const QVariantList &)
         : QObject(parent)
 {
-    KoToolRegistry::instance()->add(new TextToolFactory());
-    KoToolRegistry::instance()->add(new ReviewToolFactory());
-    KoToolRegistry::instance()->add(new ReferencesToolFactory());
+//     KoToolRegistry::instance()->add(new TextToolFactory());
+//     KoToolRegistry::instance()->add(new ReviewToolFactory());
+//     KoToolRegistry::instance()->add(new ReferencesToolFactory());
     KoShapeRegistry::instance()->add(new TextShapeFactory());
 }
 
diff --git a/sheets/ui/CellToolBase.cpp b/sheets/ui/CellToolBase.cpp
index 55c499e..3cfafbc 100644
--- a/sheets/ui/CellToolBase.cpp
+++ b/sheets/ui/CellToolBase.cpp
@@ -3402,10 +3402,12 @@ void CellToolBase::spellCheck()
 void CellToolBase::inspector()
 {
     // useful to inspect objects
+#if 0
     Cell cell(selection()->activeSheet(), selection()->marker());
     QPointer<Calligra::Sheets::Inspector> ins = new Calligra::Sheets::Inspector(cell);
     ins->exec();
     delete ins;
+#endif
 }
 
 void CellToolBase::qTableView()
diff --git a/words/part/KWDocument.cpp b/words/part/KWDocument.cpp
index 57aba26..47f54d3 100644
--- a/words/part/KWDocument.cpp
+++ b/words/part/KWDocument.cpp
@@ -353,9 +353,9 @@ void KWDocument::relayout(QList<KWFrameSet*> framesets)
         KoTextDocumentLayout *lay = dynamic_cast<KoTextDocumentLayout*>(tfs->document()->documentLayout());
         Q_ASSERT(lay);
 
-        if (tfs->textFrameSetType() == Words::MainTextFrameSet && m_layoutProgressUpdater) {
-            connect(lay, SIGNAL(layoutProgressChanged(int)), this, SLOT(layoutProgressChanged(int)));
-            connect(lay, SIGNAL(finishedLayout()), this, SLOT(layoutFinished()));
+        if (tfs->textFrameSetType() == Words::MainTextFrameSet) {
+            connect(lay, SIGNAL(layoutProgressChanged(int)), this, SLOT(slotLayoutProgressChanged(int)));
+            connect(lay, SIGNAL(finishedLayout()), this, SLOT(slotLayoutFinished()));
         }
 
         // schedule all calls so multiple layout calls are compressed
@@ -365,19 +365,21 @@ void KWDocument::relayout(QList<KWFrameSet*> framesets)
     firePageSetupChanged();
 }
 
-void KWDocument::layoutProgressChanged(int percent)
+void KWDocument::slotLayoutProgressChanged(int percent)
 {
-    Q_ASSERT(m_layoutProgressUpdater);
-    m_layoutProgressUpdater->setProgress(percent);
+    if (m_layoutProgressUpdater)
+        m_layoutProgressUpdater->setProgress(percent);
 }
 
-void KWDocument::layoutFinished()
+void KWDocument::slotLayoutFinished()
 {
-    Q_ASSERT(m_layoutProgressUpdater);
-    disconnect(QObject::sender(), SIGNAL(layoutProgressChanged(int)), this, SLOT(layoutProgressChanged(int)));
-    disconnect(QObject::sender(), SIGNAL(finishedLayout()), this, SLOT(layoutFinished()));
-    m_layoutProgressUpdater->setProgress(100);
-    m_layoutProgressUpdater = 0; // free the instance
+    if (m_layoutProgressUpdater) {
+        disconnect(QObject::sender(), SIGNAL(layoutProgressChanged(int)), this, SLOT(slotLayoutProgressChanged(int)));
+        disconnect(QObject::sender(), SIGNAL(finishedLayout()), this, SLOT(slotLayoutFinished()));
+        m_layoutProgressUpdater->setProgress(100);
+        m_layoutProgressUpdater = 0; // free the instance
+    }
+    emit layoutFinished();
 }
 
 void KWDocument::addFrameSet(KWFrameSet *fs)
@@ -526,6 +528,16 @@ QString KWDocument::renameFrameSet(const QString &prefix, const QString &base)
     }
 }
 
+QByteArray KWDocument::nativeFormatMimeType() const
+{
+    return QByteArray("application/vnd.oasis.opendocument.text");
+}
+
+QByteArray KWDocument::nativeOasisMimeType() const
+{
+    return QByteArray();
+}
+
 // *** LOADING
 
 void KWDocument::initEmpty()
diff --git a/words/part/KWDocument.h b/words/part/KWDocument.h
index 7654aa3..72f0c60 100644
--- a/words/part/KWDocument.h
+++ b/words/part/KWDocument.h
@@ -175,6 +175,8 @@ public:
     void firePageSetupChanged();
 
     // reimplemented slot from KoDocument
+    virtual QByteArray nativeFormatMimeType() const;
+    virtual QByteArray nativeOasisMimeType() const;
     virtual void initEmpty();
 
     bool layoutFinishedAtleastOnce() const { return m_mainFramesetEverFinished; }
@@ -226,6 +228,9 @@ signals:
     /// signal emitted when a page has been added
     void pageSetupChanged();
 
+    /// signal emitted when layouting finished
+    void layoutFinished();
+
     /// emitted whenever a shape is added.
     void shapeAdded(KoShape *, KoShapeManager::Repaint);
 
@@ -242,8 +247,8 @@ private slots:
     /// Called after the constructor figures out there is an install problem.
     void mainTextFrameSetLayoutDone();
 
-    void layoutProgressChanged(int percent);
-    void layoutFinished();
+    void slotLayoutProgressChanged(int percent);
+    void slotLayoutFinished();
 
 protected:
     /// reimplemented from KoDocument
