/* This file is part of the KDE project
   Copyright (C) 2004-2006 David Faure <faure@kde.org>
   Copyright (C) 2007 Thorsten Zachmann <zachmann@kde.org>
   Copyright (C) 2010 Thomas Zander <zander@kde.org>
   Copyright (C) 2011 Inge Wallin <inge@lysator.liu.se>

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public License
   along with this library; see the file COPYING.LIB.  If not, write to
   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
*/

#include "KoEmbeddedFileSaver.h"

#include <QList>
#include <QHash>
#include <QByteArray>

#include <kdebug.h>

#include <KoStore.h>
#include <KoXmlWriter.h>
#include <KoOdfWriteStore.h>

#include "KoOdfDocument.h"


#define INTERNAL_PROTOCOL "intern"

struct FileEntry {
    QString     path;
    QByteArray  mimeType;       // QBA because this is what addManifestEntry wants
    QByteArray  contents;
};

class KoEmbeddedFileSaver::Private
{
public:
    Private() {}

    QHash<QString, int>  prefixes; // Used in getFilename();
    QList<FileEntry*>    files;    // These will be saved when saveEmbeddedFiles() are called.
};


KoEmbeddedFileSaver::KoEmbeddedFileSaver()
    : d(new Private())
{
}

KoEmbeddedFileSaver::~KoEmbeddedFileSaver()
{
    qDeleteAll(d->files);
    delete d;
}


QString KoEmbeddedFileSaver::getFilename(const QString &prefix)
{
    int index = 1;
    if (d->prefixes.contains(prefix)) {
        index = d->prefixes.value(prefix);
    }

    // This inserts prefix into the map if it's not there.
    d->prefixes[prefix] = index + 1;

    return prefix + QString("%1").arg(index, 4, 10, QChar('0'));
}

// Examples:
// Videos/Video1.mov  ← the number is autogenerated
// Videos/Video2.mov
// Object1/foo  ← the number is autogenerated
// Object1/bar   

// Note: The contents QByteArray is implicitly shared.  It should not be a
//       reference since then the actual array may disappear before
//       the real saving is done.
//
void KoEmbeddedFileSaver::embedFile(KoXmlWriter &writer, const char *element,
                                    const QString &path, const QByteArray &mimeType,
                                    QByteArray contents)
{
    // Put the file in the list of files to be written to the store later.
    FileEntry  *entry = new FileEntry;
    entry->mimeType = mimeType;
    entry->path     = path;
    entry->contents = contents;
    d->files.append(entry);

    writer.startElement(element);
    // Write the attributes that refer to the file.

    //<draw:object draw:style-name="standard" draw:id="1"
    //             draw:layer="layout" svg:width="14.973cm"
    //             svg:height="4.478cm" svg:x="11.641cm"
    //             svg:y="14.613cm" xlink:href="#./Object 1"
    //             xlink:type="simple" xlink:show="embed"
    //             xlink:actuate="onLoad"/>
    writer.addAttribute("xlink:type", "simple");
    writer.addAttribute("xlink:show", "embed");
    writer.addAttribute("xlink:actuate", "onLoad");

    kDebug(30003) << "saving reference to embedded file as" << path;
    writer.addAttribute("xlink:href", path);
    writer.endElement();
}

void KoEmbeddedFileSaver::saveFile(const QString &path, const QByteArray &mimeType,
                                   QByteArray contents)
{
    // Put the file in the list of files to be written to the store later.
    FileEntry  *entry = new FileEntry;
    entry->mimeType = mimeType;
    entry->path     = path;
    entry->contents = contents;
    d->files.append(entry);

    kDebug(30003) << "saving reference to embedded file as" << path;
}

bool KoEmbeddedFileSaver::saveEmbeddedFiles(KoOdfDocument::SavingContext &documentContext)
{
    KoStore * store = documentContext.odfStore.store();
    foreach(FileEntry *entry, d->files) {
        QString path = entry->path;
        kDebug(30003) << "saving" << path;

        // To make the children happy cd to the correct directory
        store->pushDirectory();

        int index = path.lastIndexOf('/');
        const QString dirPath = path.left(index);
        const QString fileName = path.right(path.size() - index - 1);
        store->enterDirectory(dirPath);

#if 0
        if (!doc->saveOdf(documentContext)) {
            kWarning(30003) << "KoEmbeddedDocumentSaver::saveEmbeddedFile failed";
            return false;
        }
#else
        if (!store->open(fileName)) {
            return false;
        }
        store->write(entry->contents);
        store->close();

#endif
        // Now that we're done leave the directory again
        store->popDirectory();

        // Create the manifest entry.
        if (path.startsWith('/')) {
            path = path.mid(1);   // remove leading '/', no wanted in manifest
        }
        documentContext.odfStore.manifestWriter()->addManifestEntry(path, entry->mimeType);
    }

    return true;
}
