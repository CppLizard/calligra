/* This code was generated by msoscheme (http://gitorious.org/msoscheme) */
#include "api.h"
const quint32 MSO::RecordHeader::_size = 8;
MSO::RecordHeader::RecordHeader(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_recVer = readuint4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_recInstance = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    m_recType = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_recLen = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::CurrentUserAtom::CurrentUserAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FF6)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_size = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_size) == 0x14)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_headerToken = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_headerToken) == 0xE391C05F || ((quint32)m_headerToken) == 0xF3D1C4DF)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_offsetToCurrentEdit = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_lenUserName = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_lenUserName)<=255)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_docFileVersion = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_docFileVersion) == 0x03F4)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_majorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_majorVersion) == 0x03)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_minorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_minorVersion) == 0x00)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_ansiUserName = MSOCastArray<char>((const char*)(_d + _position), lenUserName());
    _msize = (lenUserName())*1;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_relVersion = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_relVersion) == 0x8 || ((quint32)m_relVersion) == 0x9)) {
         return;
    }
    _position += _msize;
    bool _has_unicodeUserName = rh().recLen()>3*lenUserName()+0x18;
    if (_has_unicodeUserName) {
        m_unicodeUserName = MSOCastArray<quint16>((const quint16*)(_d + _position), lenUserName());
        _msize = (lenUserName())*2;
        _position += _msize;
    }
    bool _has_unknown = rh().recLen()-0x18-3*lenUserName()>0;
    if (_has_unknown) {
        m_unknown = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-0x18-3*lenUserName());
        _msize = (rh().recLen()-0x18-3*lenUserName())*1;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TODOS::TODOS(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    m_anon = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (!m_anon.isValid()) return;
    _msize = m_anon.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::Byte::_size = 1;
MSO::Byte::Byte(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ZeroByte::_size = 1;
MSO::ZeroByte::ZeroByte(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_b) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::CurrentUserStream::CurrentUserStream(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon1 = CurrentUserAtom(_d + _position, _maxsize - _position);
    if (!m_anon1.isValid()) return;
    _msize = m_anon1.getSize();
    _position += _msize;
    m_trailing = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (!m_trailing.isValid()) return;
    _msize = m_trailing.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBStoreDelay::OfficeArtBStoreDelay(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    m_rgfb = MSOArray<OfficeArtBStoreContainerFileBlock>(_d + _position, _maxsize - _position);
    if (!m_rgfb.isValid()) return;
    _msize = m_rgfb.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtRecordHeader::_size = 8;
MSO::OfficeArtRecordHeader::OfficeArtRecordHeader(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_recVer = readuint4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_recInstance = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    m_recType = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_recLen = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OfficeArtBlipJPEG::OfficeArtBlipJPEG(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x46A || rh().recInstance() == 0x46B || rh().recInstance() == 0x6E2 || rh().recInstance() == 0x6E3)) {
         return;
    }
    if (!(rh().recType() == 0xF01D)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x46B || rh().recInstance() == 0x6E3;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    m_tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance() == 0x46A || rh().recInstance() == 0x6E2)?17:33));
    _msize = (rh().recLen()-((rh().recInstance() == 0x46A || rh().recInstance() == 0x6E2)?17:33))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBlipPNG::OfficeArtBlipPNG(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x6E0 || rh().recInstance() == 0x6E1)) {
         return;
    }
    if (!(rh().recType() == 0xF01E)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x6E1;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    m_tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance()==0x6E0)?17:33));
    _msize = (rh().recLen()-((rh().recInstance()==0x6E0)?17:33))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBlipDIB::OfficeArtBlipDIB(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x7A8 || rh().recInstance() == 0x7A9)) {
         return;
    }
    if (!(rh().recType() == 0xF01F)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x7A9;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    m_tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance()==0x7A8)?17:33));
    _msize = (rh().recLen()-((rh().recInstance()==0x7A8)?17:33))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBlipTIFF::OfficeArtBlipTIFF(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x6E4 || rh().recInstance() == 0x6E5)) {
         return;
    }
    if (!(rh().recType() == 0xF020)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x6E5;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    m_tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance()==0x6E4)?17:33));
    _msize = (rh().recLen()-((rh().recInstance()==0x6E4)?17:33))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::RECT::_size = 16;
MSO::RECT::RECT(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_left = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_top = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_right = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_bottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::POINT::_size = 8;
MSO::POINT::POINT(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_x = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_y = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PowerPointStructs::PowerPointStructs(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    m_anon = MSOArray<PowerPointStruct>(_d + _position, _maxsize - _position);
    if (!m_anon.isValid()) return;
    _msize = m_anon.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::SoundCollectionAtom::_size = 12;
MSO::SoundCollectionAtom::SoundCollectionAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x7e5)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_soundIdSeed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::HeadersFootersAtom::_size = 12;
MSO::HeadersFootersAtom::HeadersFootersAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFDA)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_formatId = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)m_formatId)>=0)) {
         return;
    }
    if (!(((qint16)m_formatId)<=13)) {
         return;
    }
    _position += _msize;
    m_fHasDate = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasTodayDate = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasUserDate = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasSlideNumber = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasHeader = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasFooter = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    m_reserved2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::UserDateAtom::UserDateAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    if (!(rh().recLen()<=510)) {
         return;
    }
    _position += _msize;
    m_userDate = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::HeaderAtom::HeaderAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_header = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::FooterAtom::FooterAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 2)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_footer = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PerSlideHeadersFootersContainer::PerSlideHeadersFootersContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFD9)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_hfAtom = HeadersFootersAtom(_d + _position);
    if (!m_hfAtom.isValid()) return;
    _msize = m_hfAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_userDateAtom = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (m_userDateAtom.isPresent()) ?m_userDateAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_headerAtom = HeaderAtom(_d + _position, _maxsize - _position);
        _msize = (m_headerAtom.isPresent()) ?m_headerAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_footerAtom = FooterAtom(_d + _position, _maxsize - _position);
        _msize = (m_footerAtom.isPresent()) ?m_footerAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_userDateAtom2 = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (m_userDateAtom2.isPresent()) ?m_userDateAtom2.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
const quint32 MSO::EndDocumentAtom::_size = 8;
MSO::EndDocumentAtom::EndDocumentAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3EA)) {
         return;
    }
    if (!(rh().recLen() == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::DocInfoListContainer::DocInfoListContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x7D0)) {
         return;
    }
    _position += _msize;
    m_rgChildRec = MSOArray<DocInfoListSubContainerOrAtom>(_d + _position, _maxsize - _position);
    if (!m_rgChildRec.isValid()) return;
    _msize = m_rgChildRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::SlideViewInfoAtom::_size = 11;
MSO::SlideViewInfoAtom::SlideViewInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3FE)) {
         return;
    }
    if (!(rh().recLen() == 3)) {
         return;
    }
    _position += _msize;
    m_unused1 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fSnapToGrid = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fSnapToShape = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GuideAtom::_size = 16;
MSO::GuideAtom::GuideAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 7)) {
         return;
    }
    if (!(rh().recType() == 0x3FB)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_type = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_type) == 0 || ((quint32)m_type) == 1)) {
         return;
    }
    _position += _msize;
    m_pos = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_pos)>=-15840)) {
         return;
    }
    if (!(((qint32)m_pos)<=32255)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::DocProgTagsContainer::DocProgTagsContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x1388)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgChildRec = MSOArray<DocProgTagsSubContainerOrAtom>(_d + _position, rh().recLen());
    if (m_rgChildRec.getSize() != rh().recLen()) return;
    _msize = m_rgChildRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::TextAutoNumberScheme::_size = 4;
MSO::TextAutoNumberScheme::TextAutoNumberScheme(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_scheme = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_scheme)<=40)) {
         return;
    }
    _position += _msize;
    m_startNum = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_startNum)>=1)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::BlipCollection9Container::BlipCollection9Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x07F8)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgBlipEntityAtom = MSOArray<BlipEntityAtom>(_d + _position, rh().recLen());
    if (m_rgBlipEntityAtom.getSize() != rh().recLen()) return;
    _msize = m_rgBlipEntityAtom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::Kinsoku9Atom::_size = 12;
MSO::Kinsoku9Atom::Kinsoku9Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x3)) {
         return;
    }
    if (!(rh().recType() == 0x0FD2)) {
         return;
    }
    if (!(rh().recLen() == 0x0004)) {
         return;
    }
    _position += _msize;
    m_korLevel = readuint2(_d + _position);
    _msize = 0;
    if (!(((quint8)m_korLevel) == 0x0 || ((quint8)m_korLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    m_scLevel = readuint2_2(_d + _position);
    _msize = 0;
    if (!(((quint8)m_scLevel) == 0x0 || ((quint8)m_scLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    m_tcLevel = readuint2_4(_d + _position);
    _msize = 0;
    if (!(((quint8)m_tcLevel) == 0x0 || ((quint8)m_tcLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    m_jpnLevel = readuint2_6(_d + _position);
    _msize = 1;
    if (!(((quint8)m_jpnLevel) == 0x0 || ((quint8)m_jpnLevel) == 0x1 || ((quint8)m_jpnLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    m_reserveda = readuint4(_d + _position);
    _msize = 0;
    if (!(((quint8)m_reserveda) == 0)) {
         return;
    }
    _position += _msize;
    m_reservedb = readuint20_4(_d + _position);
    _msize = 3;
    if (!(((quint32)m_reservedb) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ExHyperlink9Container::ExHyperlink9Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFE4)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::PresAdvisorFlags9Atom::_size = 12;
MSO::PresAdvisorFlags9Atom::PresAdvisorFlags9Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x177A)) {
         return;
    }
    if (!(rh().recLen() == 0x4)) {
         return;
    }
    _position += _msize;
    m_fDisableCaseStyleTitleRule = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableCaseStyleBodyRule = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableEndPunctuationTitleRule = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableEndPunctuationBodyRule = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableTooManyBulletsRule = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableFontSizeTitleRule = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableFontSizeBodyRule = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableNumberOfLinesTitleRule = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fDisableNumberOfLinesBodyRule = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisableTooManyFontsRule = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDisablePrintTip = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserveda = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserveda) == 0)) {
         return;
    }
    _position += _msize;
    m_reservedb = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_reservedb) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::EnvelopeData9Atom::EnvelopeData9Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1785)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::EnvelopeFlags9Atom::_size = 12;
MSO::EnvelopeFlags9Atom::EnvelopeFlags9Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1784)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_fHasEnvelope = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fEnvelopeVisible = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readuint2_2(_d + _position);
    _msize = 0;
    if (!(((quint8)m_reserved1) == 0)) {
         return;
    }
    _position += _msize;
    m_fEnvelopeDirty = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2a = readuint3_5(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2a) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved2b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2b) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved2c = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_reserved2c) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::HTMLDocInfo9Atom::_size = 24;
MSO::HTMLDocInfo9Atom::HTMLDocInfo9Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x177B)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    m_unused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_encoding = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_frameColorType = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_frameColorType) == 0 || ((quint16)m_frameColorType) == 1 || ((quint16)m_frameColorType) == 2 || ((quint16)m_frameColorType) == 3 || ((quint16)m_frameColorType) == 4 || ((quint16)m_frameColorType) == 5)) {
         return;
    }
    _position += _msize;
    m_screenSize = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_outputType = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fShowFrame = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fResizeGraphics = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fOrganizeInFolder = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseLongFileNames = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fRelyOnVML = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fAllowPNG = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fShowSlideAnimation = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readbit_7(_d + _position);
    _msize = 1;
    if (!(((bool)m_reserved1) == false)) {
         return;
    }
    _position += _msize;
    m_unused3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::HTMLPublishInfo9Container::HTMLPublishInfo9Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x177D)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::BroadcastDocInfo9Container::BroadcastDocInfo9Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x177E)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OutlineTextProps9Container::OutlineTextProps9Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FAE)) {
         return;
    }
    _position += _msize;
    m_rgOutlineTextProps9Entry = MSOArray<OutlineTextProps9Entry>(_d + _position, _maxsize - _position);
    if (!m_rgOutlineTextProps9Entry.isValid()) return;
    _msize = m_rgOutlineTextProps9Entry.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OutlineTextPropsHeaderExAtom::_size = 16;
MSO::OutlineTextPropsHeaderExAtom::OutlineTextPropsHeaderExAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance()<=5)) {
         return;
    }
    if (!(rh().recType() == 0xFAF)) {
         return;
    }
    _position += _msize;
    m_slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_txType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::StyleTextProp9Atom::StyleTextProp9Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFAC)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgStyleTextProp9 = MSOArray<StyleTextProp9>(_d + _position, rh().recLen());
    if (m_rgStyleTextProp9.getSize() != rh().recLen()) return;
    _msize = m_rgStyleTextProp9.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::FontCollection10Container::FontCollection10Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x07D6)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgFontCollectionEntry = MSOArray<FontCollectionEntry>(_d + _position, rh().recLen());
    if (m_rgFontCollectionEntry.getSize() != rh().recLen()) return;
    _msize = m_rgFontCollectionEntry.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::GridSpacing10Atom::_size = 16;
MSO::GridSpacing10Atom::GridSpacing10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x040D)) {
         return;
    }
    if (!(rh().recLen() == 0x08)) {
         return;
    }
    _position += _msize;
    m_x = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_x)>=23224)) {
         return;
    }
    if (!(((quint32)m_x)<=1179648)) {
         return;
    }
    _position += _msize;
    m_y = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_y)>=23224)) {
         return;
    }
    if (!(((quint32)m_y)<=1179648)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::AuthorNameAtom::AuthorNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()<=104)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_authorName = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::CommentIndex10Atom::_size = 16;
MSO::CommentIndex10Atom::CommentIndex10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x2EE5)) {
         return;
    }
    if (!(rh().recLen() == 0x08)) {
         return;
    }
    _position += _msize;
    m_colorIndex = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_colorIndex)>=0)) {
         return;
    }
    _position += _msize;
    m_commentIndexSeed = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_commentIndexSeed)>=0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FontEmbedFlags10Atom::_size = 12;
MSO::FontEmbedFlags10Atom::FontEmbedFlags10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x32C8)) {
         return;
    }
    if (!(rh().recLen() == 0x04)) {
         return;
    }
    _position += _msize;
    m_fSubset = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSubsetOptionConfirmed = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unuseda = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    m_unusedb = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::CopyrightAtom::CopyrightAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x1)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()<=510)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_copyright = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::KeywordsAtom::KeywordsAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x2)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()<=510)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_keywords = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::FilterPrivacyFlags10Atom::_size = 12;
MSO::FilterPrivacyFlags10Atom::FilterPrivacyFlags10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x36B0)) {
         return;
    }
    if (!(rh().recLen() == 0x04)) {
         return;
    }
    _position += _msize;
    m_fRemovePII = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2a = readuint7_1(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2a) == 0x0)) {
         return;
    }
    _position += _msize;
    m_reserved2b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2b) == 0x0)) {
         return;
    }
    _position += _msize;
    m_reserved2c = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_reserved2c) == 0x0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OutlineTextProps10Container::OutlineTextProps10Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FB3)) {
         return;
    }
    _position += _msize;
    m_rgOutlineTextProps10Entry = MSOArray<OutlineTextProps10Entry>(_d + _position, _maxsize - _position);
    if (!m_rgOutlineTextProps10Entry.isValid()) return;
    _msize = m_rgOutlineTextProps10Entry.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::StyleTextProp10Atom::StyleTextProp10Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0xFB1)) {
         return;
    }
    _position += _msize;
    m_rgStyleTextProp10 = MSOArray<TextCFException10>(_d + _position, _maxsize - _position);
    if (!m_rgStyleTextProp10.isValid()) return;
    _msize = m_rgStyleTextProp10.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::DocToolbarStates10Atom::_size = 9;
MSO::DocToolbarStates10Atom::DocToolbarStates10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x36B1)) {
         return;
    }
    if (!(rh().recLen() == 0x01)) {
         return;
    }
    _position += _msize;
    m_fShowReviewingToolbar = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fShowReviewingGallery = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint6_2(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved) == 0x0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SlideListTable10Container::SlideListTable10Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EF1)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::DiffTree10Container::DiffTree10Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EEC)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ModifyPasswordAtom::ModifyPasswordAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x03)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()<=510)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_modifyPassword = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::PhotoAlbumInfo10Atom::_size = 14;
MSO::PhotoAlbumInfo10Atom::PhotoAlbumInfo10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x036B2)) {
         return;
    }
    if (!(rh().recLen() == 0x06)) {
         return;
    }
    _position += _msize;
    m_fUseBlackWhite = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fHasCaption = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_layout = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_layout) == 0 || ((quint8)m_layout) == 1 || ((quint8)m_layout) == 2 || ((quint8)m_layout) == 3 || ((quint8)m_layout) == 4 || ((quint8)m_layout) == 5 || ((quint8)m_layout) == 6)) {
         return;
    }
    _position += _msize;
    m_unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_frameShape = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_frameShape) == 0x0000 || ((quint16)m_frameShape) == 0x0001 || ((quint16)m_frameShape) == 0x0002 || ((quint16)m_frameShape) == 0x0003 || ((quint16)m_frameShape) == 0x0004 || ((quint16)m_frameShape) == 0x0005 || ((quint16)m_frameShape) == 0x0006)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SmartTagStore11Container::SmartTagStore11Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x36B3)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OutlineTextProps11Container::OutlineTextProps11Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FB5)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::BinaryTagDataBlob::BinaryTagDataBlob(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP12DocBinaryTagExtension::PP12DocBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0x0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rhData().recLen());
    _msize = (rhData().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SorterViewInfoContainer::SorterViewInfoContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x408)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::VBAInfoAtom::_size = 20;
MSO::VBAInfoAtom::VBAInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 2)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x400)) {
         return;
    }
    if (!(rh().recLen() == 0xC)) {
         return;
    }
    _position += _msize;
    m_persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fHasMacros = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_fHasMacros) == 0 || ((quint32)m_fHasMacros) == 1)) {
         return;
    }
    _position += _msize;
    m_version = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_version) == 0 || ((quint32)m_version) == 1 || ((quint32)m_version) == 2)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::MasterListWithTextContainer::MasterListWithTextContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x1)) {
         return;
    }
    if (!(rh().recType() == 0x0FF0)) {
         return;
    }
    if (!(rh().recLen()%28==0)) {
         return;
    }
    _position += _msize;
    m_rgMasterPersistAtom = MSOArray<MasterPersistAtom>(_d + _position, 28 * rh().recLen()/28, rh().recLen()/28);
    if (m_rgMasterPersistAtom.getCount() != rh().recLen()/28) return;
    _msize = m_rgMasterPersistAtom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::MasterPersistAtom::_size = 28;
MSO::MasterPersistAtom::MasterPersistAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3F3)) {
         return;
    }
    if (!(rh().recLen() == 0x14)) {
         return;
    }
    _position += _msize;
    m_persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved1 = readuint2(_d + _position);
    _msize = 0;
    if (!(((quint8)m_reserved1) == 0)) {
         return;
    }
    _position += _msize;
    m_fNonOutLineData = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2 = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved3 = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved3) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved4 = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_reserved4) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved5 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved5) == 0)) {
         return;
    }
    _position += _msize;
    m_masterId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved6 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved6) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SlideListWithTextContainer::SlideListWithTextContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FF0)) {
         return;
    }
    _position += _msize;
    m_rgChildRec = MSOArray<SlideListWithTextSubContainerOrAtom>(_d + _position, _maxsize - _position);
    if (!m_rgChildRec.isValid()) return;
    _msize = m_rgChildRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::NotesListWithTextContainer::NotesListWithTextContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 2)) {
         return;
    }
    if (!(rh().recType() == 0x0FF0)) {
         return;
    }
    _position += _msize;
    m_rgNotesPersistAtom = MSOArray<NotesPersistAtom>(_d + _position, _maxsize - _position);
    if (!m_rgNotesPersistAtom.isValid()) return;
    _msize = m_rgNotesPersistAtom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::NotesPersistAtom::_size = 28;
MSO::NotesPersistAtom::NotesPersistAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x03F3)) {
         return;
    }
    if (!(rh().recLen() == 0x14)) {
         return;
    }
    _position += _msize;
    m_persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved1 = readuint2(_d + _position);
    _msize = 0;
    if (!(((quint8)m_reserved1) == 0)) {
         return;
    }
    _position += _msize;
    m_fNonOutlineData = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2a = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2a) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved2b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2b) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved2c = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_reserved2c) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved3 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved3) == 0)) {
         return;
    }
    _position += _msize;
    m_notesId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved4 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved4) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::TextHeaderAtom::_size = 12;
MSO::TextHeaderAtom::TextHeaderAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1 || rh().recInstance() == 2 || rh().recInstance() == 3 || rh().recInstance() == 4 || rh().recInstance() == 5)) {
         return;
    }
    if (!(rh().recType() == 0xF9F)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_textType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TextCharsAtom::TextCharsAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFA0)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_textChars = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextBytesAtom::TextBytesAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFA8)) {
         return;
    }
    _position += _msize;
    m_textChars = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::MasterTextPropAtom::MasterTextPropAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFA2)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgMasterTextPropRun = MSOArray<MasterTextPropRun>(_d + _position, rh().recLen());
    if (m_rgMasterTextPropRun.getSize() != rh().recLen()) return;
    _msize = m_rgMasterTextPropRun.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::MasterTextPropRun::_size = 6;
MSO::MasterTextPropRun::MasterTextPropRun(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_count = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_indentLevel = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_indentLevel)<=4)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::StyleTextPropAtom::StyleTextPropAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFA1)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::SlideNumberMCAtom::_size = 12;
MSO::SlideNumberMCAtom::SlideNumberMCAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFD8)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DateTimeMCAtom::_size = 16;
MSO::DateTimeMCAtom::DateTimeMCAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFF7)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_index = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = MSOCastArray<char>((const char*)(_d + _position), 3);
    _msize = (3)*1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GenericDateMCAtom::_size = 12;
MSO::GenericDateMCAtom::GenericDateMCAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFF8)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::HeaderMCAtom::_size = 12;
MSO::HeaderMCAtom::HeaderMCAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFF9)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FooterMCAtom::_size = 12;
MSO::FooterMCAtom::FooterMCAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFFA)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::RTFDateTimeMCAtom::_size = 140;
MSO::RTFDateTimeMCAtom::RTFDateTimeMCAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1015)) {
         return;
    }
    if (!(rh().recLen() == 0x84)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_format = MSOCastArray<char>((const char*)(_d + _position), 128);
    _msize = (128)*1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::TextBookmarkAtom::_size = 20;
MSO::TextBookmarkAtom::TextBookmarkAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFA7)) {
         return;
    }
    if (!(rh().recLen() == 0xC)) {
         return;
    }
    _position += _msize;
    m_begin = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_end = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_bookmarkID = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::TextRange::_size = 8;
MSO::TextRange::TextRange(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_begin = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_end = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::MouseClickTextInteractiveInfoAtom::_size = 16;
MSO::MouseClickTextInteractiveInfoAtom::MouseClickTextInteractiveInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFDF)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_range = TextRange(_d + _position);
    if (!m_range.isValid()) return;
    _msize = m_range.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::MouseOverTextInteractiveInfoAtom::_size = 16;
MSO::MouseOverTextInteractiveInfoAtom::MouseOverTextInteractiveInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0xFDF)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_range = TextRange(_d + _position);
    if (!m_range.isValid()) return;
    _msize = m_range.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::SlideId::_size = 4;
MSO::SlideId::SlideId(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_slideId = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_slideId)>=100)) {
         return;
    }
    if (!(((quint32)m_slideId)<2147483647)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TabStops::TabStops(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_count = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_rgTabStop = MSOArray<TabStop>(_d + _position, 4 * count(), count());
    if (m_rgTabStop.getCount() != count()) return;
    _msize = m_rgTabStop.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::TabStop::_size = 4;
MSO::TabStop::TabStop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_position = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_type = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PFWrapFlags::_size = 2;
MSO::PFWrapFlags::PFWrapFlags(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_charWrap = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_wordWrap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_overflow = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readuint5_3(_d + _position);
    _msize = 1;
    _position += _msize;
    m_reserved2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ColorIndexStruct::_size = 4;
MSO::ColorIndexStruct::ColorIndexStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_index = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BulletFlags::_size = 2;
MSO::BulletFlags::BulletFlags(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fHasBullet = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fBulletHasFont = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fBulletHasColor = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fBulletHasSize = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PFMasks::_size = 4;
MSO::PFMasks::PFMasks(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_hasBullet = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletHasFont = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletHasColor = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletHasSize = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletFont = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletColor = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletSize = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletChar = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_leftMargin = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_indent = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_align = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_lineSpacing = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_spaceBefore = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_spaceAfter = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_defaultTabSize = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fontAlign = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_charWrap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_wordWrap = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_overflow = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_tabStops = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_textDirection = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletBlip = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_bulletScheme = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_bulletHasScheme = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CFMasks::_size = 4;
MSO::CFMasks::CFMasks(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_bold = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_italic = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_underline = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_shadow = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fehint = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_kumi = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused3 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_emboss = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasStyle = readuint4_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused4 = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    m_typeface = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_size = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_color = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_position = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_pp10ext = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_oldEATypeface = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_ansiTypeface = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_symbolTypeface = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_newEATypeface = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_csTypeface = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_pp11ext = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint5_3(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CFStyle::_size = 2;
MSO::CFStyle::CFStyle(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_bold = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_italic = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_underline = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_shadow = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fehint = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_kumi = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused3 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_emboss = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_pp9rt = readuint4_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused4 = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::FontCollectionContainer::FontCollectionContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x07D5)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgFontCollectionEntry = MSOArray<FontCollectionEntry>(_d + _position, rh().recLen());
    if (m_rgFontCollectionEntry.getSize() != rh().recLen()) return;
    _msize = m_rgFontCollectionEntry.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::FontEntityAtom::_size = 76;
MSO::FontEntityAtom::FontEntityAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance()<=128)) {
         return;
    }
    if (!(rh().recType() == 0xFB7)) {
         return;
    }
    if (!(rh().recLen() == 0x44)) {
         return;
    }
    _position += _msize;
    m_lfFaceName = MSOCastArray<quint16>((const quint16*)(_d + _position), 32);
    _msize = (32)*2;
    _position += _msize;
    m_lfCharSet = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fEmbedSubsetted = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused = readuint7_1(_d + _position);
    _msize = 1;
    _position += _msize;
    m_rasterFontType = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_deviceFontType = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_truetypeFontType = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fNoFontSubstitution = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint4_4(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved) == 0)) {
         return;
    }
    _position += _msize;
    m_lfPitchAndFamily = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::FontEmbedDataBlob::FontEmbedDataBlob(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance()<=3)) {
         return;
    }
    if (!(rh().recType() == 0xFB8)) {
         return;
    }
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::KinsokuAtom::_size = 12;
MSO::KinsokuAtom::KinsokuAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x3)) {
         return;
    }
    if (!(rh().recType() == 0x0FD2)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_level = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_level) == 0 || ((quint32)m_level) == 1 || ((quint32)m_level) == 2 || ((quint32)m_level) == 128)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::KinsokuLeadingAtom::KinsokuLeadingAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_kinsokuLeading = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::KinsokuFollowingAtom::KinsokuFollowingAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 1 )) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_kinsokuFollowing = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextSpecialInfoAtom::TextSpecialInfoAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0xFAA)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgSIRun = MSOArray<TextSIRun>(_d + _position, rh().recLen());
    if (m_rgSIRun.getSize() != rh().recLen()) return;
    _msize = m_rgSIRun.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SmartTags::SmartTags(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_count = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_rgSmartTagIndex = MSOCastArray<quint32>((const quint32*)(_d + _position), count());
    _msize = (count())*4;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::ExOleEmbedAtom::_size = 16;
MSO::ExOleEmbedAtom::ExOleEmbedAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FCD)) {
         return;
    }
    if (!(rh().recLen() == 0x8)) {
         return;
    }
    _position += _msize;
    m_exColorFollow = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_exColorFollow) == 0 || ((quint32)m_exColorFollow) == 1 || ((quint32)m_exColorFollow) == 2)) {
         return;
    }
    _position += _msize;
    m_fCantLockServer = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fNoSizeToServer = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fIsTable = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PointStruct::_size = 8;
MSO::PointStruct::PointStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_x = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_y = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::RatioStruct::_size = 8;
MSO::RatioStruct::RatioStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_numer = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_denom = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_denom)!= 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PersistDirectoryAtom::PersistDirectoryAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1772)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgPersistDirEntry = MSOArray<PersistDirectoryEntry>(_d + _position, rh().recLen());
    if (m_rgPersistDirEntry.getSize() != rh().recLen()) return;
    _msize = m_rgPersistDirEntry.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UnknownDocumentContainerChild::UnknownDocumentContainerChild(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recType() == 0x416 || rh().recType() == 0x41A || rh().recType() == 0x101A || rh().recType() == 0x1773 || rh().recType() == 0x1788 || rh().recType() == 0x178c || rh().recType() == 0x178d)) {
         return;
    }
    _position += _msize;
    m_unknown = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UnknownOfficeArtClientDataChild::UnknownOfficeArtClientDataChild(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFE8 || rh().recType() == 0x1019)) {
         return;
    }
    _position += _msize;
    m_unknown = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UnknownSlideContainerChild::UnknownSlideContainerChild(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x101D)) {
         return;
    }
    _position += _msize;
    m_unknown = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UnknownTextContainerChild::UnknownTextContainerChild(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 3)) {
         return;
    }
    if (!(rh().recInstance() == 9)) {
         return;
    }
    if (!(rh().recType() == 0)) {
         return;
    }
    _position += _msize;
    m_unknown = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PersistDirectoryEntry::PersistDirectoryEntry(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_persistId = readuint20(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_cPersist = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    m_rgPersistOffset = MSOCastArray<quint32>((const quint32*)(_d + _position), cPersist());
    _msize = (cPersist())*4;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::PersistIdRef::_size = 4;
MSO::PersistIdRef::PersistIdRef(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_anon = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SchemeListElementColorSchemeAtom::SchemeListElementColorSchemeAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 6)) {
         return;
    }
    if (!(rh().recType() == 0x7F0)) {
         return;
    }
    if (!(rh().recLen() == 0x20)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_rgSchemeColor = MSOArray<ColorStruct>(_d + _position, 4 * 8, 8);
    if (m_rgSchemeColor.getCount() != 8) return;
    _msize = m_rgSchemeColor.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::RoundTripOArtTextStyles12Atom::RoundTripOArtTextStyles12Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x423)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SlideNameAtom::SlideNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 3)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_slideName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SlideProgTagsContainer::SlideProgTagsContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1388)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgTypeRec = MSOArray<SlideProgTagsSubContainerOrAtom>(_d + _position, rh().recLen());
    if (m_rgTypeRec.getSize() != rh().recLen()) return;
    _msize = m_rgTypeRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP9SlideBinaryTagExtension::PP9SlideBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen() == 0xE)) {
         return;
    }
    _position += _msize;
    if (_position + 14 > _maxsize) return;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 7);
    _msize = (7)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_rgTextMasterStyleAtom = MSOArray<TextMasterStyle9Atom>(_d + _position, _maxsize - _position);
    if (!m_rgTextMasterStyleAtom.isValid()) return;
    _msize = m_rgTextMasterStyleAtom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::Comment10Container::Comment10Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EE0)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::Comment10Atom::Comment10Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EE1)) {
         return;
    }
    if (!(rh().recLen() == 0x1C)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::LinkedSlide10Atom::_size = 16;
MSO::LinkedSlide10Atom::LinkedSlide10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EE7)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_linkedSlideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_clinkedShapes = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LinkedShape10Atom::_size = 16;
MSO::LinkedShape10Atom::LinkedShape10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EE6)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_shapeIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_linkedShapeIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::SlideFlags10Atom::_size = 12;
MSO::SlideFlags10Atom::SlideFlags10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EEA)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_fPreserveMaster = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fOverrideMasterAnimatino = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unuseda = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    m_unusedb = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::HashCode10Atom::_size = 12;
MSO::HashCode10Atom::HashCode10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2B00)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_hash = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ExtTimeNodeContainer::ExtTimeNodeContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0xF144)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::BuildListContainer::BuildListContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2B02)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::RoundTripHeaderFooterDefaults12Atom::_size = 9;
MSO::RoundTripHeaderFooterDefaults12Atom::RoundTripHeaderFooterDefaults12Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0424)) {
         return;
    }
    if (!(rh().recLen() == 1)) {
         return;
    }
    _position += _msize;
    m_fIncludeDate = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fIncludeFooter = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fIncludeHeader = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fIncludeSlideNumber = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TagNameAtom::TagNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2 == 0 )) {
         return;
    }
    _position += _msize;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TagValueAtom::TagValueAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    _position += _msize;
    m_tagValue = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::RoundTripMainMasterRecord::RoundTripMainMasterRecord(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recType() == 0x41C || rh().recType() == 0x40E || rh().recType() == 0x040F || rh().recType() == 0x41E || rh().recType() == 0x0423 || rh().recType() == 0x2B0D || rh().recType() == 0x2B0B || rh().recType() == 0x041D || rh().recType() == 0x2B0C || rh().recType() == 0x101D)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TemplateNameAtom::TemplateNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 2)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_templateName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::RoundTripSlideSyncInfo12Container::RoundTripSlideSyncInfo12Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3714)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::SlideFlags::_size = 2;
MSO::SlideFlags::SlideFlags(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fMasterObjects = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fMasterScheme = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fMasterBackground = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readuint5_3(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::NotesRoundTripAtom::NotesRoundTripAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x40E || rh().recType() == 0x40F || rh().recType() == 0x427)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::HandoutContainer::HandoutContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FC9)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExControlStg::ExControlStg(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x1011)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExOleObjStg::ExOleObjStg(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1011)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UserEditAtom::UserEditAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FF5)) {
         return;
    }
    if (!(rh().recLen() == 0x1C || rh().recLen() == 0x20)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_lastSlideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_version = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_minorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_minorVersion) == 0)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_majorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_majorVersion) == 3)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_offsetLastEdit = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_offsetPersistDirectory = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_docPersistIdRef = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_docPersistIdRef) == 1)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_persistIdSeed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_lastView = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_lastView)<=18)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    bool _has_encryptSessionPersistIdRef = rh().recLen()==32;
    if (_has_encryptSessionPersistIdRef) {
        if (_position + 4 > _maxsize) return;
        m_encryptSessionPersistIdRef = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    m_zeroPadding = MSOArray<ZeroByte>(_d + _position, _maxsize - _position);
    if (!m_zeroPadding.isValid()) return;
    _msize = m_zeroPadding.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::VbaProjectStg::VbaProjectStg(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x1011)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::SlideAtom::_size = 32;
MSO::SlideAtom::SlideAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x2)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x03EF)) {
         return;
    }
    if (!(rh().recLen() == 0x18)) {
         return;
    }
    _position += _msize;
    m_geom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_rgPlaceholderTypes = MSOCastArray<char>((const char*)(_d + _position), 8);
    _msize = (8)*1;
    _position += _msize;
    m_masterIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_notesIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_slideFlags = SlideFlags(_d + _position);
    if (!m_slideFlags.isValid()) return;
    _msize = m_slideFlags.getSize();
    _position += _msize;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::SlideShowSlideInfoAtom::_size = 24;
MSO::SlideShowSlideInfoAtom::SlideShowSlideInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x03F9)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    m_slidetime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_effectDirection = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_effectType = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fManualAdvance = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHidden = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSound = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved3 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLoopSound = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved4 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fStopSound = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_freserved5 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fAutoAdvance = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved6 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCursorVisible = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved7 = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    m_speed = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = MSOCastArray<char>((const char*)(_d + _position), 3);
    _msize = (3)*1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::SlideShowDocInfoAtom::_size = 88;
MSO::SlideShowDocInfoAtom::SlideShowDocInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 1)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0401)) {
         return;
    }
    if (!(rh().recLen() == 0x50)) {
         return;
    }
    _position += _msize;
    m_penColor = ColorIndexStruct(_d + _position);
    if (!m_penColor.isValid()) return;
    _msize = m_penColor.getSize();
    _position += _msize;
    m_restartTime = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_startSlide = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)m_startSlide)>=0)) {
         return;
    }
    _position += _msize;
    m_endSlide = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)m_endSlide)>=0)) {
         return;
    }
    _position += _msize;
    m_namedShow = MSOCastArray<char>((const char*)(_d + _position), 64);
    _msize = (64)*1;
    _position += _msize;
    m_fAutoAdvance = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fWillSkipBuilds = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseSlideRange = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDocUseNamedShow = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fShowBrowseMode = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fKioskMode = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fWillSkipNarration = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLoopContinuously = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fHideScrollBar = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint7_1(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SlideSchemeColorSchemeAtom::SlideSchemeColorSchemeAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x07F0)) {
         return;
    }
    if (!(rh().recLen() == 0x20)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_rgSchemeColor = MSOArray<ColorStruct>(_d + _position, 4 * 8, 8);
    if (m_rgSchemeColor.getCount() != 8) return;
    _msize = m_rgSchemeColor.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::RoundTripSlideRecord::RoundTripSlideRecord(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recType() == 0x40E || rh().recType() == 0x40F || rh().recType() == 0x41D || rh().recType() == 0x3714 || rh().recType() == 0x2B0D || rh().recType() == 0x2B0B || rh().recType() == 0x2B0C || rh().recType() == 0x422)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::NamedShowsContainer::NamedShowsContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x410)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SummaryContainer::SummaryContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x402)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::DocRoutingSlipAtom::DocRoutingSlipAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x406)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PrintOptionsAtom::PrintOptionsAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1770)) {
         return;
    }
    if (!(rh().recLen() == 5)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::RoundTripCustomTableStyles12Atom::RoundTripCustomTableStyles12Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0 || rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x428)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::RoundTripCompositeMasterId12Atom::_size = 12;
MSO::RoundTripCompositeMasterId12Atom::RoundTripCompositeMasterId12Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x41D)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_compositeMasterId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ColorStruct::_size = 4;
MSO::ColorStruct::ColorStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ExObjListAtom::_size = 12;
MSO::ExObjListAtom::ExObjListAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x040A)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_exObjIdSeed = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_exObjIdSeed)>=1)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ExAviMovieContainer::ExAviMovieContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1006)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExCDAudioContainer::ExCDAudioContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x100E)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::ExControlAtom::_size = 12;
MSO::ExControlAtom::ExControlAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFFB)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ExHyperlinkAtom::_size = 12;
MSO::ExHyperlinkAtom::ExHyperlinkAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFD3)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_exHyperLinkId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::FriendlyNameAtom::FriendlyNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_friendlyName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TargetAtom::TargetAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_target = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::LocationAtom::LocationAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 3)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_location = MSOCastArray<quint16>((const quint16*)(_d + _position), rh().recLen()/2);
    _msize = (rh().recLen()/2)*2;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExMCIMovieContainer::ExMCIMovieContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1007)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExMIDIAudioContainer::ExMIDIAudioContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x100D)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExWAVAudioEmbeddedContainer::ExWAVAudioEmbeddedContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x100F)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExWAVAudioLinkContainer::ExWAVAudioLinkContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1010)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UnknownExObjListSubContainerChild::UnknownExObjListSubContainerChild(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFEA)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::ExOleLinkAtom::_size = 20;
MSO::ExOleLinkAtom::ExOleLinkAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FD1)) {
         return;
    }
    if (!(rh().recLen() == 0xC)) {
         return;
    }
    _position += _msize;
    m_slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_oleUpdateMode = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_unused = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ExOleObjAtom::_size = 32;
MSO::ExOleObjAtom::ExOleObjAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x1)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FC3)) {
         return;
    }
    if (!(rh().recLen() == 0x18)) {
         return;
    }
    _position += _msize;
    m_drawAspect = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_type = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_exObjId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_subType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_unused = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::MenuNameAtom::MenuNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x1)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()%2 == 0 )) {
         return;
    }
    _position += _msize;
    m_menuName = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ProgIDAtom::ProgIDAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x2)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()%2 == 0 )) {
         return;
    }
    _position += _msize;
    m_progId = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ClipboardNameAtom::ClipboardNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x3)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen()%2 == 0 )) {
         return;
    }
    _position += _msize;
    m_clipboardName = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::MetafileBlob::MetafileBlob(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FC1)) {
         return;
    }
    if (!(rh().recLen()>16)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_mm = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_xExt = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_yExt = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-6);
    _msize = (rh().recLen()-6)*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtFDGG::_size = 16;
MSO::OfficeArtFDGG::OfficeArtFDGG(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_spidMax = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_spidMax)<67098623)) {
         return;
    }
    _position += _msize;
    m_cidcl = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_cidcl)<268435455)) {
         return;
    }
    _position += _msize;
    m_cspSaved = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_cdgSaved = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtFDG::_size = 16;
MSO::OfficeArtFDG::OfficeArtFDG(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance()<=4094)) {
         return;
    }
    if (!(rh().recType() == 0x0F008)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_csp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_spidCur = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OfficeArtFRITContainer::OfficeArtFRITContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF118)) {
         return;
    }
    if (!(rh().recLen()==4*rh().recInstance())) {
         return;
    }
    _position += _msize;
    m_rgfrit = MSOArray<OfficeArtFRIT>(_d + _position, 4 * rh().recInstance(), rh().recInstance());
    if (m_rgfrit.getCount() != rh().recInstance()) return;
    _msize = m_rgfrit.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtFRIT::_size = 4;
MSO::OfficeArtFRIT::OfficeArtFRIT(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fridNew = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_fridOld = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OfficeArtBStoreContainer::OfficeArtBStoreContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recType() == 0x0F001)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgfb = MSOArray<OfficeArtBStoreContainerFileBlock>(_d + _position, rh().recLen());
    if (m_rgfb.getSize() != rh().recLen()) return;
    _msize = m_rgfb.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtSpgrContainer::OfficeArtSpgrContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0F003)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgfb = MSOArray<OfficeArtSpgrContainerFileBlock>(_d + _position, rh().recLen());
    if (m_rgfb.getSize() != rh().recLen()) return;
    _msize = m_rgfb.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtSolverContainer::OfficeArtSolverContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recType() == 0xF005)) {
         return;
    }
    _position += _msize;
    m_rgfb = MSOArray<OfficeArtSolverContainerFileBlock>(_d + _position, _maxsize - _position);
    if (!m_rgfb.isValid()) return;
    _msize = m_rgfb.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtFConnectorRule::_size = 32;
MSO::OfficeArtFConnectorRule::OfficeArtFConnectorRule(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 1)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF012)) {
         return;
    }
    if (!(rh().recLen() == 0x18)) {
         return;
    }
    _position += _msize;
    m_ruid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_spidA = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_spidB = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_spidC = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_cptiA = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_cptiB = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtFArcRule::_size = 16;
MSO::OfficeArtFArcRule::OfficeArtFArcRule(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF014)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_ruid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_spid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtFCalloutRule::_size = 16;
MSO::OfficeArtFCalloutRule::OfficeArtFCalloutRule(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF017)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_ruid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_spid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtFSPGR::_size = 24;
MSO::OfficeArtFSPGR::OfficeArtFSPGR(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x1)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0F009)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    m_xLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_yTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_xRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_yBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtFSP::_size = 16;
MSO::OfficeArtFSP::OfficeArtFSP(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x2)) {
         return;
    }
    if (!(rh().recInstance()<= 202)) {
         return;
    }
    if (!(rh().recType() == 0x0F00A)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_spid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fGroup = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fChild = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPatriarch = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDeleted = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fOleShape = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHaveMaster = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFlipH = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFlipV = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fConnector = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHaveAnchor = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fBackground = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHaveSpt = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readuint20_4(_d + _position);
    _msize = 3;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OfficeArtFOPT::OfficeArtFOPT(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x3)) {
         return;
    }
    if (!(rh().recType() == 0x0F00B)) {
         return;
    }
    _position += _msize;
    m_fopt = MSOArray<OfficeArtFOPTEChoice>(_d + _position, 6 * rh().recInstance(), rh().recInstance());
    if (m_fopt.getCount() != rh().recInstance()) return;
    _msize = m_fopt.getSize();
    _position += _msize;
    m_complexData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-6*rh().recInstance());
    _msize = (rh().recLen()-6*rh().recInstance())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtSecondaryFOPT::OfficeArtSecondaryFOPT(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 3)) {
         return;
    }
    if (!(rh().recType() == 0xF121)) {
         return;
    }
    _position += _msize;
    m_fopt = MSOArray<OfficeArtFOPTEChoice>(_d + _position, 6 * rh().recInstance(), rh().recInstance());
    if (m_fopt.getCount() != rh().recInstance()) return;
    _msize = m_fopt.getSize();
    _position += _msize;
    m_complexData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-6*rh().recInstance());
    _msize = (rh().recLen()-6*rh().recInstance())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtTertiaryFOPT::OfficeArtTertiaryFOPT(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 3)) {
         return;
    }
    if (!(rh().recType() == 0xF122)) {
         return;
    }
    _position += _msize;
    m_fopt = MSOArray<OfficeArtFOPTEChoice>(_d + _position, 6 * rh().recInstance(), rh().recInstance());
    if (m_fopt.getCount() != rh().recInstance()) return;
    _msize = m_fopt.getSize();
    _position += _msize;
    m_complexData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-6*rh().recInstance());
    _msize = (rh().recLen()-6*rh().recInstance())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::MSOPATHINFO::_size = 2;
MSO::MSOPATHINFO::MSOPATHINFO(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_type = readuint3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_segments = readuint13_3(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FixedPoint::_size = 4;
MSO::FixedPoint::FixedPoint(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fractional = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_integral = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PVertices_complex::PVertices_complex(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), (cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()));
    _msize = ((cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PSegmentInfo_complex::PSegmentInfo_complex(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), (cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()));
    _msize = ((cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::FillShadeColors_complex::FillShadeColors_complex(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), (cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()));
    _msize = ((cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PWrapPolygonVertices_complex::PWrapPolygonVertices_complex(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), (cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()));
    _msize = ((cbElem()==0xFFF0)?(4 * nElems()):(cbElem() * nElems()))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtCOLORREF::_size = 4;
MSO::OfficeArtCOLORREF::OfficeArtCOLORREF(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fPaletteIndex = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPaletteRGB = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSystemRGB = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSchemeIndex = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSysIndex = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused3 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtChildAnchor::_size = 24;
MSO::OfficeArtChildAnchor::OfficeArtChildAnchor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF00F)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    m_xLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_yTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_xRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_yBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DocOfficeArtClientAnchor::_size = 12;
MSO::DocOfficeArtClientAnchor::DocOfficeArtClientAnchor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF010)) {
         return;
    }
    if (!(rh().recLen() == 0x4)) {
         return;
    }
    _position += _msize;
    m_clientAnchor = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::XlsOfficeArtClientAnchor::XlsOfficeArtClientAnchor(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF010)) {
         return;
    }
    if (!(rh().recLen() == 0x8 || rh().recLen() == 0x12)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fMove = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fSize = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_unused = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    bool _has_width = rh().recLen()==0x8;
    if (_has_width) {
        if (_position + 4 > _maxsize) return;
        m_width = readint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    bool _has_height = rh().recLen()==0x8;
    if (_has_height) {
        if (_position + 4 > _maxsize) return;
        m_height = readint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    bool _has_colL = rh().recLen()==0x12;
    if (_has_colL) {
        if (_position + 2 > _maxsize) return;
        m_colL = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_dxL = rh().recLen()==0x12;
    if (_has_dxL) {
        if (_position + 2 > _maxsize) return;
        m_dxL = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_rwT = rh().recLen()==0x12;
    if (_has_rwT) {
        if (_position + 2 > _maxsize) return;
        m_rwT = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_dyT = rh().recLen()==0x12;
    if (_has_dyT) {
        if (_position + 2 > _maxsize) return;
        m_dyT = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_colR = rh().recLen()==0x12;
    if (_has_colR) {
        if (_position + 2 > _maxsize) return;
        m_colR = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_dxR = rh().recLen()==0x12;
    if (_has_dxR) {
        if (_position + 2 > _maxsize) return;
        m_dxR = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_rwB = rh().recLen()==0x12;
    if (_has_rwB) {
        if (_position + 2 > _maxsize) return;
        m_rwB = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_dyB = rh().recLen()==0x12;
    if (_has_dyB) {
        if (_position + 2 > _maxsize) return;
        m_dyB = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtFPSPL::_size = 12;
MSO::OfficeArtFPSPL::OfficeArtFPSPL(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF11D)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_spid = readuint30(_d + _position);
    _msize = 3;
    _position += _msize;
    m_reserved1 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLast = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::RectStruct::_size = 16;
MSO::RectStruct::RectStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_top = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_left = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_right = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_bottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::SmallRectStruct::_size = 8;
MSO::SmallRectStruct::SmallRectStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_top = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_left = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_right = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_bottom = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DocOfficeArtClientData::_size = 12;
MSO::DocOfficeArtClientData::DocOfficeArtClientData(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF011)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_clientData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::XlsOfficeArtClientData::_size = 8;
MSO::XlsOfficeArtClientData::XlsOfficeArtClientData(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF011)) {
         return;
    }
    if (!(rh().recLen() == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ShapeFlagsAtom::ShapeFlagsAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xBDB)) {
         return;
    }
    if (!(rh().recLen() == 1)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ShapeFlags10Atom::ShapeFlags10Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xBDC)) {
         return;
    }
    if (!(rh().recLen() == 1)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::ExObjRefAtom::_size = 12;
MSO::ExObjRefAtom::ExObjRefAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xBC1)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_exObjIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::AnimationInfoAtom::_size = 36;
MSO::AnimationInfoAtom::AnimationInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x1)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFF1)) {
         return;
    }
    if (!(rh().recLen() == 0x1C)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), 0x1C);
    _msize = (0x1C)*1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SoundContainer::SoundContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x7E6)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::InteractiveInfoAtom::_size = 24;
MSO::InteractiveInfoAtom::InteractiveInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFF2 || rh().recType() == 0xFF3)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    m_soundIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_exHyperlinkIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_action = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_action)<8)) {
         return;
    }
    _position += _msize;
    m_oleVerb = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_oleVerb)<3)) {
         return;
    }
    _position += _msize;
    m_jump = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_jump)<7)) {
         return;
    }
    _position += _msize;
    m_fAnimated = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fStopSound = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCustomSoundReturn = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fVisited = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    m_hyperlinkType = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = MSOCastArray<char>((const char*)(_d + _position), 3);
    _msize = (3)*1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::MacroNameAtom::MacroNameAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 2)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen()%2==0)) {
         return;
    }
    _position += _msize;
    m_macroName = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::PlaceholderAtom::_size = 16;
MSO::PlaceholderAtom::PlaceholderAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xBC3)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_placementId = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_size = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::RecolorInfoAtom::RecolorInfoAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFE7)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OutlineTextRefAtom::_size = 12;
MSO::OutlineTextRefAtom::OutlineTextRefAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF9E)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_index = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_index)>=0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ShapeProgsTagContainer::ShapeProgsTagContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1 || rh().recInstance() == 2)) {
         return;
    }
    if (!(rh().recType() == 0x1388)) {
         return;
    }
    _position += _msize;
    m_rgChildRec = MSOArray<ShapeProgTagsSubContainerOrAtom>(_d + _position, _maxsize - _position);
    if (!m_rgChildRec.isValid()) return;
    _msize = m_rgChildRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP9ShapeBinaryTagExtension::PP9ShapeBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen() == 0xE)) {
         return;
    }
    _position += _msize;
    if (_position + 14 > _maxsize) return;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 7);
    _msize = (7)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_styleTextProp9Atom = StyleTextProp9Atom(_d + _position, _maxsize - _position);
    if (!m_styleTextProp9Atom.isValid()) return;
    _msize = m_styleTextProp9Atom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP10ShapeBinaryTagExtension::PP10ShapeBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rhData().recLen());
    _msize = (rhData().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP11ShapeBinaryTagExtension::PP11ShapeBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), rhData().recLen());
    _msize = (rhData().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::RoundTripNewPlaceHolderId12Atom::_size = 9;
MSO::RoundTripNewPlaceHolderId12Atom::RoundTripNewPlaceHolderId12Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xBDD)) {
         return;
    }
    if (!(rh().recLen() == 1)) {
         return;
    }
    _position += _msize;
    m_newPlaceHolderId = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::RoundTripShapeId12Atom::_size = 12;
MSO::RoundTripShapeId12Atom::RoundTripShapeId12Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x41F)) {
         return;
    }
    if (!(rh().recLen() == 4)) {
         return;
    }
    _position += _msize;
    m_shapeId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::RoundTripHFPlaceholder12Atom::_size = 9;
MSO::RoundTripHFPlaceholder12Atom::RoundTripHFPlaceholder12Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x420)) {
         return;
    }
    if (!(rh().recLen() == 1)) {
         return;
    }
    _position += _msize;
    m_placeHolderId = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::RoundTripShapeCheckSumForCustomLayouts12Atom::RoundTripShapeCheckSumForCustomLayouts12Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x426)) {
         return;
    }
    if (!(rh().recLen() == 8 || rh().recLen() == 40)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_shapeCheckSum = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_textCheckSum = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_unknown = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-8);
    _msize = (rh().recLen()-8)*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::XlsOfficeArtClientTextBox::_size = 8;
MSO::XlsOfficeArtClientTextBox::XlsOfficeArtClientTextBox(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF00D)) {
         return;
    }
    if (!(rh().recLen() == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DocOfficeArtClientTextBox::_size = 12;
MSO::DocOfficeArtClientTextBox::DocOfficeArtClientTextBox(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0 || rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF00D)) {
         return;
    }
    if (!(rh().recLen() == 0x4)) {
         return;
    }
    _position += _msize;
    m_clientTextBox = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PptOfficeArtClientTextBox::PptOfficeArtClientTextBox(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0 || rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF00D)) {
         return;
    }
    if (!(rh().recLen()!=4)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh().recLen()) return;
    m_rgChildRec = MSOArray<TextClientDataSubContainerOrAtom>(_d + _position, rh().recLen());
    if (m_rgChildRec.getSize() != rh().recLen()) return;
    _msize = m_rgChildRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtIDCL::_size = 8;
MSO::OfficeArtIDCL::OfficeArtIDCL(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_dgid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_cspidCur = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtFOPTEOPID::_size = 2;
MSO::OfficeArtFOPTEOPID::OfficeArtFOPTEOPID(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = readuint14(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fBid = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fComplex = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OfficeArtColorMRUContainer::OfficeArtColorMRUContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0xF11A)) {
         return;
    }
    if (!(rh().recLen()==4*rh().recInstance())) {
         return;
    }
    _position += _msize;
    m_rgmsocr = MSOArray<MSOCR>(_d + _position, 4 * rh().recInstance(), rh().recInstance());
    if (m_rgmsocr.getCount() != rh().recInstance()) return;
    _msize = m_rgmsocr.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::MSOCR::_size = 4;
MSO::MSOCR::MSOCR(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused1 = readuint3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSchemeIndex = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OfficeArtSplitMenuColorContainer::_size = 24;
MSO::OfficeArtSplitMenuColorContainer::OfficeArtSplitMenuColorContainer(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x4)) {
         return;
    }
    if (!(rh().recType() == 0xF11E)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    m_smca = MSOArray<MSOCR>(_d + _position, 4 * 4, 4);
    if (m_smca.getCount() != 4) return;
    _msize = m_smca.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::todo::todo(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    _position += _msize;
    m_anon = MSOCastArray<char>((const char*)(_d + _position), rh().recLen());
    _msize = (rh().recLen())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::FibBase::_size = 32;
MSO::FibBase::FibBase(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_wIdent = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_nFib = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_nFib) == 0x65 || ((quint16)m_nFib) == 0x67 || ((quint16)m_nFib) == 0x68 || ((quint16)m_nFib) == 0xC0 || ((quint16)m_nFib) == 0xC1 || ((quint16)m_nFib) == 0xC2 || ((quint16)m_nFib) == 0x101 || ((quint16)m_nFib) == 0x10B || ((quint16)m_nFib) == 0x10C || ((quint16)m_nFib) == 0x112)) {
         return;
    }
    _position += _msize;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_lid = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_pnNext = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_fDot = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fGlsy = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fComplex = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHasPic = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_cQuickSaves = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fEncrypted = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fWhichTblStm = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fReadOnlyRecommended = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fWriteReservation = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fExtChar = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLoadOverride = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFarEast = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fObfuscated = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_nFibBack = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_IKey = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_envr = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fMac = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fEmptySpecial = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLoadOverridePage = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSpare0 = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    m_reserved3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved4 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved5 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved6 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FibRgW97::_size = 28;
MSO::FibRgW97::FibRgW97(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_reserved1 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved2 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved4 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved5 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved6 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved7 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved8 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved9 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved10 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved11 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved12 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_reserved13 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_lidFE = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FibRgLw97::_size = 88;
MSO::FibRgLw97::FibRgLw97(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_cbMac = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_ccpText = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpText)>=0)) {
         return;
    }
    _position += _msize;
    m_ccpFtn = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpFtn)>=0)) {
         return;
    }
    _position += _msize;
    m_ccpHdd = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpHdd)>=0)) {
         return;
    }
    _position += _msize;
    m_reserved3 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved3) == 0)) {
         return;
    }
    _position += _msize;
    m_ccpAtn = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpAtn)>=0)) {
         return;
    }
    _position += _msize;
    m_ccpEdn = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpEdn)>=0)) {
         return;
    }
    _position += _msize;
    m_ccpTxbx = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpTxbx)>=0)) {
         return;
    }
    _position += _msize;
    m_ccpHdrTxbx = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_ccpHdrTxbx)>=0)) {
         return;
    }
    _position += _msize;
    m_reserved4 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved5 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved6 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved7 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved8 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved9 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved10 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved11 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved12 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved13 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved13) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved14 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved14) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FibRgFcLcb97::_size = 744;
MSO::FibRgFcLcb97::FibRgFcLcb97(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fcStshfOrig = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbStshfOrig = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcStshf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbStshf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcffndRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcffndRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcffndTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcffndTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfandRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfandRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfandTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfandTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfSed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfSed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcPad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcPad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfPhe = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfPhe = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfHdd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfHdd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBteChpx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBteChpx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBtePapx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBtePapx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfSea = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfSea = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfFfn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfFfn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldAtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldAtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcCmds = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbCmds = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPrDrvr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPrDrvr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPrEnvPort = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPrEnvPort = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPrEnvLand = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPrEnvLand = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcWss = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbWss = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcDop = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbDop = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfAssoc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfAssoc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcClx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbClx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfPgdFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfPgdFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcAutosaveSource = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbAutosaveSource = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcGrpXstAtnOwners = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbGrpXstAtnOwners = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfAtnBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfAtnBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUnused3 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUnused3 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcSpaMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcSpaMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcSpaHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcSpaHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfAtnBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfAtnBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfAtnBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfAtnBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPms = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPms = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcFormFldSttbs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbFormFldSttbs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfendRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfendRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfendTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfendTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldEdn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldEdn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUnused4 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUnused4 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcDggInfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbDggInfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfRMark = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfRMark = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfAutoCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfAutoCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfWkb = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfWkb = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfSpl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfSpl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcftxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcftxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfFldTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfFldTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfHdrtxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfHdrtxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcffldHdrTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcffldHdrTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcStwUser = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbStwUser = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbTtmbd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbTtmbd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcCookieData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbCookieData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPgdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPgdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcBkdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbBkdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPgdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPgdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcBkdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbBkdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPgdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPgdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcBkdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbBkdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfIntlFld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfIntlFld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcRouteSlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbRouteSlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbSavedBy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbSavedBy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbFnm = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbFnm = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlfLst = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlfLst = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlfLfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlfLfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfTxbxBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfTxbxBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfTxbxHdrBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfTxbxHdrBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcDocUndoWord9 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbDocUndoWord9 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUskf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUskf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcupcRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcupcRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcupcUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcupcUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbGlsyStyle = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbGlsyStyle = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlgosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlgosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcocx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcocx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBteLvc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBteLvc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_dwLowDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_dwHighDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfLvcPre10 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfLvcPre10 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfAsumy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfAsumy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfGram = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfGram = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbListNames = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbListNames = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfUssr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfUssr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FibRgFcLcb2000::_size = 120;
MSO::FibRgFcLcb2000::FibRgFcLcb2000(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fcPlcfTch = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfTch = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcRmdThreading = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbRmdThreading = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcMid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbMid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbRgtplc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbRgtplc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcMsoEnvelope = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbMsoEnvelope = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfLad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfLad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcRgDofr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbRgDofr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfCookieOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfCookieOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPgdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPgdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcBkdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbBkdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPgdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPgdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcBkdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbBkdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPgdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPgdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcBkdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbBkdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FibRgFcLcb2002::_size = 200;
MSO::FibRgFcLcb2002::FibRgFcLcb2002(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fcUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfPgp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfPgp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfuim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfuim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlfguidUim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlfguidUim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcAtrdExtra = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbAtrdExtra = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlrsid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlrsid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfBkmkFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfBkmkFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBkfFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBkfFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfcookie = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfcookie = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBklFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBklFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcFactoidData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbFactoidData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcDocUndo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbDocUndo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfBkmkFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfBkmkFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBkfFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBkfFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfBklFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfBklFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcSttbfbkmkBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbSttbfbkmkBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfbkfBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfbkfBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfbklBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfbklBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPmsNew = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPmsNew = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcODSO = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbODSO = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfpmiOldXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfpmiOldXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfpmiNewXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfpmiNewXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcfpmiMixedXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcfpmiMixedXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fcPlcffactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_lcbPlcffactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::LPStshi::LPStshi(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_cbSthi = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_stshi = MSOCastArray<char>((const char*)(_d + _position), cbSthi());
    _msize = (cbSthi())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::LPStd::LPStd(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_cbStd = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_std = MSOCastArray<char>((const char*)(_d + _position), cbStd());
    _msize = (cbStd())*1;
    _position += _msize;
    bool _has_padding = cbStd()%2==1;
    if (_has_padding) {
        if (_position + 1 > _maxsize) return;
        m_padding = readuint8(_d + _position);
        _msize = 1;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::PlcfSed::PlcfSed(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 2);
    _msize = (2)*4;
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_aSed = MSOArray<Sed>(_d + _position, 12 * 1, 1);
    if (m_aSed.getCount() != 1) return;
    _msize = m_aSed.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::Sed::_size = 12;
MSO::Sed::Sed(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fn = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_fcSepx = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_fnMpr = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    m_fcMpr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Plcfhdd::_size = 52;
MSO::Plcfhdd::Plcfhdd(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 13);
    _msize = (13)*4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PlcBteChpx::_size = 12;
MSO::PlcBteChpx::PlcBteChpx(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 2);
    _msize = (2)*4;
    _position += _msize;
    m_aPnBteChpx = MSOCastArray<quint32>((const quint32*)(_d + _position), 1);
    _msize = (1)*4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PlcfBtePapx::_size = 12;
MSO::PlcfBtePapx::PlcfBtePapx(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 2);
    _msize = (2)*4;
    _position += _msize;
    m_aPnBteChpx = MSOCastArray<quint32>((const quint32*)(_d + _position), 1);
    _msize = (1)*4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Tcg::_size = 12;
MSO::Tcg::Tcg(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_nTcgVer = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_nTcgVer) == 0)) {
         return;
    }
    _position += _msize;
    m_todo = MSOCastArray<char>((const char*)(_d + _position), 11);
    _msize = (11)*1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PrcData::PrcData(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_cbGrpprl = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)m_cbGrpprl)>=0)) {
         return;
    }
    if (!(((qint16)m_cbGrpprl)<=16290)) {
         return;
    }
    if (!(((qint16)m_cbGrpprl)%2==0)) {
         return;
    }
    _position += _msize;
    m_GrpPrl = MSOArray<Sprm>(_d + _position, 2 * cbGrpprl()/2, cbGrpprl()/2);
    if (m_GrpPrl.getCount() != cbGrpprl()/2) return;
    _msize = m_GrpPrl.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::Sprm::_size = 2;
MSO::Sprm::Sprm(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_ispmd = readuint9(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fSpec = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_sgc = readuint3_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_spra = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::Pcdt::Pcdt(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 1 > _maxsize) return;
    m_clxt = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_clxt) == 2)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_lcb = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_PlcPcd = MSOArray<Pcd>(_d + _position, 8 * lcb()/8, lcb()/8);
    if (m_PlcPcd.getCount() != lcb()/8) return;
    _msize = m_PlcPcd.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::FCompressed::_size = 4;
MSO::FCompressed::FCompressed(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fc = readuint30(_d + _position);
    _msize = 3;
    _position += _msize;
    m_fCompressed = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_r1 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Prm0::_size = 2;
MSO::Prm0::Prm0(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fComplex = readbit(_d + _position);
    _msize = 0;
    if (!(((bool)m_fComplex) == false)) {
         return;
    }
    _position += _msize;
    m_isprm = readuint7_1(_d + _position);
    _msize = 1;
    _position += _msize;
    m_val = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Prm1::_size = 2;
MSO::Prm1::Prm1(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fComplex = readbit(_d + _position);
    _msize = 0;
    if (!(((bool)m_fComplex) == true)) {
         return;
    }
    _position += _msize;
    m_igrpprl = readuint15_1(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SttbfFfn::SttbfFfn(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_cData = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cbExtra = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cbExtra) == 0)) {
         return;
    }
    _position += _msize;
    m_data = MSOArray<SttbfFfnEntry>(_d + _position, _maxsize - _position, cData());
    if (m_data.getCount() != cData()) return;
    _msize = m_data.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SttbfFfnEntry::SttbfFfnEntry(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 1 > _maxsize) return;
    m_cchData = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_Data = MSOCastArray<char>((const char*)(_d + _position), cchData());
    _msize = (cchData())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::CodePageString::CodePageString(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_characters = MSOCastArray<char>((const char*)(_d + _position), 4*(size()/4)+((size()%4!=0)?4:0));
    _msize = (4*(size()/4)+((size()%4!=0)?4:0))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::FILETIME::_size = 8;
MSO::FILETIME::FILETIME(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_dwLowDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_dwHighDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ClipboardData::ClipboardData(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_format = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_data = MSOCastArray<char>((const char*)(_d + _position), 4*(size()/4)+((size()%4!=0)?4:0)-4);
    _msize = (4*(size()/4)+((size()%4!=0)?4:0)-4)*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::PropertyIdentifierAndOffset::_size = 8;
MSO::PropertyIdentifierAndOffset::PropertyIdentifierAndOffset(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_propertyIdentifier = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_offset = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TypedPropertyValue::TypedPropertyValue(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_type = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_padding = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    bool _has_vt_I2 = type()==2;
    if (_has_vt_I2) {
        if (_position + 2 > _maxsize) return;
        m_vt_I2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_paddingI2 = type()==2;
    if (_has_paddingI2) {
        if (_position + 2 > _maxsize) return;
        m_paddingI2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_vg_ERROR = type()==10;
    if (_has_vg_ERROR) {
        if (_position + 4 > _maxsize) return;
        m_vg_ERROR = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    if (type()==30) {
        if (_position + 0 > _maxsize) return;
        m_vt_lpstr = CodePageString(_d + _position, _maxsize - _position);
        if (!m_vt_lpstr.isPresent()) return;
        _msize = m_vt_lpstr.getSize();
        _position += _msize;
    }
    if (type()==64) {
        if (_position + 8 > _maxsize) return;
        m_vg_FILETIME = FILETIME(_d + _position);
        if (!m_vg_FILETIME.isPresent()) return;
        _msize = m_vg_FILETIME.getSize();
        _position += _msize;
    }
    if (type()==71) {
        if (_position + 0 > _maxsize) return;
        m_vg_CF = ClipboardData(_d + _position, _maxsize - _position);
        if (!m_vg_CF.isPresent()) return;
        _msize = m_vg_CF.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::PropertySet::PropertySet(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_numProperties = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_propertyIdentifierAndOffset = MSOArray<PropertyIdentifierAndOffset>(_d + _position, 8 * numProperties(), numProperties());
    if (m_propertyIdentifierAndOffset.getCount() != numProperties()) return;
    _msize = m_propertyIdentifierAndOffset.getSize();
    _position += _msize;
    m_property = MSOArray<TypedPropertyValue>(_d + _position, _maxsize - _position, numProperties());
    if (m_property.getCount() != numProperties()) return;
    _msize = m_property.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PropertySetStream::PropertySetStream(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    m_byteOrder = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_byteOrder) == 0xFFFE)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_version = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_systemIdentifier = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_clsID = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_numPropertySets = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_numPropertySets) == 1 || ((quint32)m_numPropertySets) == 2)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_fmtID0 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_offset0 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    bool _has_fmtID1 = numPropertySets()==2;
    if (_has_fmtID1) {
        if (_position + 16 > _maxsize) return;
        m_fmtID1 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    bool _has_offset1 = numPropertySets()==2;
    if (_has_offset1) {
        if (_position + 4 > _maxsize) return;
        m_offset1 = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_propertySet1 = PropertySet(_d + _position, _maxsize - _position);
    if (!m_propertySet1.isValid()) return;
    _msize = m_propertySet1.getSize();
    _position += _msize;
    if (numPropertySets()==2) {
        if (_position + 0 > _maxsize) return;
        m_propertySet2 = PropertySet(_d + _position, _maxsize - _position);
        if (!m_propertySet2.isPresent()) return;
        _msize = m_propertySet2.getSize();
        _position += _msize;
    }
    m_padding = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (!m_padding.isValid()) return;
    _msize = m_padding.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SummaryInformationPropertySetStream::SummaryInformationPropertySetStream(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_propertySet = PropertySetStream(_d + _position, _maxsize - _position);
    if (!m_propertySet.isValid()) return;
    _msize = m_propertySet.getSize();
    if (!(propertySet().version() == 0)) {
         return;
    }
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::DocumentSummaryInformationPropertySetStream::DocumentSummaryInformationPropertySetStream(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_propertySet = PropertySetStream(_d + _position, _maxsize - _position);
    if (!m_propertySet.isValid()) return;
    _msize = m_propertySet.getSize();
    if (!(propertySet().version() == 0)) {
         return;
    }
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PicturesStream::PicturesStream(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon1 = OfficeArtBStoreDelay(_d + _position, _maxsize - _position);
    if (!m_anon1.isValid()) return;
    _msize = m_anon1.getSize();
    _position += _msize;
    m_trailing = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (!m_trailing.isValid()) return;
    _msize = m_trailing.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtMetafileHeader::_size = 34;
MSO::OfficeArtMetafileHeader::OfficeArtMetafileHeader(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_cbSize = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_rcBounds = RECT(_d + _position);
    if (!m_rcBounds.isValid()) return;
    _msize = m_rcBounds.getSize();
    _position += _msize;
    m_ptSize = POINT(_d + _position);
    if (!m_ptSize.isValid()) return;
    _msize = m_ptSize.getSize();
    _position += _msize;
    m_cbsave = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_compression = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_filter = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SoundCollectionContainer::SoundCollectionContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 5)) {
         return;
    }
    if (!(rh().recType() == 0x7E4)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_soundCollectionAtom = SoundCollectionAtom(_d + _position);
    if (!m_soundCollectionAtom.isValid()) return;
    _msize = m_soundCollectionAtom.getSize();
    _position += _msize;
    if (_maxsize - _position < rh().recLen()-12) return;
    m_rgSoundContainer = MSOArray<SoundContainer>(_d + _position, rh().recLen()-12);
    if (m_rgSoundContainer.getSize() != rh().recLen()-12) return;
    _msize = m_rgSoundContainer.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SlideHeadersFootersContainer::SlideHeadersFootersContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 3)) {
         return;
    }
    if (!(rh().recType() == 0xFD9)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_hfAtom = HeadersFootersAtom(_d + _position);
    if (!m_hfAtom.isValid()) return;
    _msize = m_hfAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_userDateAtom = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (m_userDateAtom.isPresent()) ?m_userDateAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_footerAtom = FooterAtom(_d + _position, _maxsize - _position);
        _msize = (m_footerAtom.isPresent()) ?m_footerAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::NotesHeadersFootersContainer::NotesHeadersFootersContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 4)) {
         return;
    }
    if (!(rh().recType() == 0xFD9)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_hfAtom = HeadersFootersAtom(_d + _position);
    if (!m_hfAtom.isValid()) return;
    _msize = m_hfAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_userDateAtom = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (m_userDateAtom.isPresent()) ?m_userDateAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_headerAtom = HeaderAtom(_d + _position, _maxsize - _position);
        _msize = (m_headerAtom.isPresent()) ?m_headerAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_footerAtom = FooterAtom(_d + _position, _maxsize - _position);
        _msize = (m_footerAtom.isPresent()) ?m_footerAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
const quint32 MSO::ScalingStruct::_size = 16;
MSO::ScalingStruct::ScalingStruct(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_x = RatioStruct(_d + _position);
    if (!m_x.isValid()) return;
    _msize = m_x.getSize();
    _position += _msize;
    m_y = RatioStruct(_d + _position);
    if (!m_y.isValid()) return;
    _msize = m_y.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TextPFException9::TextPFException9(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_masks = PFMasks(_d + _position);
    if (!m_masks.isValid()) return;
    _msize = m_masks.getSize();
    if (!(masks().hasBullet() == false)) {
         return;
    }
    if (!(masks().bulletHasFont() == false)) {
         return;
    }
    if (!(masks().bulletHasColor() == false)) {
         return;
    }
    if (!(masks().bulletHasSize() == false)) {
         return;
    }
    if (!(masks().bulletFont() == false)) {
         return;
    }
    if (!(masks().bulletColor() == false)) {
         return;
    }
    if (!(masks().bulletSize() == false)) {
         return;
    }
    if (!(masks().bulletChar() == false)) {
         return;
    }
    if (!(masks().leftMargin() == false)) {
         return;
    }
    if (!(masks().indent() == false)) {
         return;
    }
    if (!(masks().align() == false)) {
         return;
    }
    if (!(masks().lineSpacing() == false)) {
         return;
    }
    if (!(masks().spaceBefore() == false)) {
         return;
    }
    if (!(masks().spaceAfter() == false)) {
         return;
    }
    if (!(masks().defaultTabSize() == false)) {
         return;
    }
    if (!(masks().fontAlign() == false)) {
         return;
    }
    if (!(masks().charWrap() == false)) {
         return;
    }
    if (!(masks().wordWrap() == false)) {
         return;
    }
    if (!(masks().overflow() == false)) {
         return;
    }
    if (!(masks().tabStops() == false)) {
         return;
    }
    if (!(masks().textDirection() == false)) {
         return;
    }
    _position += _msize;
    bool _has_bulletBlipRef = masks().bulletBlip();
    if (_has_bulletBlipRef) {
        if (_position + 2 > _maxsize) return;
        m_bulletBlipRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_fBulletHasAutoNumber = masks().bulletHasScheme();
    if (_has_fBulletHasAutoNumber) {
        if (_position + 2 > _maxsize) return;
        m_fBulletHasAutoNumber = readuint16(_d + _position);
        _msize = 2;
        if (!(((quint16)*m_fBulletHasAutoNumber) == 0 || ((quint16)*m_fBulletHasAutoNumber) == 1)) {
             return;
        }
        _position += _msize;
    }
    if (masks().bulletScheme()) {
        if (_position + 4 > _maxsize) return;
        m_bulletAutoNumberScheme = TextAutoNumberScheme(_d + _position);
        if (!m_bulletAutoNumberScheme.isPresent()) return;
        _msize = m_bulletAutoNumberScheme.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextCFException9::TextCFException9(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_masks = CFMasks(_d + _position);
    if (!m_masks.isValid()) return;
    _msize = m_masks.getSize();
    if (!(masks().bold() == false)) {
         return;
    }
    if (!(masks().italic() == false)) {
         return;
    }
    if (!(masks().underline() == false)) {
         return;
    }
    if (!(masks().shadow() == false)) {
         return;
    }
    if (!(masks().fehint() == false)) {
         return;
    }
    if (!(masks().kumi() == false)) {
         return;
    }
    if (!(masks().emboss() == false)) {
         return;
    }
    if (!(masks().reserved() == 0)) {
         return;
    }
    if (!(masks().typeface() == false)) {
         return;
    }
    if (!(masks().size() == false)) {
         return;
    }
    if (!(masks().color() == false)) {
         return;
    }
    if (!(masks().position() == false)) {
         return;
    }
    if (!(masks().oldEATypeface() == false)) {
         return;
    }
    if (!(masks().ansiTypeface() == false)) {
         return;
    }
    if (!(masks().symbolTypeface() == false)) {
         return;
    }
    if (!(masks().newEATypeface() == false)) {
         return;
    }
    if (!(masks().csTypeface() == false)) {
         return;
    }
    if (!(masks().pp11ext() == false)) {
         return;
    }
    _position += _msize;
    bool _has_pp10runid = masks().pp10ext();
    if (_has_pp10runid) {
        if (_position + 0 > _maxsize) return;
        m_pp10runid = readuint4(_d + _position);
        _msize = 0;
        _position += _msize;
    }
    bool _has_unuseda = masks().pp10ext();
    if (_has_unuseda) {
        if (_position + 2 > _maxsize) return;
        m_unuseda = readuint20_4(_d + _position);
        _msize = 3;
        _position += _msize;
    }
    bool _has_unusedb = masks().pp10ext();
    if (_has_unusedb) {
        if (_position + 1 > _maxsize) return;
        m_unusedb = readuint8(_d + _position);
        _msize = 1;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextDefaults9Atom::TextDefaults9Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x00)) {
         return;
    }
    if (!(rh().recType() == 0x0FB0)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf9 = TextCFException9(_d + _position, _maxsize - _position);
    if (!m_cf9.isValid()) return;
    _msize = m_cf9.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_pf9 = TextPFException9(_d + _position, _maxsize - _position);
    if (!m_pf9.isValid()) return;
    _msize = m_pf9.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::Kinsoku9Container::Kinsoku9Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x2)) {
         return;
    }
    if (!(rh().recType() == 0x0FC8)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_kinsoku9Atom = Kinsoku9Atom(_d + _position);
    if (!m_kinsoku9Atom.isValid()) return;
    _msize = m_kinsoku9Atom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_kinsokuLeadingAtom = KinsokuLeadingAtom(_d + _position, _maxsize - _position);
        _msize = (m_kinsokuLeadingAtom.isPresent()) ?m_kinsokuLeadingAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_kinsokuFollowingAtom = KinsokuFollowingAtom(_d + _position, _maxsize - _position);
        _msize = (m_kinsokuFollowingAtom.isPresent()) ?m_kinsokuFollowingAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::OutlineTextProps9Entry::OutlineTextProps9Entry(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 16 > _maxsize) return;
    m_outlineTextHeaderAtom = OutlineTextPropsHeaderExAtom(_d + _position);
    if (!m_outlineTextHeaderAtom.isValid()) return;
    _msize = m_outlineTextHeaderAtom.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_styleTextProp9Atom = StyleTextProp9Atom(_d + _position, _maxsize - _position);
    if (!m_styleTextProp9Atom.isValid()) return;
    _msize = m_styleTextProp9Atom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextCFException10::TextCFException10(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_masks = CFMasks(_d + _position);
    if (!m_masks.isValid()) return;
    _msize = m_masks.getSize();
    if (!(masks().bold() == false)) {
         return;
    }
    if (!(masks().italic() == false)) {
         return;
    }
    if (!(masks().underline() == false)) {
         return;
    }
    if (!(masks().shadow() == false)) {
         return;
    }
    if (!(masks().fehint() == false)) {
         return;
    }
    if (!(masks().kumi() == false)) {
         return;
    }
    if (!(masks().emboss() == false)) {
         return;
    }
    if (!(masks().reserved() == 0)) {
         return;
    }
    if (!(masks().typeface() == false)) {
         return;
    }
    if (!(masks().size() == false)) {
         return;
    }
    if (!(masks().color() == false)) {
         return;
    }
    if (!(masks().position() == false)) {
         return;
    }
    if (!(masks().pp10ext() == false)) {
         return;
    }
    if (!(masks().oldEATypeface() == false)) {
         return;
    }
    if (!(masks().ansiTypeface() == false)) {
         return;
    }
    if (!(masks().symbolTypeface() == false)) {
         return;
    }
    _position += _msize;
    bool _has_newEAFontRef = masks().newEATypeface();
    if (_has_newEAFontRef) {
        if (_position + 2 > _maxsize) return;
        m_newEAFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_csFontRef = masks().csTypeface();
    if (_has_csFontRef) {
        if (_position + 2 > _maxsize) return;
        m_csFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_pp11ext = masks().pp11ext();
    if (_has_pp11ext) {
        if (_position + 4 > _maxsize) return;
        m_pp11ext = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextDefaults10Atom::TextDefaults10Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FB4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf10 = TextCFException10(_d + _position, _maxsize - _position);
    if (!m_cf10.isValid()) return;
    _msize = m_cf10.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::CommentIndex10Container::CommentIndex10Container(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x2EE4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_authorNameAtom = AuthorNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_authorNameAtom.isPresent()) ?m_authorNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 16 <= _maxsize) {
        m_authorIndexAtom = CommentIndex10Atom(_d + _position);
        _msize = (m_authorIndexAtom.isPresent()) ?m_authorIndexAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::OutlineTextProps10Entry::OutlineTextProps10Entry(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 16 > _maxsize) return;
    m_outlineTextHeaderAtom = OutlineTextPropsHeaderExAtom(_d + _position);
    if (!m_outlineTextHeaderAtom.isValid()) return;
    _msize = m_outlineTextHeaderAtom.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_styleTextProp10Atom = StyleTextProp10Atom(_d + _position, _maxsize - _position);
    if (!m_styleTextProp10Atom.isValid()) return;
    _msize = m_styleTextProp10Atom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP11DocBinaryTagExtension::PP11DocBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0x0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_smartTagStore11 = SmartTagStore11Container(_d + _position, _maxsize - _position);
    if (!m_smartTagStore11.isValid()) return;
    _msize = m_smartTagStore11.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_outlineTextProps = OutlineTextProps11Container(_d + _position, _maxsize - _position);
    if (!m_outlineTextProps.isValid()) return;
    _msize = m_outlineTextProps.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::UnknownBinaryTag::UnknownBinaryTag(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_tagNameAtom = TagNameAtom(_d + _position, _maxsize - _position);
    if (!m_tagNameAtom.isValid()) return;
    _msize = m_tagNameAtom.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_tagData = BinaryTagDataBlob(_d + _position, _maxsize - _position);
    if (!m_tagData.isValid()) return;
    _msize = m_tagData.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::NoZoomViewInfoAtom::_size = 60;
MSO::NoZoomViewInfoAtom::NoZoomViewInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3FD)) {
         return;
    }
    if (!(rh().recLen() == 0x34)) {
         return;
    }
    _position += _msize;
    m_curScale = ScalingStruct(_d + _position);
    if (!m_curScale.isValid()) return;
    _msize = m_curScale.getSize();
    _position += _msize;
    m_unused1 = MSOCastArray<char>((const char*)(_d + _position), 24);
    _msize = (24)*1;
    _position += _msize;
    m_origin = PointStruct(_d + _position);
    if (!m_origin.isValid()) return;
    _msize = m_origin.getSize();
    _position += _msize;
    m_unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fDraftMode = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::VBAInfoContainer::_size = 28;
MSO::VBAInfoContainer::VBAInfoContainer(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x3FF)) {
         return;
    }
    if (!(rh().recLen() == 0x14)) {
         return;
    }
    _position += _msize;
    m_vbaInfoAtom = VBAInfoAtom(_d + _position);
    if (!m_vbaInfoAtom.isValid()) return;
    _msize = m_vbaInfoAtom.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::NormalViewSetInfoAtom::_size = 28;
MSO::NormalViewSetInfoAtom::NormalViewSetInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x415)) {
         return;
    }
    if (!(rh().recLen() == 0x14)) {
         return;
    }
    _position += _msize;
    m_leftPortion = RatioStruct(_d + _position);
    if (!m_leftPortion.isValid()) return;
    _msize = m_leftPortion.getSize();
    _position += _msize;
    m_topPortion = RatioStruct(_d + _position);
    if (!m_topPortion.isValid()) return;
    _msize = m_topPortion.getSize();
    _position += _msize;
    m_vertBarState = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_horizBarState = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fPreferSingleSet = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_fPreferSingleSet) == 0 || ((quint8)m_fPreferSingleSet) == 1)) {
         return;
    }
    _position += _msize;
    m_fHideThumbnails = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fBarSnapped = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved = readuint6_2(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TextContainer::TextContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 12 > _maxsize) return;
    m_textHeaderAtom = TextHeaderAtom(_d + _position);
    if (!m_textHeaderAtom.isValid()) return;
    _msize = m_textHeaderAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_text._TextCharsAtom = TextCharsAtom(_d + _position, _maxsize - _position);
        _msize = m_text._TextCharsAtom.getSize();
        if (_msize == 0) {
            m_text._TextBytesAtom = TextBytesAtom(_d + _position, _maxsize - _position);
            _msize = m_text._TextBytesAtom.getSize();
        }
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_style = StyleTextPropAtom(_d + _position, _maxsize - _position);
        _msize = (m_style.isPresent()) ?m_style.getSize() :0;
        _position += _msize;
    }
    m_meta = MSOArray<TextContainerMeta>(_d + _position, _maxsize - _position);
    if (!m_meta.isValid()) return;
    _msize = m_meta.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_master = MasterTextPropAtom(_d + _position, _maxsize - _position);
        _msize = (m_master.isPresent()) ?m_master.getSize() :0;
        _position += _msize;
    }
    m_bookmark = MSOArray<TextBookmarkAtom>(_d + _position, _maxsize - _position);
    if (!m_bookmark.isValid()) return;
    _msize = m_bookmark.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_unknown = UnknownTextContainerChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown.isPresent()) ?m_unknown.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_specialinfo = TextSpecialInfoAtom(_d + _position, _maxsize - _position);
        _msize = (m_specialinfo.isPresent()) ?m_specialinfo.getSize() :0;
        _position += _msize;
    }
    m_interactive = MSOArray<TextContainerInteractiveInfo>(_d + _position, _maxsize - _position);
    if (!m_interactive.isValid()) return;
    _msize = m_interactive.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_specialinfo2 = TextSpecialInfoAtom(_d + _position, _maxsize - _position);
        _msize = (m_specialinfo2.isPresent()) ?m_specialinfo2.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> TextCharsAtom TextContainer::C_text::get<TextCharsAtom>() const {
        return _TextCharsAtom;
    }
    template <> bool TextContainer::C_text::is<TextCharsAtom>() const {
        return _TextCharsAtom.isValid();
    }
    template <> TextBytesAtom TextContainer::C_text::get<TextBytesAtom>() const {
        return _TextBytesAtom;
    }
    template <> bool TextContainer::C_text::is<TextBytesAtom>() const {
        return _TextBytesAtom.isValid();
    }
}
MSO::TextContainerMeta::TextContainerMeta(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_meta._SlideNumberMCAtom = SlideNumberMCAtom(_d + _position);
    _msize = (m_meta._SlideNumberMCAtom.isValid()) ?SlideNumberMCAtom::getSize() : 0;
    if (_msize == 0) {
        m_meta._DateTimeMCAtom = DateTimeMCAtom(_d + _position);
        _msize = (m_meta._DateTimeMCAtom.isValid()) ?DateTimeMCAtom::getSize() : 0;
    }
    if (_msize == 0) {
        m_meta._GenericDateMCAtom = GenericDateMCAtom(_d + _position);
        _msize = (m_meta._GenericDateMCAtom.isValid()) ?GenericDateMCAtom::getSize() : 0;
    }
    if (_msize == 0) {
        m_meta._HeaderMCAtom = HeaderMCAtom(_d + _position);
        _msize = (m_meta._HeaderMCAtom.isValid()) ?HeaderMCAtom::getSize() : 0;
    }
    if (_msize == 0) {
        m_meta._FooterMCAtom = FooterMCAtom(_d + _position);
        _msize = (m_meta._FooterMCAtom.isValid()) ?FooterMCAtom::getSize() : 0;
    }
    if (_msize == 0) {
        m_meta._RTFDateTimeMCAtom = RTFDateTimeMCAtom(_d + _position);
        _msize = (m_meta._RTFDateTimeMCAtom.isValid()) ?RTFDateTimeMCAtom::getSize() : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> SlideNumberMCAtom TextContainerMeta::C_meta::get<SlideNumberMCAtom>() const {
        return _SlideNumberMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<SlideNumberMCAtom>() const {
        return _SlideNumberMCAtom.isValid();
    }
    template <> DateTimeMCAtom TextContainerMeta::C_meta::get<DateTimeMCAtom>() const {
        return _DateTimeMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<DateTimeMCAtom>() const {
        return _DateTimeMCAtom.isValid();
    }
    template <> GenericDateMCAtom TextContainerMeta::C_meta::get<GenericDateMCAtom>() const {
        return _GenericDateMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<GenericDateMCAtom>() const {
        return _GenericDateMCAtom.isValid();
    }
    template <> HeaderMCAtom TextContainerMeta::C_meta::get<HeaderMCAtom>() const {
        return _HeaderMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<HeaderMCAtom>() const {
        return _HeaderMCAtom.isValid();
    }
    template <> FooterMCAtom TextContainerMeta::C_meta::get<FooterMCAtom>() const {
        return _FooterMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<FooterMCAtom>() const {
        return _FooterMCAtom.isValid();
    }
    template <> RTFDateTimeMCAtom TextContainerMeta::C_meta::get<RTFDateTimeMCAtom>() const {
        return _RTFDateTimeMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<RTFDateTimeMCAtom>() const {
        return _RTFDateTimeMCAtom.isValid();
    }
}
const quint32 MSO::SlidePersistAtom::_size = 28;
MSO::SlidePersistAtom::SlidePersistAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3F3)) {
         return;
    }
    if (!(rh().recLen() == 0x14)) {
         return;
    }
    _position += _msize;
    m_persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_reserved1 = readbit(_d + _position);
    _msize = 0;
    if (!(((bool)m_reserved1) == false)) {
         return;
    }
    _position += _msize;
    m_fShouldCollapse = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fNonOutlineData = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved2 = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved2) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved3 = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_reserved3) == 0)) {
         return;
    }
    _position += _msize;
    m_reserved4 = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_reserved4) == 0)) {
         return;
    }
    _position += _msize;
    m_cTexts = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_cTexts)>=0)) {
         return;
    }
    if (!(((qint32)m_cTexts)<=8)) {
         return;
    }
    _position += _msize;
    m_slideId = SlideId(_d + _position);
    if (!m_slideId.isValid()) return;
    _msize = m_slideId.getSize();
    _position += _msize;
    m_reserved5 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_reserved5) == 0)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::TextRuler::TextRuler(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_fDefaultTabSize = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fCLevels = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fTabStops = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fLeftMargin1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fLeftMargin2 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fLeftMargin3 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fLeftMargin4 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fLeftMargin5 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fIndent1 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fIndent2 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fIndent3 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fIndent4 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fIndent5 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_reserved1 = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_reserved2 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    bool _has_cLevels = fCLevels();
    if (_has_cLevels) {
        if (_position + 2 > _maxsize) return;
        m_cLevels = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_defaultTabSize = fDefaultTabSize();
    if (_has_defaultTabSize) {
        if (_position + 2 > _maxsize) return;
        m_defaultTabSize = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (fTabStops()) {
        if (_position + 0 > _maxsize) return;
        m_tabs = TabStops(_d + _position, _maxsize - _position);
        if (!m_tabs.isPresent()) return;
        _msize = m_tabs.getSize();
        _position += _msize;
    }
    bool _has_leftMargin1 = fLeftMargin1();
    if (_has_leftMargin1) {
        if (_position + 2 > _maxsize) return;
        m_leftMargin1 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_indent1 = fIndent1();
    if (_has_indent1) {
        if (_position + 2 > _maxsize) return;
        m_indent1 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_leftMargin2 = fLeftMargin2();
    if (_has_leftMargin2) {
        if (_position + 2 > _maxsize) return;
        m_leftMargin2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_indent2 = fIndent2();
    if (_has_indent2) {
        if (_position + 2 > _maxsize) return;
        m_indent2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_leftMargin3 = fLeftMargin3();
    if (_has_leftMargin3) {
        if (_position + 2 > _maxsize) return;
        m_leftMargin3 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_indent3 = fIndent3();
    if (_has_indent3) {
        if (_position + 2 > _maxsize) return;
        m_indent3 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_leftMargin4 = fLeftMargin4();
    if (_has_leftMargin4) {
        if (_position + 2 > _maxsize) return;
        m_leftMargin4 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_indent4 = fIndent4();
    if (_has_indent4) {
        if (_position + 2 > _maxsize) return;
        m_indent4 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_leftMargin5 = fLeftMargin5();
    if (_has_leftMargin5) {
        if (_position + 2 > _maxsize) return;
        m_leftMargin5 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_indent5 = fIndent5();
    if (_has_indent5) {
        if (_position + 2 > _maxsize) return;
        m_indent5 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextPFException::TextPFException(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_masks = PFMasks(_d + _position);
    if (!m_masks.isValid()) return;
    _msize = m_masks.getSize();
    if (!(masks().bulletBlip() == false)) {
         return;
    }
    if (!(masks().bulletHasScheme() == false)) {
         return;
    }
    if (!(masks().bulletScheme() == false)) {
         return;
    }
    _position += _msize;
    if (masks().hasBullet()||masks().bulletHasFont()||masks().bulletHasColor()||masks().bulletHasSize()) {
        if (_position + 2 > _maxsize) return;
        m_bulletFlags = BulletFlags(_d + _position);
        if (!m_bulletFlags.isPresent()) return;
        _msize = m_bulletFlags.getSize();
        _position += _msize;
    }
    bool _has_bulletChar = masks().bulletChar();
    if (_has_bulletChar) {
        if (_position + 2 > _maxsize) return;
        m_bulletChar = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_bulletFontRef = masks().bulletFont();
    if (_has_bulletFontRef) {
        if (_position + 2 > _maxsize) return;
        m_bulletFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_bulletSize = masks().bulletSize();
    if (_has_bulletSize) {
        if (_position + 2 > _maxsize) return;
        m_bulletSize = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (masks().bulletColor()) {
        if (_position + 4 > _maxsize) return;
        m_bulletColor = ColorIndexStruct(_d + _position);
        if (!m_bulletColor.isPresent()) return;
        _msize = m_bulletColor.getSize();
        _position += _msize;
    }
    bool _has_textAlignment = masks().align();
    if (_has_textAlignment) {
        if (_position + 2 > _maxsize) return;
        m_textAlignment = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_lineSpacing = masks().lineSpacing();
    if (_has_lineSpacing) {
        if (_position + 2 > _maxsize) return;
        m_lineSpacing = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_spaceBefore = masks().spaceBefore();
    if (_has_spaceBefore) {
        if (_position + 2 > _maxsize) return;
        m_spaceBefore = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_spaceAfter = masks().spaceAfter();
    if (_has_spaceAfter) {
        if (_position + 2 > _maxsize) return;
        m_spaceAfter = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_leftMargin = masks().leftMargin();
    if (_has_leftMargin) {
        if (_position + 2 > _maxsize) return;
        m_leftMargin = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_indent = masks().indent();
    if (_has_indent) {
        if (_position + 2 > _maxsize) return;
        m_indent = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_defaultTabSize = masks().defaultTabSize();
    if (_has_defaultTabSize) {
        if (_position + 2 > _maxsize) return;
        m_defaultTabSize = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (masks().tabStops()) {
        if (_position + 0 > _maxsize) return;
        m_tabStops = TabStops(_d + _position, _maxsize - _position);
        if (!m_tabStops.isPresent()) return;
        _msize = m_tabStops.getSize();
        _position += _msize;
    }
    bool _has_fontAlign = masks().fontAlign();
    if (_has_fontAlign) {
        if (_position + 2 > _maxsize) return;
        m_fontAlign = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (masks().charWrap()||masks().wordWrap()||masks().overflow()) {
        if (_position + 2 > _maxsize) return;
        m_wrapFlags = PFWrapFlags(_d + _position);
        if (!m_wrapFlags.isPresent()) return;
        _msize = m_wrapFlags.getSize();
        _position += _msize;
    }
    bool _has_textDirection = masks().textDirection();
    if (_has_textDirection) {
        if (_position + 2 > _maxsize) return;
        m_textDirection = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextCFException::TextCFException(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_masks = CFMasks(_d + _position);
    if (!m_masks.isValid()) return;
    _msize = m_masks.getSize();
    if (!(masks().pp10ext() == false)) {
         return;
    }
    if (!(masks().newEATypeface() == false)) {
         return;
    }
    if (!(masks().csTypeface() == false)) {
         return;
    }
    if (!(masks().pp11ext() == false)) {
         return;
    }
    _position += _msize;
    if (masks().bold() || masks().italic() || masks().underline() || masks().shadow() || masks().fehint() || masks().kumi() || masks().emboss() || masks().fHasStyle() != 0) {
        if (_position + 2 > _maxsize) return;
        m_fontStyle = CFStyle(_d + _position);
        if (!m_fontStyle.isPresent()) return;
        _msize = m_fontStyle.getSize();
        _position += _msize;
    }
    bool _has_fontRef = masks().typeface();
    if (_has_fontRef) {
        if (_position + 2 > _maxsize) return;
        m_fontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_oldEAFontRef = masks().oldEATypeface();
    if (_has_oldEAFontRef) {
        if (_position + 2 > _maxsize) return;
        m_oldEAFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_ansiFontRef = masks().ansiTypeface();
    if (_has_ansiFontRef) {
        if (_position + 2 > _maxsize) return;
        m_ansiFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_symbolFontRef = masks().symbolTypeface();
    if (_has_symbolFontRef) {
        if (_position + 2 > _maxsize) return;
        m_symbolFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_fontSize = masks().size();
    if (_has_fontSize) {
        if (_position + 2 > _maxsize) return;
        m_fontSize = readuint16(_d + _position);
        _msize = 2;
        if (!(((quint16)*m_fontSize)>=1)) {
             return;
        }
        if (!(((quint16)*m_fontSize)<=4000)) {
             return;
        }
        _position += _msize;
    }
    if (masks().color()) {
        if (_position + 4 > _maxsize) return;
        m_color = ColorIndexStruct(_d + _position);
        if (!m_color.isPresent()) return;
        _msize = m_color.getSize();
        _position += _msize;
    }
    bool _has_position = masks().position();
    if (_has_position) {
        if (_position + 2 > _maxsize) return;
        m_position = readint16(_d + _position);
        _msize = 2;
        if (!(((qint16)*m_position)>=-100)) {
             return;
        }
        if (!(((qint16)*m_position)<=100)) {
             return;
        }
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::FontCollectionEntry::FontCollectionEntry(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 76 > _maxsize) return;
    m_fontEntityAtom = FontEntityAtom(_d + _position);
    if (!m_fontEntityAtom.isValid()) return;
    _msize = m_fontEntityAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_fontEmbedData1 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (m_fontEmbedData1.isPresent()) ?m_fontEmbedData1.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_fontEmbedData2 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (m_fontEmbedData2.isPresent()) ?m_fontEmbedData2.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_fontEmbedData3 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (m_fontEmbedData3.isPresent()) ?m_fontEmbedData3.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_fontEmbedData4 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (m_fontEmbedData4.isPresent()) ?m_fontEmbedData4.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::KinsokuContainer::KinsokuContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x2)) {
         return;
    }
    if (!(rh().recType() == 0x0FC8)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_kinsokuAtom = KinsokuAtom(_d + _position);
    if (!m_kinsokuAtom.isValid()) return;
    _msize = m_kinsokuAtom.getSize();
    _position += _msize;
    if (kinsokuAtom().level()==2) {
        if (_position + 0 > _maxsize) return;
        m_kinsokuLeadingAtom = KinsokuLeadingAtom(_d + _position, _maxsize - _position);
        if (!m_kinsokuLeadingAtom.isPresent()) return;
        _msize = m_kinsokuLeadingAtom.getSize();
        _position += _msize;
    }
    if (kinsokuAtom().level()==2) {
        if (_position + 0 > _maxsize) return;
        m_kinsokuFollowingAtom = KinsokuFollowingAtom(_d + _position, _maxsize - _position);
        if (!m_kinsokuFollowingAtom.isPresent()) return;
        _msize = m_kinsokuFollowingAtom.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextSIException::TextSIException(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_spell = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_lang = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_altLang = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_unused1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_unused2 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fPp10ext = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_fBidi = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_unused3 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_reserved1 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_smartTag = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_reserved2a = readuint2_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_reserved2b = readuint20_4(_d + _position);
    _msize = 3;
    _position += _msize;
    bool _has_spellInfo = spell();
    if (_has_spellInfo) {
        if (_position + 2 > _maxsize) return;
        m_spellInfo = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_lid = lang();
    if (_has_lid) {
        if (_position + 2 > _maxsize) return;
        m_lid = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_altLid = altLang();
    if (_has_altLid) {
        if (_position + 2 > _maxsize) return;
        m_altLid = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_bidi = fBidi();
    if (_has_bidi) {
        if (_position + 2 > _maxsize) return;
        m_bidi = readint16(_d + _position);
        _msize = 2;
        if (!(((qint16)*m_bidi) == 0 || ((qint16)*m_bidi) == 1)) {
             return;
        }
        _position += _msize;
    }
    bool _has_pp10runid = fPp10ext();
    if (_has_pp10runid) {
        if (_position + 0 > _maxsize) return;
        m_pp10runid = readuint4(_d + _position);
        _msize = 0;
        _position += _msize;
    }
    bool _has_reserved3a = fPp10ext();
    if (_has_reserved3a) {
        if (_position + 0 > _maxsize) return;
        m_reserved3a = readuint4_4(_d + _position);
        _msize = 1;
        _position += _msize;
    }
    bool _has_reserved3b = fPp10ext();
    if (_has_reserved3b) {
        if (_position + 2 > _maxsize) return;
        m_reserved3b = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    bool _has_reserved3bc = fPp10ext();
    if (_has_reserved3bc) {
        if (_position + 0 > _maxsize) return;
        m_reserved3bc = readuint7(_d + _position);
        _msize = 0;
        _position += _msize;
    }
    bool _has_grammarError = fPp10ext();
    if (_has_grammarError) {
        if (_position + 0 > _maxsize) return;
        m_grammarError = readbit_7(_d + _position);
        _msize = 1;
        _position += _msize;
    }
    if (smartTag()) {
        if (_position + 0 > _maxsize) return;
        m_smartTags = SmartTags(_d + _position, _maxsize - _position);
        if (!m_smartTags.isPresent()) return;
        _msize = m_smartTags.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextMasterStyleLevel::TextMasterStyleLevel(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_pf = TextPFException(_d + _position, _maxsize - _position);
    if (!m_pf.isValid()) return;
    _msize = m_pf.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf = TextCFException(_d + _position, _maxsize - _position);
    if (!m_cf.isValid()) return;
    _msize = m_cf.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::DocumentAtom::_size = 48;
MSO::DocumentAtom::DocumentAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 1)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x03E9)) {
         return;
    }
    if (!(rh().recLen() == 0x28)) {
         return;
    }
    _position += _msize;
    m_slideSize = PointStruct(_d + _position);
    if (!m_slideSize.isValid()) return;
    _msize = m_slideSize.getSize();
    _position += _msize;
    m_notesSize = PointStruct(_d + _position);
    if (!m_notesSize.isValid()) return;
    _msize = m_notesSize.getSize();
    _position += _msize;
    m_serverZoom = RatioStruct(_d + _position);
    if (!m_serverZoom.isValid()) return;
    _msize = m_serverZoom.getSize();
    if (!(serverZoom().numer()*serverZoom().denom() > 0)) {
         return;
    }
    _position += _msize;
    m_notesMasterPersistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_handoutMasterPersistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_firstSlideNumber = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_firstSlideNumber)<10000)) {
         return;
    }
    _position += _msize;
    m_slideSizeType = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_slideSizeType) == 0 || ((quint16)m_slideSizeType) == 1 || ((quint16)m_slideSizeType) == 2 || ((quint16)m_slideSizeType) == 3 || ((quint16)m_slideSizeType) == 4 || ((quint16)m_slideSizeType) == 5 || ((quint16)m_slideSizeType) == 6)) {
         return;
    }
    _position += _msize;
    m_fSaveWithFonts = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fOmitTitlePlace = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fRightToLeft = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fShowComments = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::SlideTime10Atom::_size = 16;
MSO::SlideTime10Atom::SlideTime10Atom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x2EEB)) {
         return;
    }
    if (!(rh().recLen() == 8)) {
         return;
    }
    _position += _msize;
    m_fileTime = FILETIME(_d + _position);
    if (!m_fileTime.isValid()) return;
    _msize = m_fileTime.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PP12SlideBinaryTagExtension::PP12SlideBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    if (rhData().recLen() > 8) {
        if (_position + 9 > _maxsize) return;
        m_roundTripHeaderFooterDefaultsAtom = RoundTripHeaderFooterDefaults12Atom(_d + _position);
        if (!m_roundTripHeaderFooterDefaultsAtom.isPresent()) return;
        _msize = m_roundTripHeaderFooterDefaultsAtom.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ProgStringTagContainer::ProgStringTagContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1389)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_tagNameAtom = TagNameAtom(_d + _position, _maxsize - _position);
    if (!m_tagNameAtom.isValid()) return;
    _msize = m_tagNameAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_tagValueAtom = TagValueAtom(_d + _position, _maxsize - _position);
        _msize = (m_tagValueAtom.isPresent()) ?m_tagValueAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
const quint32 MSO::NotesAtom::_size = 16;
MSO::NotesAtom::NotesAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 1)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3F1)) {
         return;
    }
    if (!(rh().recLen() == 0x8)) {
         return;
    }
    _position += _msize;
    m_slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    m_slideFlags = SlideFlags(_d + _position);
    if (!m_slideFlags.isValid()) return;
    _msize = m_slideFlags.getSize();
    _position += _msize;
    m_unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::ExObjListContainer::ExObjListContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0409)) {
         return;
    }
    if (!(rh().recLen()>=12)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_exObjListAtom = ExObjListAtom(_d + _position);
    if (!m_exObjListAtom.isValid()) return;
    _msize = m_exObjListAtom.getSize();
    _position += _msize;
    if (_maxsize - _position < rh().recLen()-12) return;
    m_rgChildRec = MSOArray<ExObjListSubContainer>(_d + _position, rh().recLen()-12);
    if (m_rgChildRec.getSize() != rh().recLen()-12) return;
    _msize = m_rgChildRec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::ExControlContainer::ExControlContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFEE)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_exControlAtom = ExControlAtom(_d + _position);
    if (!m_exControlAtom.isValid()) return;
    _msize = m_exControlAtom.getSize();
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_exOleObjAtom = ExOleObjAtom(_d + _position);
    if (!m_exOleObjAtom.isValid()) return;
    _msize = m_exOleObjAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_menuNameAtom = MenuNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_menuNameAtom.isPresent()) ?m_menuNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_progIdAtom = ProgIDAtom(_d + _position, _maxsize - _position);
        _msize = (m_progIdAtom.isPresent()) ?m_progIdAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_clipboardNameAtom = ClipboardNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_clipboardNameAtom.isPresent()) ?m_clipboardNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_metafile = MetafileBlob(_d + _position, _maxsize - _position);
        _msize = (m_metafile.isPresent()) ?m_metafile.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ExHyperlinkContainer::ExHyperlinkContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFD7)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_exHyperlinkAtom = ExHyperlinkAtom(_d + _position);
    if (!m_exHyperlinkAtom.isValid()) return;
    _msize = m_exHyperlinkAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_friendlyNameAtom = FriendlyNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_friendlyNameAtom.isPresent()) ?m_friendlyNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_targetAtom = TargetAtom(_d + _position, _maxsize - _position);
        _msize = (m_targetAtom.isPresent()) ?m_targetAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_locationAtom = LocationAtom(_d + _position, _maxsize - _position);
        _msize = (m_locationAtom.isPresent()) ?m_locationAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ExOleLinkContainer::ExOleLinkContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FCE)) {
         return;
    }
    _position += _msize;
    if (_position + 20 > _maxsize) return;
    m_exOleLinkAtom = ExOleLinkAtom(_d + _position);
    if (!m_exOleLinkAtom.isValid()) return;
    _msize = m_exOleLinkAtom.getSize();
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_exOleObjAtom = ExOleObjAtom(_d + _position);
    if (!m_exOleObjAtom.isValid()) return;
    _msize = m_exOleObjAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_menuNameAtom = MenuNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_menuNameAtom.isPresent()) ?m_menuNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_progIdAtom = ProgIDAtom(_d + _position, _maxsize - _position);
        _msize = (m_progIdAtom.isPresent()) ?m_progIdAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_clipboardNameAtom = ClipboardNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_clipboardNameAtom.isPresent()) ?m_clipboardNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_metafile = MetafileBlob(_d + _position, _maxsize - _position);
        _msize = (m_metafile.isPresent()) ?m_metafile.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ExOleEmbedContainer::ExOleEmbedContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FCC)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_exOleEmbedAtom = ExOleEmbedAtom(_d + _position);
    if (!m_exOleEmbedAtom.isValid()) return;
    _msize = m_exOleEmbedAtom.getSize();
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_exOleObjAtom = ExOleObjAtom(_d + _position);
    if (!m_exOleObjAtom.isValid()) return;
    _msize = m_exOleObjAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_menuNameAtom = MenuNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_menuNameAtom.isPresent()) ?m_menuNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_progIdAtom = ProgIDAtom(_d + _position, _maxsize - _position);
        _msize = (m_progIdAtom.isPresent()) ?m_progIdAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_clipboardNameAtom = ClipboardNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_clipboardNameAtom.isPresent()) ?m_clipboardNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_metafile = MetafileBlob(_d + _position, _maxsize - _position);
        _msize = (m_metafile.isPresent()) ?m_metafile.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtFDGGBlock::OfficeArtFDGGBlock(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0F006)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_head = OfficeArtFDGG(_d + _position);
    if (!m_head.isValid()) return;
    _msize = m_head.getSize();
    _position += _msize;
    m_Rgidcl = MSOArray<OfficeArtIDCL>(_d + _position, 8 * head().cidcl()-1, head().cidcl()-1);
    if (m_Rgidcl.getCount() != head().cidcl()-1) return;
    _msize = m_Rgidcl.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtSolverContainerFileBlock::OfficeArtSolverContainerFileBlock(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._OfficeArtFConnectorRule = OfficeArtFConnectorRule(_d + _position);
    _msize = (m_anon._OfficeArtFConnectorRule.isValid()) ?OfficeArtFConnectorRule::getSize() : 0;
    if (_msize == 0) {
        m_anon._OfficeArtFArcRule = OfficeArtFArcRule(_d + _position);
        _msize = (m_anon._OfficeArtFArcRule.isValid()) ?OfficeArtFArcRule::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._OfficeArtFCalloutRule = OfficeArtFCalloutRule(_d + _position);
        _msize = (m_anon._OfficeArtFCalloutRule.isValid()) ?OfficeArtFCalloutRule::getSize() : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> OfficeArtFConnectorRule OfficeArtSolverContainerFileBlock::C_anon::get<OfficeArtFConnectorRule>() const {
        return _OfficeArtFConnectorRule;
    }
    template <> bool OfficeArtSolverContainerFileBlock::C_anon::is<OfficeArtFConnectorRule>() const {
        return _OfficeArtFConnectorRule.isValid();
    }
    template <> OfficeArtFArcRule OfficeArtSolverContainerFileBlock::C_anon::get<OfficeArtFArcRule>() const {
        return _OfficeArtFArcRule;
    }
    template <> bool OfficeArtSolverContainerFileBlock::C_anon::is<OfficeArtFArcRule>() const {
        return _OfficeArtFArcRule.isValid();
    }
    template <> OfficeArtFCalloutRule OfficeArtSolverContainerFileBlock::C_anon::get<OfficeArtFCalloutRule>() const {
        return _OfficeArtFCalloutRule;
    }
    template <> bool OfficeArtSolverContainerFileBlock::C_anon::is<OfficeArtFCalloutRule>() const {
        return _OfficeArtFCalloutRule.isValid();
    }
}
const quint32 MSO::Rotation::_size = 6;
MSO::Rotation::Rotation(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0004)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_rotation = FixedPoint(_d + _position);
    if (!m_rotation.isValid()) return;
    _msize = m_rotation.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ProtectionBooleanProperties::_size = 6;
MSO::ProtectionBooleanProperties::ProtectionBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x007F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fLockAgainstGrouping = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockAdjustHandles = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockText = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockVertices = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockCropping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockAgainstSelect = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockPosition = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockAspectRatio = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fLockRotation = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockAgainstUngrouping = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused6 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefLockAgainstGrouping = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseLockAdjustHandles = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseLockText = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockVertices = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockCropping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockAgainstSelect = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockPosition = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockAspectRatio = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefLockRotation = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockAgainstUngrouping = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ITxid::_size = 6;
MSO::ITxid::ITxid(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0080)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_iTxid = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxTextLeft::_size = 6;
MSO::DxTextLeft::DxTextLeft(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0081)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxTextLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DyTextTop::_size = 6;
MSO::DyTextTop::DyTextTop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0082)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dyTextTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxTextRight::_size = 6;
MSO::DxTextRight::DxTextRight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0083)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxTextRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DyTextBottom::_size = 6;
MSO::DyTextBottom::DyTextBottom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0084)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dyTextBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::WrapText::_size = 6;
MSO::WrapText::WrapText(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0085)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_wrapText = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_wrapText)<5)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::AnchorText::_size = 6;
MSO::AnchorText::AnchorText(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0087)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_anchorText = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_anchorText)<=9)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::TxflTextFlow::_size = 6;
MSO::TxflTextFlow::TxflTextFlow(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0088)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_txflTextFlow = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_txflTextFlow)<=5)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CdirFont::_size = 6;
MSO::CdirFont::CdirFont(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0089)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_cdirFont = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_cdirFont)<=3)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::HspNext::_size = 6;
MSO::HspNext::HspNext(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x008A)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_hspNext = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Txdir::_size = 6;
MSO::Txdir::Txdir(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x008B)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_txdir = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_txdir)<=2)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::TextBooleanProperties::_size = 6;
MSO::TextBooleanProperties::TextBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x00BF)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_unused1 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFitShapeToText = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fAutoTextMargin = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fSelectText = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused3a = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused3b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused4 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefFitShapeToText = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused5 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefAutoTextMargin = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefSelectText = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused6a = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused6b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CropFromTop::_size = 6;
MSO::CropFromTop::CropFromTop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0100)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_cropFromTop = FixedPoint(_d + _position);
    if (!m_cropFromTop.isValid()) return;
    _msize = m_cropFromTop.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CropFromBottom::_size = 6;
MSO::CropFromBottom::CropFromBottom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0101)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_cropFromBottom = FixedPoint(_d + _position);
    if (!m_cropFromBottom.isValid()) return;
    _msize = m_cropFromBottom.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CropFromLeft::_size = 6;
MSO::CropFromLeft::CropFromLeft(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0102)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_cropFromLeft = FixedPoint(_d + _position);
    if (!m_cropFromLeft.isValid()) return;
    _msize = m_cropFromLeft.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CropFromRight::_size = 6;
MSO::CropFromRight::CropFromRight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0103)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_cropFromRight = FixedPoint(_d + _position);
    if (!m_cropFromRight.isValid()) return;
    _msize = m_cropFromRight.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Pib::_size = 6;
MSO::Pib::Pib(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0104)) {
         return;
    }
    _position += _msize;
    m_pib = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PibName::_size = 6;
MSO::PibName::PibName(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0105)) {
         return;
    }
    _position += _msize;
    m_pibName = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PibFlags::_size = 6;
MSO::PibFlags::PibFlags(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0106)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_pibFlags = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PictureTransparent::_size = 6;
MSO::PictureTransparent::PictureTransparent(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0107)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_pictureTransparent = OfficeArtCOLORREF(_d + _position);
    if (!m_pictureTransparent.isValid()) return;
    _msize = m_pictureTransparent.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PictureContrast::_size = 6;
MSO::PictureContrast::PictureContrast(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0108)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_pictureContrast = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PictureBrightness::_size = 6;
MSO::PictureBrightness::PictureBrightness(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0109)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_pictureBrightness = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BlipBooleanProperties::_size = 6;
MSO::BlipBooleanProperties::BlipBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x013F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fPictureActive = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPictureBiLevel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPictureGray = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fNoHitTestPicture = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLooping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fRewind = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPicturePreserveGrays = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused1b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefPictureActive = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefPictureBiLevel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefPictureGray = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefNoHitTestPicture = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLooping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefRewind = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefPicturePreserveGrays = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GeoLeft::_size = 6;
MSO::GeoLeft::GeoLeft(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0140)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_geoLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GeoTop::_size = 6;
MSO::GeoTop::GeoTop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0141)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_geoTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GeoRight::_size = 6;
MSO::GeoRight::GeoRight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0142)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_geoRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GeoBottom::_size = 6;
MSO::GeoBottom::GeoBottom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0143)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_geoBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShapePath::_size = 6;
MSO::ShapePath::ShapePath(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0144)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_shapePath = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_shapePath)<=4)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PVertices::_size = 6;
MSO::PVertices::PVertices(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0145)) {
         return;
    }
    _position += _msize;
    m_pVertices = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PSegmentInfo::_size = 6;
MSO::PSegmentInfo::PSegmentInfo(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0146)) {
         return;
    }
    _position += _msize;
    m_pSegmentInfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::AdjustValue::_size = 6;
MSO::AdjustValue::AdjustValue(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0147)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjustvalue = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust2Value::_size = 6;
MSO::Adjust2Value::Adjust2Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0148)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust2value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust3Value::_size = 6;
MSO::Adjust3Value::Adjust3Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0149)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust3value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust4Value::_size = 6;
MSO::Adjust4Value::Adjust4Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x014A)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust4value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust5Value::_size = 6;
MSO::Adjust5Value::Adjust5Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x014B)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust5value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust6Value::_size = 6;
MSO::Adjust6Value::Adjust6Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x014C)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust6value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust7Value::_size = 6;
MSO::Adjust7Value::Adjust7Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x014D)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust7value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Adjust8Value::_size = 6;
MSO::Adjust8Value::Adjust8Value(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x014E)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_adjust8value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GeometryBooleanProperties::_size = 6;
MSO::GeometryBooleanProperties::GeometryBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x017F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fFillOk = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFillShadeShapeOK = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fGtextOK = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLineOK = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_f3DOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fShadowOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unuseda = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unusedb = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefFillOK = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefFillShadeShapeOK = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefGtextOK = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLineOK = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsef3DOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefShadowOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused3a = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused3b = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused4 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillType::_size = 6;
MSO::FillType::FillType(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0180)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillType = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_fillType)<=9)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillColor::_size = 6;
MSO::FillColor::FillColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0181)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillColor = OfficeArtCOLORREF(_d + _position);
    if (!m_fillColor.isValid()) return;
    _msize = m_fillColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillOpacity::_size = 6;
MSO::FillOpacity::FillOpacity(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0182)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillOpacity = FixedPoint(_d + _position);
    if (!m_fillOpacity.isValid()) return;
    _msize = m_fillOpacity.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillBackColor::_size = 6;
MSO::FillBackColor::FillBackColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0183)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillBackColor = OfficeArtCOLORREF(_d + _position);
    if (!m_fillBackColor.isValid()) return;
    _msize = m_fillBackColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillBackOpacity::_size = 6;
MSO::FillBackOpacity::FillBackOpacity(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0184)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillBackOpacity = FixedPoint(_d + _position);
    if (!m_fillBackOpacity.isValid()) return;
    _msize = m_fillBackOpacity.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillCrMod::_size = 6;
MSO::FillCrMod::FillCrMod(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0185)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillCrMod = OfficeArtCOLORREF(_d + _position);
    if (!m_fillCrMod.isValid()) return;
    _msize = m_fillCrMod.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillBlip::_size = 6;
MSO::FillBlip::FillBlip(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0186)) {
         return;
    }
    _position += _msize;
    m_fillBlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillBlipName::_size = 6;
MSO::FillBlipName::FillBlipName(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0187)) {
         return;
    }
    _position += _msize;
    m_fillBlipName = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillBlipFlags::_size = 6;
MSO::FillBlipFlags::FillBlipFlags(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0188)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillBlipFlags = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillWidth::_size = 6;
MSO::FillWidth::FillWidth(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0189)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillWidth = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillHeight::_size = 6;
MSO::FillHeight::FillHeight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x018A)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillHeight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillAngle::_size = 6;
MSO::FillAngle::FillAngle(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x018B)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillAngle = FixedPoint(_d + _position);
    if (!m_fillAngle.isValid()) return;
    _msize = m_fillAngle.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillFocus::_size = 6;
MSO::FillFocus::FillFocus(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x018C)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillFocus = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillToLeft::_size = 6;
MSO::FillToLeft::FillToLeft(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x018D)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillToLeft = FixedPoint(_d + _position);
    if (!m_fillToLeft.isValid()) return;
    _msize = m_fillToLeft.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillToTop::_size = 6;
MSO::FillToTop::FillToTop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x018E)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillToTop = FixedPoint(_d + _position);
    if (!m_fillToTop.isValid()) return;
    _msize = m_fillToTop.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillToRight::_size = 6;
MSO::FillToRight::FillToRight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x018F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillToRight = FixedPoint(_d + _position);
    if (!m_fillToRight.isValid()) return;
    _msize = m_fillToRight.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillToBottom::_size = 6;
MSO::FillToBottom::FillToBottom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0190)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillToBottom = FixedPoint(_d + _position);
    if (!m_fillToBottom.isValid()) return;
    _msize = m_fillToBottom.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillRectLeft::_size = 6;
MSO::FillRectLeft::FillRectLeft(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0191)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillRectLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillRectTop::_size = 6;
MSO::FillRectTop::FillRectTop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0192)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillRectTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillRectRight::_size = 6;
MSO::FillRectRight::FillRectRight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0193)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillRectRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillRectBottom::_size = 6;
MSO::FillRectBottom::FillRectBottom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0194)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillRectBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillDztype::_size = 6;
MSO::FillDztype::FillDztype(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0195)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillDztype = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillShadePreset::_size = 6;
MSO::FillShadePreset::FillShadePreset(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0196)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillShadePreset = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillShadeColors::_size = 6;
MSO::FillShadeColors::FillShadeColors(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0197)) {
         return;
    }
    _position += _msize;
    m_fillShadeColors = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillOriginX::_size = 6;
MSO::FillOriginX::FillOriginX(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0198)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillOriginX = FixedPoint(_d + _position);
    if (!m_fillOriginX.isValid()) return;
    _msize = m_fillOriginX.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillOriginY::_size = 6;
MSO::FillOriginY::FillOriginY(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0199)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillOriginY = FixedPoint(_d + _position);
    if (!m_fillOriginY.isValid()) return;
    _msize = m_fillOriginY.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillShapeOriginX::_size = 6;
MSO::FillShapeOriginX::FillShapeOriginX(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x019A)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillShapeOriginX = FixedPoint(_d + _position);
    if (!m_fillShapeOriginX.isValid()) return;
    _msize = m_fillShapeOriginX.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillShapeOriginY::_size = 6;
MSO::FillShapeOriginY::FillShapeOriginY(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x019B)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillShapeOriginY = FixedPoint(_d + _position);
    if (!m_fillShapeOriginY.isValid()) return;
    _msize = m_fillShapeOriginY.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillColorExt::_size = 6;
MSO::FillColorExt::FillColorExt(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x019E)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillColorExt = OfficeArtCOLORREF(_d + _position);
    if (!m_fillColorExt.isValid()) return;
    _msize = m_fillColorExt.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillBackColorExt::_size = 6;
MSO::FillBackColorExt::FillBackColorExt(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01A2)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fillBackColorExt = OfficeArtCOLORREF(_d + _position);
    if (!m_fillBackColorExt.isValid()) return;
    _msize = m_fillBackColorExt.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::FillStyleBooleanProperties::_size = 6;
MSO::FillStyleBooleanProperties::FillStyleBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01BF)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fNoFillHitTest = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fillUseRect = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fillShape = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHitTestFill = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFilled = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseShapeAnchor = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fRecolorFillAsPicture = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused1b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUseNoFillHitTest = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseFillUseRect = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseFillShape = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseHitTestFill = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseFilled = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseUseShapeAnchor = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefRecolorFillAsPicture = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineColor::_size = 6;
MSO::LineColor::LineColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01C0)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineColor = OfficeArtCOLORREF(_d + _position);
    if (!m_lineColor.isValid()) return;
    _msize = m_lineColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineOpacity::_size = 6;
MSO::LineOpacity::LineOpacity(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01C1)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineOpacity = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)m_lineOpacity)>=0)) {
         return;
    }
    if (!(((qint32)m_lineOpacity)<=65536)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineBackColor::_size = 6;
MSO::LineBackColor::LineBackColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01C2)) {
         return;
    }
    _position += _msize;
    m_lineBackColor = OfficeArtCOLORREF(_d + _position);
    if (!m_lineBackColor.isValid()) return;
    _msize = m_lineBackColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineFillBlip::_size = 6;
MSO::LineFillBlip::LineFillBlip(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01C5)) {
         return;
    }
    _position += _msize;
    m_lineFillBlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineWidth::_size = 6;
MSO::LineWidth::LineWidth(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01CB)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineWidth = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineStyle::_size = 6;
MSO::LineStyle::LineStyle(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01CD)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineStyle = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineDashing::_size = 6;
MSO::LineDashing::LineDashing(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01CE)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineDashing = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineStartArrowhead::_size = 6;
MSO::LineStartArrowhead::LineStartArrowhead(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D0)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineStartArrowhead = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_lineStartArrowhead)<=8)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineEndArrowhead::_size = 6;
MSO::LineEndArrowhead::LineEndArrowhead(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D1)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineEndArrowhead = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_lineEndArrowhead)<=8)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineStartArrowWidth::_size = 6;
MSO::LineStartArrowWidth::LineStartArrowWidth(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D2)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineStartArrowWidth = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineStartArrowLength::_size = 6;
MSO::LineStartArrowLength::LineStartArrowLength(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D3)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineStartArrowLength = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineEndArrowWidth::_size = 6;
MSO::LineEndArrowWidth::LineEndArrowWidth(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D4)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineEndArrowWidth = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineEndArrowLength::_size = 6;
MSO::LineEndArrowLength::LineEndArrowLength(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D5)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineEndArrowLength = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineJoinStyle::_size = 6;
MSO::LineJoinStyle::LineJoinStyle(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01D6)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lineJoinStyle = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_lineJoinStyle)<=2)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LineStyleBooleanProperties::_size = 6;
MSO::LineStyleBooleanProperties::LineStyleBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x01FF)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fNoLineDrawDash = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLineFillShape = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHitTestLine = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLine = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fArrowHeadsOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fInsetPenOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fInsetPen = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_reserved2 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLineOpaqueBackColor = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUseNoLineDrawDash = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseLineFillShape = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseHitTestLine = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLine = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefArrowHeadsOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseInsetPenOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUseInsetPen = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused3 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLineOpaqueBackColor = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused4 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShadowType::_size = 6;
MSO::ShadowType::ShadowType(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0200)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_shadowType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShadowColor::_size = 6;
MSO::ShadowColor::ShadowColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0201)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_shadowColor = OfficeArtCOLORREF(_d + _position);
    if (!m_shadowColor.isValid()) return;
    _msize = m_shadowColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShadowOpacity::_size = 6;
MSO::ShadowOpacity::ShadowOpacity(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0204)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_shadowOpacity = FixedPoint(_d + _position);
    if (!m_shadowOpacity.isValid()) return;
    _msize = m_shadowOpacity.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShadowOffsetX::_size = 6;
MSO::ShadowOffsetX::ShadowOffsetX(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0205)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_shadowOffsetX = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShadowOffsetY::_size = 6;
MSO::ShadowOffsetY::ShadowOffsetY(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0206)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_shadowOffsetY = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShadowStyleBooleanProperties::_size = 6;
MSO::ShadowStyleBooleanProperties::ShadowStyleBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x023F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fShadowObscured = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fShadow = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    m_fUsefShadowObscured = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefShadow = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::HspMaster::_size = 6;
MSO::HspMaster::HspMaster(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0301)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_hspMaster = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Cxstyle::_size = 6;
MSO::Cxstyle::Cxstyle(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0303)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_cxstyle = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_cxstyle)<=4)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BWMode::_size = 6;
MSO::BWMode::BWMode(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0304)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_bWMode = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_bWMode)<=10)) {
         return;
    }
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::ShapeBooleanProperties::_size = 6;
MSO::ShapeBooleanProperties::ShapeBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x033F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fBackground = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_reserved1 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fInitiator = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLockShapeType = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPreferRelativeResize = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fOleIcon = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFlipVOverride = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fFlipHOverride = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fPolicyBarcode = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fPolicyLabel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused3 = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefBackground = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused4 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefInitiator = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLockShapeType = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fusePreferrelativeResize = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefOleIcon = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefFlipVOverride = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefFlipHOverride = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefPolicyBarcode = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefPolicyLabel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused5 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused6 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused7 = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxyCalloutGap::_size = 6;
MSO::DxyCalloutGap::DxyCalloutGap(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0341)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxyCalloutGap = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Spcoa::_size = 6;
MSO::Spcoa::Spcoa(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0342)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_spcoa = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::Spcod::_size = 6;
MSO::Spcod::Spcod(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0343)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_spcod = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxyCalloutDropSpecified::_size = 6;
MSO::DxyCalloutDropSpecified::DxyCalloutDropSpecified(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0344)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxyCalloutDropSpecified = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxyCalloutLengthSpecified::_size = 6;
MSO::DxyCalloutLengthSpecified::DxyCalloutLengthSpecified(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0345)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxyCalloutLengthSpecified = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::CalloutBooleanProperties::_size = 6;
MSO::CalloutBooleanProperties::CalloutBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x037F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fCalloutLengthSpecified = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCalloutDropAuto = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCalloutMinusY = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCalloutMinusX = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCalloutTextBorder = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCalloutAccentBar = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fCallout = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused1b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefCalloutLengthSpecified = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefCalloutDropAuto = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefCalloutMinusY = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefCalloutMinusX = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefCalloutTextBorder = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefCalloutAccentBar = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefCallout = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PWrapPolygonVertices::_size = 6;
MSO::PWrapPolygonVertices::PWrapPolygonVertices(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0383)) {
         return;
    }
    _position += _msize;
    m_pWrapPolygonVertices = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxWrapDistLeft::_size = 6;
MSO::DxWrapDistLeft::DxWrapDistLeft(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0384)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxWrapDistLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DyWrapDistTop::_size = 6;
MSO::DyWrapDistTop::DyWrapDistTop(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0385)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dyWrapDistTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxWrapDistRight::_size = 6;
MSO::DxWrapDistRight::DxWrapDistRight(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0386)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxWrapDistRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DyWrapDistBottom::_size = 6;
MSO::DyWrapDistBottom::DyWrapDistBottom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0387)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dyWrapDistBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::LidRegroup::_size = 6;
MSO::LidRegroup::LidRegroup(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0388)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_lidRegroup = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PosH::_size = 6;
MSO::PosH::PosH(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x038F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_posH = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PosRelH::_size = 6;
MSO::PosRelH::PosRelH(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0390)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_posRelH = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PosV::_size = 6;
MSO::PosV::PosV(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0391)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_posV = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PosRelV::_size = 6;
MSO::PosRelV::PosRelV(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0392)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_posRelV = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::PctHR::_size = 6;
MSO::PctHR::PctHR(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0393)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_pctHR = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::AlignHR::_size = 6;
MSO::AlignHR::AlignHR(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0394)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_alignHR = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxHeightHR::_size = 6;
MSO::DxHeightHR::DxHeightHR(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0395)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxHeightHR = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DxWidthHR::_size = 6;
MSO::DxWidthHR::DxWidthHR(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0396)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_dxWidthHR = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BorderTopColor::_size = 6;
MSO::BorderTopColor::BorderTopColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x039b)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_borderTopColor = OfficeArtCOLORREF(_d + _position);
    if (!m_borderTopColor.isValid()) return;
    _msize = m_borderTopColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BorderLeftColor::_size = 6;
MSO::BorderLeftColor::BorderLeftColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x039c)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_borderLeftColor = OfficeArtCOLORREF(_d + _position);
    if (!m_borderLeftColor.isValid()) return;
    _msize = m_borderLeftColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BorderBottomColor::_size = 6;
MSO::BorderBottomColor::BorderBottomColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x039d)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_borderBottomColor = OfficeArtCOLORREF(_d + _position);
    if (!m_borderBottomColor.isValid()) return;
    _msize = m_borderBottomColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::BorderRightColor::_size = 6;
MSO::BorderRightColor::BorderRightColor(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x039e)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_borderRightColor = OfficeArtCOLORREF(_d + _position);
    if (!m_borderRightColor.isValid()) return;
    _msize = m_borderRightColor.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::GroupShapeBooleanProperties::_size = 6;
MSO::GroupShapeBooleanProperties::GroupShapeBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x03bf)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fPrint = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHidden = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fOneD = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fIsButton = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fOnDblClickNotify = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fBehindDocument = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fEditedWrap = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fScriptAnchor = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fReallyHidden = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fAllowOverlap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUserDrawn = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fHorizRule = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fNoshadeHR = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fStandardHR = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fIsBullet = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fLayoutInCell = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefPrint = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefHidden = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefOneD = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefIsButton = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefOnDblClickNotify = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefBehindDocument = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefEditedWrap = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefScriptAnchor = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefReallyHidden = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefAllowOverlap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefUserDrawn = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefHorizRule = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefNoshadeHR = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefStandardHR = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefIsBullet = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefLayoutInCell = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::WzFillId::_size = 6;
MSO::WzFillId::WzFillId(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x0403)) {
         return;
    }
    _position += _msize;
    m_wzFillId = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::DiagramBooleanProperties::_size = 6;
MSO::DiagramBooleanProperties::DiagramBooleanProperties(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    if (!(opid().opid() == 0x053F)) {
         return;
    }
    if (!(opid().fBid() == false)) {
         return;
    }
    if (!(opid().fComplex() == false)) {
         return;
    }
    _position += _msize;
    m_fPseudoInline = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDoLayout = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fReverse = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDoFormat = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused1 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused2 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused3a = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused3b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_fUsefPseudoInline = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefDoLayout = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefReverse = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fUsefDoFormat = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused4 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused5 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    m_unused6a = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused6b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PptOfficeArtClientAnchor::PptOfficeArtClientAnchor(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF010)) {
         return;
    }
    if (!(rh().recLen() == 0x8 || rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (rh().recLen()==0x8) {
        if (_position + 8 > _maxsize) return;
        m_rect1 = SmallRectStruct(_d + _position);
        if (!m_rect1.isPresent()) return;
        _msize = m_rect1.getSize();
        _position += _msize;
    }
    if (rh().recLen()==0x10) {
        if (_position + 16 > _maxsize) return;
        m_rect2 = RectStruct(_d + _position);
        if (!m_rect2.isPresent()) return;
        _msize = m_rect2.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::AnimationInfoContainer::AnimationInfoContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x1014)) {
         return;
    }
    _position += _msize;
    if (_position + 36 > _maxsize) return;
    m_animationAtom = AnimationInfoAtom(_d + _position);
    if (!m_animationAtom.isValid()) return;
    _msize = m_animationAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_animationSound = SoundContainer(_d + _position, _maxsize - _position);
        _msize = (m_animationSound.isPresent()) ?m_animationSound.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::MouseClickInteractiveInfoContainer::MouseClickInteractiveInfoContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFF2)) {
         return;
    }
    _position += _msize;
    if (_position + 24 > _maxsize) return;
    m_interactiveInfoAtom = InteractiveInfoAtom(_d + _position);
    if (!m_interactiveInfoAtom.isValid()) return;
    _msize = m_interactiveInfoAtom.getSize();
    _position += _msize;
    if (rh().recLen()>24) {
        if (_position + 0 > _maxsize) return;
        m_macroNameAtom = MacroNameAtom(_d + _position, _maxsize - _position);
        if (!m_macroNameAtom.isPresent()) return;
        _msize = m_macroNameAtom.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::MouseOverInteractiveInfoContainer::MouseOverInteractiveInfoContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0xFF2)) {
         return;
    }
    _position += _msize;
    if (_position + 24 > _maxsize) return;
    m_interactiveInfoAtom = InteractiveInfoAtom(_d + _position);
    if (!m_interactiveInfoAtom.isValid()) return;
    _msize = m_interactiveInfoAtom.getSize();
    _position += _msize;
    if (rh().recLen()>24) {
        if (_position + 0 > _maxsize) return;
        m_macroNameAtom = MacroNameAtom(_d + _position, _maxsize - _position);
        if (!m_macroNameAtom.isPresent()) return;
        _msize = m_macroNameAtom.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ShapeClientRoundtripDataSubcontainerOrAtom::ShapeClientRoundtripDataSubcontainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._ShapeProgsTagContainer = ShapeProgsTagContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._ShapeProgsTagContainer.getSize();
    if (_msize == 0) {
        m_anon._RoundTripNewPlaceHolderId12Atom = RoundTripNewPlaceHolderId12Atom(_d + _position);
        _msize = (m_anon._RoundTripNewPlaceHolderId12Atom.isValid()) ?RoundTripNewPlaceHolderId12Atom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._RoundTripShapeId12Atom = RoundTripShapeId12Atom(_d + _position);
        _msize = (m_anon._RoundTripShapeId12Atom.isValid()) ?RoundTripShapeId12Atom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._RoundTripHFPlaceholder12Atom = RoundTripHFPlaceholder12Atom(_d + _position);
        _msize = (m_anon._RoundTripHFPlaceholder12Atom.isValid()) ?RoundTripHFPlaceholder12Atom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._RoundTripShapeCheckSumForCustomLayouts12Atom = RoundTripShapeCheckSumForCustomLayouts12Atom(_d + _position, _maxsize - _position);
        _msize = m_anon._RoundTripShapeCheckSumForCustomLayouts12Atom.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> ShapeProgsTagContainer ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<ShapeProgsTagContainer>() const {
        return _ShapeProgsTagContainer;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<ShapeProgsTagContainer>() const {
        return _ShapeProgsTagContainer.isValid();
    }
    template <> RoundTripNewPlaceHolderId12Atom ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripNewPlaceHolderId12Atom>() const {
        return _RoundTripNewPlaceHolderId12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripNewPlaceHolderId12Atom>() const {
        return _RoundTripNewPlaceHolderId12Atom.isValid();
    }
    template <> RoundTripShapeId12Atom ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripShapeId12Atom>() const {
        return _RoundTripShapeId12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripShapeId12Atom>() const {
        return _RoundTripShapeId12Atom.isValid();
    }
    template <> RoundTripHFPlaceholder12Atom ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripHFPlaceholder12Atom>() const {
        return _RoundTripHFPlaceholder12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripHFPlaceholder12Atom>() const {
        return _RoundTripHFPlaceholder12Atom.isValid();
    }
    template <> RoundTripShapeCheckSumForCustomLayouts12Atom ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripShapeCheckSumForCustomLayouts12Atom>() const {
        return _RoundTripShapeCheckSumForCustomLayouts12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripShapeCheckSumForCustomLayouts12Atom>() const {
        return _RoundTripShapeCheckSumForCustomLayouts12Atom.isValid();
    }
}
MSO::ShapeProgBinaryTagSubContainerOrAtom::ShapeProgBinaryTagSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._PP9ShapeBinaryTagExtension = PP9ShapeBinaryTagExtension(_d + _position, _maxsize - _position);
    _msize = m_anon._PP9ShapeBinaryTagExtension.getSize();
    if (_msize == 0) {
        m_anon._PP10ShapeBinaryTagExtension = PP10ShapeBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP10ShapeBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._PP11ShapeBinaryTagExtension = PP11ShapeBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP11ShapeBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._UnknownBinaryTag = UnknownBinaryTag(_d + _position, _maxsize - _position);
        _msize = m_anon._UnknownBinaryTag.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> PP9ShapeBinaryTagExtension ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<PP9ShapeBinaryTagExtension>() const {
        return _PP9ShapeBinaryTagExtension;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<PP9ShapeBinaryTagExtension>() const {
        return _PP9ShapeBinaryTagExtension.isValid();
    }
    template <> PP10ShapeBinaryTagExtension ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<PP10ShapeBinaryTagExtension>() const {
        return _PP10ShapeBinaryTagExtension;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<PP10ShapeBinaryTagExtension>() const {
        return _PP10ShapeBinaryTagExtension.isValid();
    }
    template <> PP11ShapeBinaryTagExtension ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<PP11ShapeBinaryTagExtension>() const {
        return _PP11ShapeBinaryTagExtension;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<PP11ShapeBinaryTagExtension>() const {
        return _PP11ShapeBinaryTagExtension.isValid();
    }
    template <> UnknownBinaryTag ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<UnknownBinaryTag>() const {
        return _UnknownBinaryTag;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<UnknownBinaryTag>() const {
        return _UnknownBinaryTag.isValid();
    }
}
MSO::OfficeArtClientTextBox::OfficeArtClientTextBox(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._XlsOfficeArtClientTextBox = XlsOfficeArtClientTextBox(_d + _position);
    _msize = (m_anon._XlsOfficeArtClientTextBox.isValid()) ?XlsOfficeArtClientTextBox::getSize() : 0;
    if (_msize == 0) {
        m_anon._DocOfficeArtClientTextBox = DocOfficeArtClientTextBox(_d + _position);
        _msize = (m_anon._DocOfficeArtClientTextBox.isValid()) ?DocOfficeArtClientTextBox::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PptOfficeArtClientTextBox = PptOfficeArtClientTextBox(_d + _position, _maxsize - _position);
        _msize = m_anon._PptOfficeArtClientTextBox.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> XlsOfficeArtClientTextBox OfficeArtClientTextBox::C_anon::get<XlsOfficeArtClientTextBox>() const {
        return _XlsOfficeArtClientTextBox;
    }
    template <> bool OfficeArtClientTextBox::C_anon::is<XlsOfficeArtClientTextBox>() const {
        return _XlsOfficeArtClientTextBox.isValid();
    }
    template <> DocOfficeArtClientTextBox OfficeArtClientTextBox::C_anon::get<DocOfficeArtClientTextBox>() const {
        return _DocOfficeArtClientTextBox;
    }
    template <> bool OfficeArtClientTextBox::C_anon::is<DocOfficeArtClientTextBox>() const {
        return _DocOfficeArtClientTextBox.isValid();
    }
    template <> PptOfficeArtClientTextBox OfficeArtClientTextBox::C_anon::get<PptOfficeArtClientTextBox>() const {
        return _PptOfficeArtClientTextBox;
    }
    template <> bool OfficeArtClientTextBox::C_anon::is<PptOfficeArtClientTextBox>() const {
        return _PptOfficeArtClientTextBox.isValid();
    }
}
MSO::TextRulerAtom::TextRulerAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFA6)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_textRuler = TextRuler(_d + _position, _maxsize - _position);
    if (!m_textRuler.isValid()) return;
    _msize = m_textRuler.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtFOPTE::_size = 6;
MSO::OfficeArtFOPTE::OfficeArtFOPTE(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_opid = OfficeArtFOPTEOPID(_d + _position);
    if (!m_opid.isValid()) return;
    _msize = m_opid.getSize();
    _position += _msize;
    m_op = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::Fib::Fib(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 32 > _maxsize) return;
    m_base = FibBase(_d + _position);
    if (!m_base.isValid()) return;
    _msize = m_base.getSize();
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_csw = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_csw) == 14)) {
         return;
    }
    _position += _msize;
    if (_position + 28 > _maxsize) return;
    m_fibRgW = FibRgW97(_d + _position);
    if (!m_fibRgW.isValid()) return;
    _msize = m_fibRgW.getSize();
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cslw = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cslw) == 22)) {
         return;
    }
    _position += _msize;
    if (_position + 88 > _maxsize) return;
    m_fibRgLw = FibRgLw97(_d + _position);
    if (!m_fibRgLw.isValid()) return;
    _msize = m_fibRgLw.getSize();
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cbRgFcLcb = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cbRgFcLcb) == 0x5D || ((quint16)m_cbRgFcLcb) == 0x6C || ((quint16)m_cbRgFcLcb) == 0x88 || ((quint16)m_cbRgFcLcb) == 0xA4 || ((quint16)m_cbRgFcLcb) == 0xB7)) {
         return;
    }
    _position += _msize;
    if (_position + 744 > _maxsize) return;
    m_fibRgFcLcbBlob = FibRgFcLcb97(_d + _position);
    if (!m_fibRgFcLcbBlob.isValid()) return;
    _msize = m_fibRgFcLcbBlob.getSize();
    _position += _msize;
    if (cbRgFcLcb()>=0x6C) {
        if (_position + 120 > _maxsize) return;
        m_fibRgFcLcbBlob2 = FibRgFcLcb2000(_d + _position);
        if (!m_fibRgFcLcbBlob2.isPresent()) return;
        _msize = m_fibRgFcLcbBlob2.getSize();
        _position += _msize;
    }
    if (cbRgFcLcb()>=0x88) {
        if (_position + 200 > _maxsize) return;
        m_fibRgFcLcbBlob3 = FibRgFcLcb2002(_d + _position);
        if (!m_fibRgFcLcbBlob3.isPresent()) return;
        _msize = m_fibRgFcLcbBlob3.getSize();
        _position += _msize;
    }
    if (_position + 2 > _maxsize) return;
    m_cswNew = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cswNew) == 0 || ((quint16)m_cswNew) == 2 || ((quint16)m_cswNew) == 5)) {
         return;
    }
    _position += _msize;
    m_fibRgCswNew = MSOCastArray<char>((const char*)(_d + _position), 2*cswNew());
    _msize = (2*cswNew())*1;
    _position += _msize;
    m_trail = MSOCastArray<char>((const char*)(_d + _position), fibRgLw().cbMac()-156-8*cbRgFcLcb()-2*cswNew());
    _msize = (fibRgLw().cbMac()-156-8*cbRgFcLcb()-2*cswNew())*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::STSH::STSH(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_lpstshi = LPStshi(_d + _position, _maxsize - _position);
    if (!m_lpstshi.isValid()) return;
    _msize = m_lpstshi.getSize();
    _position += _msize;
    m_rglpstd = MSOArray<LPStd>(_d + _position, _maxsize - _position, 20);
    if (m_rglpstd.getCount() != 20) return;
    _msize = m_rglpstd.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::Clx::Clx(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    m_RgPrc = MSOArray<Pcr>(_d + _position, _maxsize - _position);
    if (!m_RgPrc.isValid()) return;
    _msize = m_RgPrc.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_pcdt = Pcdt(_d + _position, _maxsize - _position);
    if (!m_pcdt.isValid()) return;
    _msize = m_pcdt.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::Pcr::Pcr(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 1 > _maxsize) return;
    m_clxt = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_clxt) == 1)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_prcData = PrcData(_d + _position, _maxsize - _position);
    if (!m_prcData.isValid()) return;
    _msize = m_prcData.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::Prm::_size = 2;
MSO::Prm::Prm(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_prm._Prm0 = Prm0(_d + _position);
    _msize = (m_prm._Prm0.isValid()) ?Prm0::getSize() : 0;
    if (_msize == 0) {
        m_prm._Prm1 = Prm1(_d + _position);
        _msize = (m_prm._Prm1.isValid()) ?Prm1::getSize() : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
namespace MSO {
    template <> Prm0 Prm::C_prm::get<Prm0>() const {
        return _Prm0;
    }
    template <> bool Prm::C_prm::is<Prm0>() const {
        return _Prm0.isValid();
    }
    template <> Prm1 Prm::C_prm::get<Prm1>() const {
        return _Prm1;
    }
    template <> bool Prm::C_prm::is<Prm1>() const {
        return _Prm1.isValid();
    }
}
MSO::OfficeArtBlipEMF::OfficeArtBlipEMF(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x3D4 || rh().recInstance() == 0x3D5)) {
         return;
    }
    if (!(rh().recType() == 0xF01A)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x3D5;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 34 > _maxsize) return;
    m_metafileHeader = OfficeArtMetafileHeader(_d + _position);
    if (!m_metafileHeader.isValid()) return;
    _msize = m_metafileHeader.getSize();
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance()==0x3D4)?50:66));
    _msize = (rh().recLen()-((rh().recInstance()==0x3D4)?50:66))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBlipWMF::OfficeArtBlipWMF(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x216 || rh().recInstance() == 0x217)) {
         return;
    }
    if (!(rh().recType() == 0xF01B)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x217;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 34 > _maxsize) return;
    m_metafileHeader = OfficeArtMetafileHeader(_d + _position);
    if (!m_metafileHeader.isValid()) return;
    _msize = m_metafileHeader.getSize();
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance()==0x216)?50:66));
    _msize = (rh().recLen()-((rh().recInstance()==0x216)?50:66))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBlipPICT::OfficeArtBlipPICT(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0x542 || rh().recInstance() == 0x543)) {
         return;
    }
    if (!(rh().recType() == 0xF01C)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    bool _has_rgbUid2 = rh().recInstance() == 0x543;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        m_rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 34 > _maxsize) return;
    m_metafileHeader = OfficeArtMetafileHeader(_d + _position);
    if (!m_metafileHeader.isValid()) return;
    _msize = m_metafileHeader.getSize();
    _position += _msize;
    m_BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh().recLen()-((rh().recInstance()==0x542)?50:66));
    _msize = (rh().recLen()-((rh().recInstance()==0x542)?50:66))*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBlip::OfficeArtBlip(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._OfficeArtBlipEMF = OfficeArtBlipEMF(_d + _position, _maxsize - _position);
    _msize = m_anon._OfficeArtBlipEMF.getSize();
    if (_msize == 0) {
        m_anon._OfficeArtBlipWMF = OfficeArtBlipWMF(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlipWMF.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtBlipPICT = OfficeArtBlipPICT(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlipPICT.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtBlipJPEG = OfficeArtBlipJPEG(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlipJPEG.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtBlipPNG = OfficeArtBlipPNG(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlipPNG.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtBlipDIB = OfficeArtBlipDIB(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlipDIB.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtBlipTIFF = OfficeArtBlipTIFF(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlipTIFF.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> OfficeArtBlipEMF OfficeArtBlip::C_anon::get<OfficeArtBlipEMF>() const {
        return _OfficeArtBlipEMF;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipEMF>() const {
        return _OfficeArtBlipEMF.isValid();
    }
    template <> OfficeArtBlipWMF OfficeArtBlip::C_anon::get<OfficeArtBlipWMF>() const {
        return _OfficeArtBlipWMF;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipWMF>() const {
        return _OfficeArtBlipWMF.isValid();
    }
    template <> OfficeArtBlipPICT OfficeArtBlip::C_anon::get<OfficeArtBlipPICT>() const {
        return _OfficeArtBlipPICT;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipPICT>() const {
        return _OfficeArtBlipPICT.isValid();
    }
    template <> OfficeArtBlipJPEG OfficeArtBlip::C_anon::get<OfficeArtBlipJPEG>() const {
        return _OfficeArtBlipJPEG;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipJPEG>() const {
        return _OfficeArtBlipJPEG.isValid();
    }
    template <> OfficeArtBlipPNG OfficeArtBlip::C_anon::get<OfficeArtBlipPNG>() const {
        return _OfficeArtBlipPNG;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipPNG>() const {
        return _OfficeArtBlipPNG.isValid();
    }
    template <> OfficeArtBlipDIB OfficeArtBlip::C_anon::get<OfficeArtBlipDIB>() const {
        return _OfficeArtBlipDIB;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipDIB>() const {
        return _OfficeArtBlipDIB.isValid();
    }
    template <> OfficeArtBlipTIFF OfficeArtBlip::C_anon::get<OfficeArtBlipTIFF>() const {
        return _OfficeArtBlipTIFF;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipTIFF>() const {
        return _OfficeArtBlipTIFF.isValid();
    }
}
const quint32 MSO::ZoomViewInfoAtom::_size = 60;
MSO::ZoomViewInfoAtom::ZoomViewInfoAtom(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x3FD)) {
         return;
    }
    if (!(rh().recLen() == 0x34)) {
         return;
    }
    _position += _msize;
    m_curScale = ScalingStruct(_d + _position);
    if (!m_curScale.isValid()) return;
    _msize = m_curScale.getSize();
    _position += _msize;
    m_unused1 = MSOCastArray<char>((const char*)(_d + _position), 24);
    _msize = (24)*1;
    _position += _msize;
    m_origin = PointStruct(_d + _position);
    if (!m_origin.isValid()) return;
    _msize = m_origin.getSize();
    _position += _msize;
    m_fUseVarScale = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_fUseVarScale) == 0 || ((quint8)m_fUseVarScale) == 1)) {
         return;
    }
    _position += _msize;
    m_fDraftMode = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    m_unused2 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::PP9DocBinaryTagExtension::PP9DocBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen() == 0x0E)) {
         return;
    }
    _position += _msize;
    if (_position + 14 > _maxsize) return;
    m_tagName = MSOCastArray<char>((const char*)(_d + _position), 14);
    _msize = (14)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0x0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_rgTextMasterStyle9 = MSOArray<TextMasterStyle9Atom>(_d + _position, _maxsize - _position);
    if (!m_rgTextMasterStyle9.isValid()) return;
    _msize = m_rgTextMasterStyle9.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_blipCollectionContainer = BlipCollection9Container(_d + _position, _maxsize - _position);
        _msize = (m_blipCollectionContainer.isPresent()) ?m_blipCollectionContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_textDefaultsAtom = TextDefaults9Atom(_d + _position, _maxsize - _position);
        _msize = (m_textDefaultsAtom.isPresent()) ?m_textDefaultsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_kinsokuContainer = Kinsoku9Container(_d + _position, _maxsize - _position);
        _msize = (m_kinsokuContainer.isPresent()) ?m_kinsokuContainer.getSize() :0;
        _position += _msize;
    }
    m_rgExternalHyperlink9 = MSOArray<ExHyperlink9Container>(_d + _position, _maxsize - _position);
    if (!m_rgExternalHyperlink9.isValid()) return;
    _msize = m_rgExternalHyperlink9.getSize();
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        m_presAdvisorFlagsAtom = PresAdvisorFlags9Atom(_d + _position);
        _msize = (m_presAdvisorFlagsAtom.isPresent()) ?m_presAdvisorFlagsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_envelopeDataAtom = EnvelopeData9Atom(_d + _position, _maxsize - _position);
        _msize = (m_envelopeDataAtom.isPresent()) ?m_envelopeDataAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        m_envelopeFlagsAtom = EnvelopeFlags9Atom(_d + _position);
        _msize = (m_envelopeFlagsAtom.isPresent()) ?m_envelopeFlagsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 24 <= _maxsize) {
        m_htmlDocInfoAtom = HTMLDocInfo9Atom(_d + _position);
        _msize = (m_htmlDocInfoAtom.isPresent()) ?m_htmlDocInfoAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_htmlPublishInfoAtom = HTMLPublishInfo9Container(_d + _position, _maxsize - _position);
        _msize = (m_htmlPublishInfoAtom.isPresent()) ?m_htmlPublishInfoAtom.getSize() :0;
        _position += _msize;
    }
    m_rgBroadcastDocInfo9 = MSOArray<BroadcastDocInfo9Container>(_d + _position, _maxsize - _position);
    if (!m_rgBroadcastDocInfo9.isValid()) return;
    _msize = m_rgBroadcastDocInfo9.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_outlineTextPropsContainer = OutlineTextProps9Container(_d + _position, _maxsize - _position);
        _msize = (m_outlineTextPropsContainer.isPresent()) ?m_outlineTextPropsContainer.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextMasterStyle9Level::TextMasterStyle9Level(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_pf9 = TextPFException9(_d + _position, _maxsize - _position);
    if (!m_pf9.isValid()) return;
    _msize = m_pf9.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf9 = TextCFException9(_d + _position, _maxsize - _position);
    if (!m_cf9.isValid()) return;
    _msize = m_cf9.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::StyleTextProp9::StyleTextProp9(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_pf9 = TextPFException9(_d + _position, _maxsize - _position);
    if (!m_pf9.isValid()) return;
    _msize = m_pf9.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf9 = TextCFException9(_d + _position, _maxsize - _position);
    if (!m_cf9.isValid()) return;
    _msize = m_cf9.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_si = TextSIException(_d + _position, _maxsize - _position);
    if (!m_si.isValid()) return;
    _msize = m_si.getSize();
    if (!(si().spell() == false)) {
         return;
    }
    if (!(si().lang() == false)) {
         return;
    }
    if (!(si().altLang() == false)) {
         return;
    }
    if (!(si().smartTag() == false)) {
         return;
    }
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::PP10DocBinaryTagExtension::PP10DocBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0FBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0x0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_fontCollectionContainer = FontCollection10Container(_d + _position, _maxsize - _position);
        _msize = (m_fontCollectionContainer.isPresent()) ?m_fontCollectionContainer.getSize() :0;
        _position += _msize;
    }
    m_rgTextMasterStyle10 = MSOArray<TextMasterStyle10Atom>(_d + _position, _maxsize - _position);
    if (!m_rgTextMasterStyle10.isValid()) return;
    _msize = m_rgTextMasterStyle10.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_textDefaultsAtom = TextDefaults10Atom(_d + _position, _maxsize - _position);
        _msize = (m_textDefaultsAtom.isPresent()) ?m_textDefaultsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 16 > _maxsize) return;
    m_gridSpacingAtom = GridSpacing10Atom(_d + _position);
    if (!m_gridSpacingAtom.isValid()) return;
    _msize = m_gridSpacingAtom.getSize();
    _position += _msize;
    m_rgCommentIndex10 = MSOArray<CommentIndex10Container>(_d + _position, _maxsize - _position);
    if (!m_rgCommentIndex10.isValid()) return;
    _msize = m_rgCommentIndex10.getSize();
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        m_fontEmbedFlagsAtom = FontEmbedFlags10Atom(_d + _position);
        _msize = (m_fontEmbedFlagsAtom.isPresent()) ?m_fontEmbedFlagsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_copyrightAtom = CopyrightAtom(_d + _position, _maxsize - _position);
        _msize = (m_copyrightAtom.isPresent()) ?m_copyrightAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_keywordsAtom = KeywordsAtom(_d + _position, _maxsize - _position);
        _msize = (m_keywordsAtom.isPresent()) ?m_keywordsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        m_filterPrivacyFlagsAtom = FilterPrivacyFlags10Atom(_d + _position);
        _msize = (m_filterPrivacyFlagsAtom.isPresent()) ?m_filterPrivacyFlagsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_outlineTextPropsContainer = OutlineTextProps10Container(_d + _position, _maxsize - _position);
        _msize = (m_outlineTextPropsContainer.isPresent()) ?m_outlineTextPropsContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 9 <= _maxsize) {
        m_docToolbarStatesAtom = DocToolbarStates10Atom(_d + _position);
        _msize = (m_docToolbarStatesAtom.isPresent()) ?m_docToolbarStatesAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideListTableContainer = SlideListTable10Container(_d + _position, _maxsize - _position);
        _msize = (m_slideListTableContainer.isPresent()) ?m_slideListTableContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_rgDiffTree10Container = DiffTree10Container(_d + _position, _maxsize - _position);
        _msize = (m_rgDiffTree10Container.isPresent()) ?m_rgDiffTree10Container.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_modifyPasswordAtom = ModifyPasswordAtom(_d + _position, _maxsize - _position);
        _msize = (m_modifyPasswordAtom.isPresent()) ?m_modifyPasswordAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 14 <= _maxsize) {
        m_photoAlbumInfoAtom = PhotoAlbumInfo10Atom(_d + _position);
        _msize = (m_photoAlbumInfoAtom.isPresent()) ?m_photoAlbumInfoAtom.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextMasterStyle10Level::TextMasterStyle10Level(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_cf10 = TextCFException10(_d + _position, _maxsize - _position);
    if (!m_cf10.isValid()) return;
    _msize = m_cf10.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::NotesTextViewInfoContainer::_size = 68;
MSO::NotesTextViewInfoContainer::NotesTextViewInfoContainer(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x413)) {
         return;
    }
    _position += _msize;
    m_zoomViewInfo = ZoomViewInfoAtom(_d + _position);
    if (!m_zoomViewInfo.isValid()) return;
    _msize = m_zoomViewInfo.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::OutlineViewInfoContainer::_size = 68;
MSO::OutlineViewInfoContainer::OutlineViewInfoContainer(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x407)) {
         return;
    }
    _position += _msize;
    m_noZoomViewInfo = NoZoomViewInfoAtom(_d + _position);
    if (!m_noZoomViewInfo.isValid()) return;
    _msize = m_noZoomViewInfo.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
const quint32 MSO::NormalViewSetInfoContainer::_size = 36;
MSO::NormalViewSetInfoContainer::NormalViewSetInfoContainer(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x414)) {
         return;
    }
    if (!(rh().recLen() == 0x1C)) {
         return;
    }
    _position += _msize;
    m_normalViewSetInfoAtom = NormalViewSetInfoAtom(_d + _position);
    if (!m_normalViewSetInfoAtom.isValid()) return;
    _msize = m_normalViewSetInfoAtom.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::SlideListWithTextSubContainerOrAtom::SlideListWithTextSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 28 > _maxsize) return;
    m_slidePersistAtom = SlidePersistAtom(_d + _position);
    if (!m_slidePersistAtom.isValid()) return;
    _msize = m_slidePersistAtom.getSize();
    _position += _msize;
    m_atoms = MSOArray<TextContainer>(_d + _position, _maxsize - _position);
    if (!m_atoms.isValid()) return;
    _msize = m_atoms.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::MouseClickTextInfo::MouseClickTextInfo(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_interactive = MouseClickInteractiveInfoContainer(_d + _position, _maxsize - _position);
    if (!m_interactive.isValid()) return;
    _msize = m_interactive.getSize();
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_text = MouseClickTextInteractiveInfoAtom(_d + _position);
    if (!m_text.isValid()) return;
    _msize = m_text.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::MouseOverTextInfo::MouseOverTextInfo(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_interactive = MouseOverInteractiveInfoContainer(_d + _position, _maxsize - _position);
    if (!m_interactive.isValid()) return;
    _msize = m_interactive.getSize();
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_text = MouseOverTextInteractiveInfoAtom(_d + _position);
    if (!m_text.isValid()) return;
    _msize = m_text.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextClientDataSubContainerOrAtom::TextClientDataSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._OutlineTextRefAtom = OutlineTextRefAtom(_d + _position);
    _msize = (m_anon._OutlineTextRefAtom.isValid()) ?OutlineTextRefAtom::getSize() : 0;
    if (_msize == 0) {
        m_anon._TextContainer = TextContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._TextContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._TextRulerAtom = TextRulerAtom(_d + _position, _maxsize - _position);
        _msize = m_anon._TextRulerAtom.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> OutlineTextRefAtom TextClientDataSubContainerOrAtom::C_anon::get<OutlineTextRefAtom>() const {
        return _OutlineTextRefAtom;
    }
    template <> bool TextClientDataSubContainerOrAtom::C_anon::is<OutlineTextRefAtom>() const {
        return _OutlineTextRefAtom.isValid();
    }
    template <> TextContainer TextClientDataSubContainerOrAtom::C_anon::get<TextContainer>() const {
        return _TextContainer;
    }
    template <> bool TextClientDataSubContainerOrAtom::C_anon::is<TextContainer>() const {
        return _TextContainer.isValid();
    }
    template <> TextRulerAtom TextClientDataSubContainerOrAtom::C_anon::get<TextRulerAtom>() const {
        return _TextRulerAtom;
    }
    template <> bool TextClientDataSubContainerOrAtom::C_anon::is<TextRulerAtom>() const {
        return _TextRulerAtom.isValid();
    }
}
MSO::TextPFRun::TextPFRun(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_count = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_count)>0)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_indentLevel = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_indentLevel)<=4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_pf = TextPFException(_d + _position, _maxsize - _position);
    if (!m_pf.isValid()) return;
    _msize = m_pf.getSize();
    if (!(pf().masks().leftMargin() == false)) {
         return;
    }
    if (!(pf().masks().indent() == false)) {
         return;
    }
    if (!(pf().masks().defaultTabSize() == false)) {
         return;
    }
    if (!(pf().masks().tabStops() == false)) {
         return;
    }
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextCFRun::TextCFRun(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_count = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_count)>0)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf = TextCFException(_d + _position, _maxsize - _position);
    if (!m_cf.isValid()) return;
    _msize = m_cf.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextCFExceptionAtom::TextCFExceptionAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FA4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_cf = TextCFException(_d + _position, _maxsize - _position);
    if (!m_cf.isValid()) return;
    _msize = m_cf.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::DefaultRulerAtom::DefaultRulerAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FAB)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_defaultTextRuler = TextRuler(_d + _position, _maxsize - _position);
    if (!m_defaultTextRuler.isValid()) return;
    _msize = m_defaultTextRuler.getSize();
    if (!(defaultTextRuler().fDefaultTabSize() == true)) {
         return;
    }
    if (!(defaultTextRuler().fCLevels() == true)) {
         return;
    }
    if (!(defaultTextRuler().fTabStops() == true)) {
         return;
    }
    if (!(defaultTextRuler().fLeftMargin1() == true)) {
         return;
    }
    if (!(defaultTextRuler().fLeftMargin2() == true)) {
         return;
    }
    if (!(defaultTextRuler().fLeftMargin3() == true)) {
         return;
    }
    if (!(defaultTextRuler().fLeftMargin4() == true)) {
         return;
    }
    if (!(defaultTextRuler().fIndent1() == true)) {
         return;
    }
    if (!(defaultTextRuler().fIndent2() == true)) {
         return;
    }
    if (!(defaultTextRuler().fIndent3() == true)) {
         return;
    }
    if (!(defaultTextRuler().fIndent4() == true)) {
         return;
    }
    if (!(defaultTextRuler().fIndent5() == true)) {
         return;
    }
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextPFExceptionAtom::TextPFExceptionAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FA5)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_reserved = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_pf = TextPFException(_d + _position, _maxsize - _position);
    if (!m_pf.isValid()) return;
    _msize = m_pf.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextSIRun::TextSIRun(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    m_count = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)m_count)>=1)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_si = TextSIException(_d + _position, _maxsize - _position);
    if (!m_si.isValid()) return;
    _msize = m_si.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextSIExceptionAtom::TextSIExceptionAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0FA9)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_textSIException = TextSIException(_d + _position, _maxsize - _position);
    if (!m_textSIException.isValid()) return;
    _msize = m_textSIException.getSize();
    if (!(textSIException().fPp10ext() == false)) {
         return;
    }
    if (!(textSIException().fBidi() == false)) {
         return;
    }
    if (!(textSIException().smartTag() == false)) {
         return;
    }
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextMasterStyleAtom::TextMasterStyleAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1 || rh().recInstance() == 2 || rh().recInstance() == 3 || rh().recInstance() == 4 || rh().recInstance() == 5 || rh().recInstance() == 6 || rh().recInstance() == 7 || rh().recInstance() == 8)) {
         return;
    }
    if (!(rh().recType() == 0x0FA3)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cLevels = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cLevels)<=5)) {
         return;
    }
    _position += _msize;
    bool _has_lstLvl1level = cLevels()>0 && rh().recInstance()>=5;
    if (_has_lstLvl1level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl1level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>0) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl1 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (!m_lstLvl1.isPresent()) return;
        _msize = m_lstLvl1.getSize();
        _position += _msize;
    }
    bool _has_lstLvl2level = cLevels()>1 && rh().recInstance()>=5;
    if (_has_lstLvl2level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl2level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>1) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl2 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (!m_lstLvl2.isPresent()) return;
        _msize = m_lstLvl2.getSize();
        _position += _msize;
    }
    bool _has_lstLvl3level = cLevels()>2 && rh().recInstance()>=5;
    if (_has_lstLvl3level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl3level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>2) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl3 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (!m_lstLvl3.isPresent()) return;
        _msize = m_lstLvl3.getSize();
        _position += _msize;
    }
    bool _has_lstLvl4level = cLevels()>3 && rh().recInstance()>=5;
    if (_has_lstLvl4level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl4level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>3) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl4 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (!m_lstLvl4.isPresent()) return;
        _msize = m_lstLvl4.getSize();
        _position += _msize;
    }
    bool _has_lstLvl5level = cLevels()>4 && rh().recInstance()>=5;
    if (_has_lstLvl5level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl5level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>4) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl5 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (!m_lstLvl5.isPresent()) return;
        _msize = m_lstLvl5.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::PP10SlideBinaryTagExtension::PP10SlideBinaryTagExtension(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xFBA)) {
         return;
    }
    if (!(rh().recLen() == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_rhData = RecordHeader(_d + _position);
    if (!m_rhData.isValid()) return;
    _msize = m_rhData.getSize();
    if (!(rhData().recVer() == 0)) {
         return;
    }
    if (!(rhData().recInstance() == 0)) {
         return;
    }
    if (!(rhData().recType() == 0x138B)) {
         return;
    }
    _position += _msize;
    m_rgTextMasterStyleAtom = MSOArray<TextMasterStyle10Atom>(_d + _position, _maxsize - _position);
    if (!m_rgTextMasterStyleAtom.isValid()) return;
    _msize = m_rgTextMasterStyleAtom.getSize();
    _position += _msize;
    m_rgComment10Container = MSOArray<Comment10Container>(_d + _position, _maxsize - _position);
    if (!m_rgComment10Container.isValid()) return;
    _msize = m_rgComment10Container.getSize();
    _position += _msize;
    if (_position + 16 <= _maxsize) {
        m_linkedSlideAtom = LinkedSlide10Atom(_d + _position);
        _msize = (m_linkedSlideAtom.isPresent()) ?m_linkedSlideAtom.getSize() :0;
        _position += _msize;
    }
    m_rgLinkedShape10Atom = MSOArray<LinkedShape10Atom>(_d + _position, _maxsize - _position);
    if (!m_rgLinkedShape10Atom.isValid()) return;
    _msize = m_rgLinkedShape10Atom.getSize();
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        m_slideFlagsAtom = SlideFlags10Atom(_d + _position);
        _msize = (m_slideFlagsAtom.isPresent()) ?m_slideFlagsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 16 <= _maxsize) {
        m_slideTimeAtom = SlideTime10Atom(_d + _position);
        _msize = (m_slideTimeAtom.isPresent()) ?m_slideTimeAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_unknown = UnknownSlideContainerChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown.isPresent()) ?m_unknown.getSize() :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        m_hashCodeAtom = HashCode10Atom(_d + _position);
        _msize = (m_hashCodeAtom.isPresent()) ?m_hashCodeAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_extTimeNodeContainer = ExtTimeNodeContainer(_d + _position, _maxsize - _position);
        _msize = (m_extTimeNodeContainer.isPresent()) ?m_extTimeNodeContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_buildListContainer = BuildListContainer(_d + _position, _maxsize - _position);
        _msize = (m_buildListContainer.isPresent()) ?m_buildListContainer.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ExObjListSubContainer::ExObjListSubContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._ExAviMovieContainer = ExAviMovieContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._ExAviMovieContainer.getSize();
    if (_msize == 0) {
        m_anon._ExCDAudioContainer = ExCDAudioContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExCDAudioContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExControlContainer = ExControlContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExControlContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExHyperlinkContainer = ExHyperlinkContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExHyperlinkContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExMCIMovieContainer = ExMCIMovieContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExMCIMovieContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExMIDIAudioContainer = ExMIDIAudioContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExMIDIAudioContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExOleEmbedContainer = ExOleEmbedContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExOleEmbedContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExOleLinkContainer = ExOleLinkContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExOleLinkContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExWAVAudioEmbeddedContainer = ExWAVAudioEmbeddedContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExWAVAudioEmbeddedContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExWAVAudioLinkContainer = ExWAVAudioLinkContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ExWAVAudioLinkContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._UnknownExObjListSubContainerChild = UnknownExObjListSubContainerChild(_d + _position, _maxsize - _position);
        _msize = m_anon._UnknownExObjListSubContainerChild.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> ExAviMovieContainer ExObjListSubContainer::C_anon::get<ExAviMovieContainer>() const {
        return _ExAviMovieContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExAviMovieContainer>() const {
        return _ExAviMovieContainer.isValid();
    }
    template <> ExCDAudioContainer ExObjListSubContainer::C_anon::get<ExCDAudioContainer>() const {
        return _ExCDAudioContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExCDAudioContainer>() const {
        return _ExCDAudioContainer.isValid();
    }
    template <> ExControlContainer ExObjListSubContainer::C_anon::get<ExControlContainer>() const {
        return _ExControlContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExControlContainer>() const {
        return _ExControlContainer.isValid();
    }
    template <> ExHyperlinkContainer ExObjListSubContainer::C_anon::get<ExHyperlinkContainer>() const {
        return _ExHyperlinkContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExHyperlinkContainer>() const {
        return _ExHyperlinkContainer.isValid();
    }
    template <> ExMCIMovieContainer ExObjListSubContainer::C_anon::get<ExMCIMovieContainer>() const {
        return _ExMCIMovieContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExMCIMovieContainer>() const {
        return _ExMCIMovieContainer.isValid();
    }
    template <> ExMIDIAudioContainer ExObjListSubContainer::C_anon::get<ExMIDIAudioContainer>() const {
        return _ExMIDIAudioContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExMIDIAudioContainer>() const {
        return _ExMIDIAudioContainer.isValid();
    }
    template <> ExOleEmbedContainer ExObjListSubContainer::C_anon::get<ExOleEmbedContainer>() const {
        return _ExOleEmbedContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExOleEmbedContainer>() const {
        return _ExOleEmbedContainer.isValid();
    }
    template <> ExOleLinkContainer ExObjListSubContainer::C_anon::get<ExOleLinkContainer>() const {
        return _ExOleLinkContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExOleLinkContainer>() const {
        return _ExOleLinkContainer.isValid();
    }
    template <> ExWAVAudioEmbeddedContainer ExObjListSubContainer::C_anon::get<ExWAVAudioEmbeddedContainer>() const {
        return _ExWAVAudioEmbeddedContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExWAVAudioEmbeddedContainer>() const {
        return _ExWAVAudioEmbeddedContainer.isValid();
    }
    template <> ExWAVAudioLinkContainer ExObjListSubContainer::C_anon::get<ExWAVAudioLinkContainer>() const {
        return _ExWAVAudioLinkContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExWAVAudioLinkContainer>() const {
        return _ExWAVAudioLinkContainer.isValid();
    }
    template <> UnknownExObjListSubContainerChild ExObjListSubContainer::C_anon::get<UnknownExObjListSubContainerChild>() const {
        return _UnknownExObjListSubContainerChild;
    }
    template <> bool ExObjListSubContainer::C_anon::is<UnknownExObjListSubContainerChild>() const {
        return _UnknownExObjListSubContainerChild.isValid();
    }
}
MSO::OfficeArtDggContainer::OfficeArtDggContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x0F000)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_drawingGroup = OfficeArtFDGGBlock(_d + _position, _maxsize - _position);
    if (!m_drawingGroup.isValid()) return;
    _msize = m_drawingGroup.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_blipStore = OfficeArtBStoreContainer(_d + _position, _maxsize - _position);
        _msize = (m_blipStore.isPresent()) ?m_blipStore.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_drawingPrimaryOptions = OfficeArtFOPT(_d + _position, _maxsize - _position);
        _msize = (m_drawingPrimaryOptions.isPresent()) ?m_drawingPrimaryOptions.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_drawingTertiaryOptions = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (m_drawingTertiaryOptions.isPresent()) ?m_drawingTertiaryOptions.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_colorMRU = OfficeArtColorMRUContainer(_d + _position, _maxsize - _position);
        _msize = (m_colorMRU.isPresent()) ?m_colorMRU.getSize() :0;
        _position += _msize;
    }
    if (_position + 24 > _maxsize) return;
    m_splitColors = OfficeArtSplitMenuColorContainer(_d + _position);
    if (!m_splitColors.isValid()) return;
    _msize = m_splitColors.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_blipStore2 = OfficeArtBStoreContainer(_d + _position, _maxsize - _position);
        _msize = (m_blipStore2.isPresent()) ?m_blipStore2.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_unknown = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (m_unknown.isPresent()) ?m_unknown.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
const quint32 MSO::OfficeArtFOPTEChoice::_size = 6;
MSO::OfficeArtFOPTEChoice::OfficeArtFOPTEChoice(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_anon._Rotation = Rotation(_d + _position);
    _msize = (m_anon._Rotation.isValid()) ?Rotation::getSize() : 0;
    if (_msize == 0) {
        m_anon._ProtectionBooleanProperties = ProtectionBooleanProperties(_d + _position);
        _msize = (m_anon._ProtectionBooleanProperties.isValid()) ?ProtectionBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ITxid = ITxid(_d + _position);
        _msize = (m_anon._ITxid.isValid()) ?ITxid::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxTextLeft = DxTextLeft(_d + _position);
        _msize = (m_anon._DxTextLeft.isValid()) ?DxTextLeft::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DyTextTop = DyTextTop(_d + _position);
        _msize = (m_anon._DyTextTop.isValid()) ?DyTextTop::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxTextRight = DxTextRight(_d + _position);
        _msize = (m_anon._DxTextRight.isValid()) ?DxTextRight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DyTextBottom = DyTextBottom(_d + _position);
        _msize = (m_anon._DyTextBottom.isValid()) ?DyTextBottom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._WrapText = WrapText(_d + _position);
        _msize = (m_anon._WrapText.isValid()) ?WrapText::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._AnchorText = AnchorText(_d + _position);
        _msize = (m_anon._AnchorText.isValid()) ?AnchorText::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._TxflTextFlow = TxflTextFlow(_d + _position);
        _msize = (m_anon._TxflTextFlow.isValid()) ?TxflTextFlow::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._CdirFont = CdirFont(_d + _position);
        _msize = (m_anon._CdirFont.isValid()) ?CdirFont::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._HspNext = HspNext(_d + _position);
        _msize = (m_anon._HspNext.isValid()) ?HspNext::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Txdir = Txdir(_d + _position);
        _msize = (m_anon._Txdir.isValid()) ?Txdir::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._TextBooleanProperties = TextBooleanProperties(_d + _position);
        _msize = (m_anon._TextBooleanProperties.isValid()) ?TextBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._CropFromTop = CropFromTop(_d + _position);
        _msize = (m_anon._CropFromTop.isValid()) ?CropFromTop::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._CropFromBottom = CropFromBottom(_d + _position);
        _msize = (m_anon._CropFromBottom.isValid()) ?CropFromBottom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._CropFromLeft = CropFromLeft(_d + _position);
        _msize = (m_anon._CropFromLeft.isValid()) ?CropFromLeft::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._CropFromRight = CropFromRight(_d + _position);
        _msize = (m_anon._CropFromRight.isValid()) ?CropFromRight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Pib = Pib(_d + _position);
        _msize = (m_anon._Pib.isValid()) ?Pib::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PibName = PibName(_d + _position);
        _msize = (m_anon._PibName.isValid()) ?PibName::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PibFlags = PibFlags(_d + _position);
        _msize = (m_anon._PibFlags.isValid()) ?PibFlags::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PictureTransparent = PictureTransparent(_d + _position);
        _msize = (m_anon._PictureTransparent.isValid()) ?PictureTransparent::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PictureContrast = PictureContrast(_d + _position);
        _msize = (m_anon._PictureContrast.isValid()) ?PictureContrast::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PictureBrightness = PictureBrightness(_d + _position);
        _msize = (m_anon._PictureBrightness.isValid()) ?PictureBrightness::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._BlipBooleanProperties = BlipBooleanProperties(_d + _position);
        _msize = (m_anon._BlipBooleanProperties.isValid()) ?BlipBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._GeoLeft = GeoLeft(_d + _position);
        _msize = (m_anon._GeoLeft.isValid()) ?GeoLeft::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._GeoTop = GeoTop(_d + _position);
        _msize = (m_anon._GeoTop.isValid()) ?GeoTop::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._GeoRight = GeoRight(_d + _position);
        _msize = (m_anon._GeoRight.isValid()) ?GeoRight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._GeoBottom = GeoBottom(_d + _position);
        _msize = (m_anon._GeoBottom.isValid()) ?GeoBottom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShapePath = ShapePath(_d + _position);
        _msize = (m_anon._ShapePath.isValid()) ?ShapePath::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PVertices = PVertices(_d + _position);
        _msize = (m_anon._PVertices.isValid()) ?PVertices::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PSegmentInfo = PSegmentInfo(_d + _position);
        _msize = (m_anon._PSegmentInfo.isValid()) ?PSegmentInfo::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._AdjustValue = AdjustValue(_d + _position);
        _msize = (m_anon._AdjustValue.isValid()) ?AdjustValue::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust2Value = Adjust2Value(_d + _position);
        _msize = (m_anon._Adjust2Value.isValid()) ?Adjust2Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust3Value = Adjust3Value(_d + _position);
        _msize = (m_anon._Adjust3Value.isValid()) ?Adjust3Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust4Value = Adjust4Value(_d + _position);
        _msize = (m_anon._Adjust4Value.isValid()) ?Adjust4Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust5Value = Adjust5Value(_d + _position);
        _msize = (m_anon._Adjust5Value.isValid()) ?Adjust5Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust6Value = Adjust6Value(_d + _position);
        _msize = (m_anon._Adjust6Value.isValid()) ?Adjust6Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust7Value = Adjust7Value(_d + _position);
        _msize = (m_anon._Adjust7Value.isValid()) ?Adjust7Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Adjust8Value = Adjust8Value(_d + _position);
        _msize = (m_anon._Adjust8Value.isValid()) ?Adjust8Value::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._GeometryBooleanProperties = GeometryBooleanProperties(_d + _position);
        _msize = (m_anon._GeometryBooleanProperties.isValid()) ?GeometryBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillType = FillType(_d + _position);
        _msize = (m_anon._FillType.isValid()) ?FillType::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillColor = FillColor(_d + _position);
        _msize = (m_anon._FillColor.isValid()) ?FillColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillOpacity = FillOpacity(_d + _position);
        _msize = (m_anon._FillOpacity.isValid()) ?FillOpacity::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillBackColor = FillBackColor(_d + _position);
        _msize = (m_anon._FillBackColor.isValid()) ?FillBackColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillBackOpacity = FillBackOpacity(_d + _position);
        _msize = (m_anon._FillBackOpacity.isValid()) ?FillBackOpacity::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillCrMod = FillCrMod(_d + _position);
        _msize = (m_anon._FillCrMod.isValid()) ?FillCrMod::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillBlip = FillBlip(_d + _position);
        _msize = (m_anon._FillBlip.isValid()) ?FillBlip::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillBlipName = FillBlipName(_d + _position);
        _msize = (m_anon._FillBlipName.isValid()) ?FillBlipName::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillBlipFlags = FillBlipFlags(_d + _position);
        _msize = (m_anon._FillBlipFlags.isValid()) ?FillBlipFlags::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillWidth = FillWidth(_d + _position);
        _msize = (m_anon._FillWidth.isValid()) ?FillWidth::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillHeight = FillHeight(_d + _position);
        _msize = (m_anon._FillHeight.isValid()) ?FillHeight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillAngle = FillAngle(_d + _position);
        _msize = (m_anon._FillAngle.isValid()) ?FillAngle::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillFocus = FillFocus(_d + _position);
        _msize = (m_anon._FillFocus.isValid()) ?FillFocus::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillToLeft = FillToLeft(_d + _position);
        _msize = (m_anon._FillToLeft.isValid()) ?FillToLeft::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillToTop = FillToTop(_d + _position);
        _msize = (m_anon._FillToTop.isValid()) ?FillToTop::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillToRight = FillToRight(_d + _position);
        _msize = (m_anon._FillToRight.isValid()) ?FillToRight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillToBottom = FillToBottom(_d + _position);
        _msize = (m_anon._FillToBottom.isValid()) ?FillToBottom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillRectLeft = FillRectLeft(_d + _position);
        _msize = (m_anon._FillRectLeft.isValid()) ?FillRectLeft::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillRectTop = FillRectTop(_d + _position);
        _msize = (m_anon._FillRectTop.isValid()) ?FillRectTop::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillRectRight = FillRectRight(_d + _position);
        _msize = (m_anon._FillRectRight.isValid()) ?FillRectRight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillRectBottom = FillRectBottom(_d + _position);
        _msize = (m_anon._FillRectBottom.isValid()) ?FillRectBottom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillDztype = FillDztype(_d + _position);
        _msize = (m_anon._FillDztype.isValid()) ?FillDztype::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillShadePreset = FillShadePreset(_d + _position);
        _msize = (m_anon._FillShadePreset.isValid()) ?FillShadePreset::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillShadeColors = FillShadeColors(_d + _position);
        _msize = (m_anon._FillShadeColors.isValid()) ?FillShadeColors::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillOriginX = FillOriginX(_d + _position);
        _msize = (m_anon._FillOriginX.isValid()) ?FillOriginX::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillOriginY = FillOriginY(_d + _position);
        _msize = (m_anon._FillOriginY.isValid()) ?FillOriginY::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillShapeOriginX = FillShapeOriginX(_d + _position);
        _msize = (m_anon._FillShapeOriginX.isValid()) ?FillShapeOriginX::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillShapeOriginY = FillShapeOriginY(_d + _position);
        _msize = (m_anon._FillShapeOriginY.isValid()) ?FillShapeOriginY::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillColorExt = FillColorExt(_d + _position);
        _msize = (m_anon._FillColorExt.isValid()) ?FillColorExt::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillBackColorExt = FillBackColorExt(_d + _position);
        _msize = (m_anon._FillBackColorExt.isValid()) ?FillBackColorExt::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._FillStyleBooleanProperties = FillStyleBooleanProperties(_d + _position);
        _msize = (m_anon._FillStyleBooleanProperties.isValid()) ?FillStyleBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineColor = LineColor(_d + _position);
        _msize = (m_anon._LineColor.isValid()) ?LineColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineOpacity = LineOpacity(_d + _position);
        _msize = (m_anon._LineOpacity.isValid()) ?LineOpacity::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineBackColor = LineBackColor(_d + _position);
        _msize = (m_anon._LineBackColor.isValid()) ?LineBackColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineFillBlip = LineFillBlip(_d + _position);
        _msize = (m_anon._LineFillBlip.isValid()) ?LineFillBlip::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineWidth = LineWidth(_d + _position);
        _msize = (m_anon._LineWidth.isValid()) ?LineWidth::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineStyle = LineStyle(_d + _position);
        _msize = (m_anon._LineStyle.isValid()) ?LineStyle::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineDashing = LineDashing(_d + _position);
        _msize = (m_anon._LineDashing.isValid()) ?LineDashing::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineStartArrowhead = LineStartArrowhead(_d + _position);
        _msize = (m_anon._LineStartArrowhead.isValid()) ?LineStartArrowhead::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineEndArrowhead = LineEndArrowhead(_d + _position);
        _msize = (m_anon._LineEndArrowhead.isValid()) ?LineEndArrowhead::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineStartArrowWidth = LineStartArrowWidth(_d + _position);
        _msize = (m_anon._LineStartArrowWidth.isValid()) ?LineStartArrowWidth::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineStartArrowLength = LineStartArrowLength(_d + _position);
        _msize = (m_anon._LineStartArrowLength.isValid()) ?LineStartArrowLength::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineEndArrowWidth = LineEndArrowWidth(_d + _position);
        _msize = (m_anon._LineEndArrowWidth.isValid()) ?LineEndArrowWidth::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineEndArrowLength = LineEndArrowLength(_d + _position);
        _msize = (m_anon._LineEndArrowLength.isValid()) ?LineEndArrowLength::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineJoinStyle = LineJoinStyle(_d + _position);
        _msize = (m_anon._LineJoinStyle.isValid()) ?LineJoinStyle::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LineStyleBooleanProperties = LineStyleBooleanProperties(_d + _position);
        _msize = (m_anon._LineStyleBooleanProperties.isValid()) ?LineStyleBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShadowType = ShadowType(_d + _position);
        _msize = (m_anon._ShadowType.isValid()) ?ShadowType::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShadowColor = ShadowColor(_d + _position);
        _msize = (m_anon._ShadowColor.isValid()) ?ShadowColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShadowOpacity = ShadowOpacity(_d + _position);
        _msize = (m_anon._ShadowOpacity.isValid()) ?ShadowOpacity::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShadowOffsetX = ShadowOffsetX(_d + _position);
        _msize = (m_anon._ShadowOffsetX.isValid()) ?ShadowOffsetX::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShadowOffsetY = ShadowOffsetY(_d + _position);
        _msize = (m_anon._ShadowOffsetY.isValid()) ?ShadowOffsetY::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShadowStyleBooleanProperties = ShadowStyleBooleanProperties(_d + _position);
        _msize = (m_anon._ShadowStyleBooleanProperties.isValid()) ?ShadowStyleBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._HspMaster = HspMaster(_d + _position);
        _msize = (m_anon._HspMaster.isValid()) ?HspMaster::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Cxstyle = Cxstyle(_d + _position);
        _msize = (m_anon._Cxstyle.isValid()) ?Cxstyle::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._BWMode = BWMode(_d + _position);
        _msize = (m_anon._BWMode.isValid()) ?BWMode::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._ShapeBooleanProperties = ShapeBooleanProperties(_d + _position);
        _msize = (m_anon._ShapeBooleanProperties.isValid()) ?ShapeBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxyCalloutGap = DxyCalloutGap(_d + _position);
        _msize = (m_anon._DxyCalloutGap.isValid()) ?DxyCalloutGap::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Spcoa = Spcoa(_d + _position);
        _msize = (m_anon._Spcoa.isValid()) ?Spcoa::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._Spcod = Spcod(_d + _position);
        _msize = (m_anon._Spcod.isValid()) ?Spcod::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxyCalloutDropSpecified = DxyCalloutDropSpecified(_d + _position);
        _msize = (m_anon._DxyCalloutDropSpecified.isValid()) ?DxyCalloutDropSpecified::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxyCalloutLengthSpecified = DxyCalloutLengthSpecified(_d + _position);
        _msize = (m_anon._DxyCalloutLengthSpecified.isValid()) ?DxyCalloutLengthSpecified::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._CalloutBooleanProperties = CalloutBooleanProperties(_d + _position);
        _msize = (m_anon._CalloutBooleanProperties.isValid()) ?CalloutBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PWrapPolygonVertices = PWrapPolygonVertices(_d + _position);
        _msize = (m_anon._PWrapPolygonVertices.isValid()) ?PWrapPolygonVertices::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxWrapDistLeft = DxWrapDistLeft(_d + _position);
        _msize = (m_anon._DxWrapDistLeft.isValid()) ?DxWrapDistLeft::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DyWrapDistTop = DyWrapDistTop(_d + _position);
        _msize = (m_anon._DyWrapDistTop.isValid()) ?DyWrapDistTop::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxWrapDistRight = DxWrapDistRight(_d + _position);
        _msize = (m_anon._DxWrapDistRight.isValid()) ?DxWrapDistRight::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DyWrapDistBottom = DyWrapDistBottom(_d + _position);
        _msize = (m_anon._DyWrapDistBottom.isValid()) ?DyWrapDistBottom::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._LidRegroup = LidRegroup(_d + _position);
        _msize = (m_anon._LidRegroup.isValid()) ?LidRegroup::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PosH = PosH(_d + _position);
        _msize = (m_anon._PosH.isValid()) ?PosH::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PosRelH = PosRelH(_d + _position);
        _msize = (m_anon._PosRelH.isValid()) ?PosRelH::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PosV = PosV(_d + _position);
        _msize = (m_anon._PosV.isValid()) ?PosV::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PosRelV = PosRelV(_d + _position);
        _msize = (m_anon._PosRelV.isValid()) ?PosRelV::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._PctHR = PctHR(_d + _position);
        _msize = (m_anon._PctHR.isValid()) ?PctHR::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._AlignHR = AlignHR(_d + _position);
        _msize = (m_anon._AlignHR.isValid()) ?AlignHR::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxHeightHR = DxHeightHR(_d + _position);
        _msize = (m_anon._DxHeightHR.isValid()) ?DxHeightHR::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DxWidthHR = DxWidthHR(_d + _position);
        _msize = (m_anon._DxWidthHR.isValid()) ?DxWidthHR::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._BorderTopColor = BorderTopColor(_d + _position);
        _msize = (m_anon._BorderTopColor.isValid()) ?BorderTopColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._BorderLeftColor = BorderLeftColor(_d + _position);
        _msize = (m_anon._BorderLeftColor.isValid()) ?BorderLeftColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._BorderBottomColor = BorderBottomColor(_d + _position);
        _msize = (m_anon._BorderBottomColor.isValid()) ?BorderBottomColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._BorderRightColor = BorderRightColor(_d + _position);
        _msize = (m_anon._BorderRightColor.isValid()) ?BorderRightColor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._GroupShapeBooleanProperties = GroupShapeBooleanProperties(_d + _position);
        _msize = (m_anon._GroupShapeBooleanProperties.isValid()) ?GroupShapeBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._WzFillId = WzFillId(_d + _position);
        _msize = (m_anon._WzFillId.isValid()) ?WzFillId::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._DiagramBooleanProperties = DiagramBooleanProperties(_d + _position);
        _msize = (m_anon._DiagramBooleanProperties.isValid()) ?DiagramBooleanProperties::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._OfficeArtFOPTE = OfficeArtFOPTE(_d + _position);
        _msize = (m_anon._OfficeArtFOPTE.isValid()) ?OfficeArtFOPTE::getSize() : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
namespace MSO {
    template <> Rotation OfficeArtFOPTEChoice::C_anon::get<Rotation>() const {
        return _Rotation;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Rotation>() const {
        return _Rotation.isValid();
    }
    template <> ProtectionBooleanProperties OfficeArtFOPTEChoice::C_anon::get<ProtectionBooleanProperties>() const {
        return _ProtectionBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ProtectionBooleanProperties>() const {
        return _ProtectionBooleanProperties.isValid();
    }
    template <> ITxid OfficeArtFOPTEChoice::C_anon::get<ITxid>() const {
        return _ITxid;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ITxid>() const {
        return _ITxid.isValid();
    }
    template <> DxTextLeft OfficeArtFOPTEChoice::C_anon::get<DxTextLeft>() const {
        return _DxTextLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxTextLeft>() const {
        return _DxTextLeft.isValid();
    }
    template <> DyTextTop OfficeArtFOPTEChoice::C_anon::get<DyTextTop>() const {
        return _DyTextTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyTextTop>() const {
        return _DyTextTop.isValid();
    }
    template <> DxTextRight OfficeArtFOPTEChoice::C_anon::get<DxTextRight>() const {
        return _DxTextRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxTextRight>() const {
        return _DxTextRight.isValid();
    }
    template <> DyTextBottom OfficeArtFOPTEChoice::C_anon::get<DyTextBottom>() const {
        return _DyTextBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyTextBottom>() const {
        return _DyTextBottom.isValid();
    }
    template <> WrapText OfficeArtFOPTEChoice::C_anon::get<WrapText>() const {
        return _WrapText;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<WrapText>() const {
        return _WrapText.isValid();
    }
    template <> AnchorText OfficeArtFOPTEChoice::C_anon::get<AnchorText>() const {
        return _AnchorText;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<AnchorText>() const {
        return _AnchorText.isValid();
    }
    template <> TxflTextFlow OfficeArtFOPTEChoice::C_anon::get<TxflTextFlow>() const {
        return _TxflTextFlow;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<TxflTextFlow>() const {
        return _TxflTextFlow.isValid();
    }
    template <> CdirFont OfficeArtFOPTEChoice::C_anon::get<CdirFont>() const {
        return _CdirFont;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CdirFont>() const {
        return _CdirFont.isValid();
    }
    template <> HspNext OfficeArtFOPTEChoice::C_anon::get<HspNext>() const {
        return _HspNext;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<HspNext>() const {
        return _HspNext.isValid();
    }
    template <> Txdir OfficeArtFOPTEChoice::C_anon::get<Txdir>() const {
        return _Txdir;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Txdir>() const {
        return _Txdir.isValid();
    }
    template <> TextBooleanProperties OfficeArtFOPTEChoice::C_anon::get<TextBooleanProperties>() const {
        return _TextBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<TextBooleanProperties>() const {
        return _TextBooleanProperties.isValid();
    }
    template <> CropFromTop OfficeArtFOPTEChoice::C_anon::get<CropFromTop>() const {
        return _CropFromTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromTop>() const {
        return _CropFromTop.isValid();
    }
    template <> CropFromBottom OfficeArtFOPTEChoice::C_anon::get<CropFromBottom>() const {
        return _CropFromBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromBottom>() const {
        return _CropFromBottom.isValid();
    }
    template <> CropFromLeft OfficeArtFOPTEChoice::C_anon::get<CropFromLeft>() const {
        return _CropFromLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromLeft>() const {
        return _CropFromLeft.isValid();
    }
    template <> CropFromRight OfficeArtFOPTEChoice::C_anon::get<CropFromRight>() const {
        return _CropFromRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromRight>() const {
        return _CropFromRight.isValid();
    }
    template <> Pib OfficeArtFOPTEChoice::C_anon::get<Pib>() const {
        return _Pib;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Pib>() const {
        return _Pib.isValid();
    }
    template <> PibName OfficeArtFOPTEChoice::C_anon::get<PibName>() const {
        return _PibName;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PibName>() const {
        return _PibName.isValid();
    }
    template <> PibFlags OfficeArtFOPTEChoice::C_anon::get<PibFlags>() const {
        return _PibFlags;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PibFlags>() const {
        return _PibFlags.isValid();
    }
    template <> PictureTransparent OfficeArtFOPTEChoice::C_anon::get<PictureTransparent>() const {
        return _PictureTransparent;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PictureTransparent>() const {
        return _PictureTransparent.isValid();
    }
    template <> PictureContrast OfficeArtFOPTEChoice::C_anon::get<PictureContrast>() const {
        return _PictureContrast;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PictureContrast>() const {
        return _PictureContrast.isValid();
    }
    template <> PictureBrightness OfficeArtFOPTEChoice::C_anon::get<PictureBrightness>() const {
        return _PictureBrightness;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PictureBrightness>() const {
        return _PictureBrightness.isValid();
    }
    template <> BlipBooleanProperties OfficeArtFOPTEChoice::C_anon::get<BlipBooleanProperties>() const {
        return _BlipBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BlipBooleanProperties>() const {
        return _BlipBooleanProperties.isValid();
    }
    template <> GeoLeft OfficeArtFOPTEChoice::C_anon::get<GeoLeft>() const {
        return _GeoLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoLeft>() const {
        return _GeoLeft.isValid();
    }
    template <> GeoTop OfficeArtFOPTEChoice::C_anon::get<GeoTop>() const {
        return _GeoTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoTop>() const {
        return _GeoTop.isValid();
    }
    template <> GeoRight OfficeArtFOPTEChoice::C_anon::get<GeoRight>() const {
        return _GeoRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoRight>() const {
        return _GeoRight.isValid();
    }
    template <> GeoBottom OfficeArtFOPTEChoice::C_anon::get<GeoBottom>() const {
        return _GeoBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoBottom>() const {
        return _GeoBottom.isValid();
    }
    template <> ShapePath OfficeArtFOPTEChoice::C_anon::get<ShapePath>() const {
        return _ShapePath;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShapePath>() const {
        return _ShapePath.isValid();
    }
    template <> PVertices OfficeArtFOPTEChoice::C_anon::get<PVertices>() const {
        return _PVertices;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PVertices>() const {
        return _PVertices.isValid();
    }
    template <> PSegmentInfo OfficeArtFOPTEChoice::C_anon::get<PSegmentInfo>() const {
        return _PSegmentInfo;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PSegmentInfo>() const {
        return _PSegmentInfo.isValid();
    }
    template <> AdjustValue OfficeArtFOPTEChoice::C_anon::get<AdjustValue>() const {
        return _AdjustValue;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<AdjustValue>() const {
        return _AdjustValue.isValid();
    }
    template <> Adjust2Value OfficeArtFOPTEChoice::C_anon::get<Adjust2Value>() const {
        return _Adjust2Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust2Value>() const {
        return _Adjust2Value.isValid();
    }
    template <> Adjust3Value OfficeArtFOPTEChoice::C_anon::get<Adjust3Value>() const {
        return _Adjust3Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust3Value>() const {
        return _Adjust3Value.isValid();
    }
    template <> Adjust4Value OfficeArtFOPTEChoice::C_anon::get<Adjust4Value>() const {
        return _Adjust4Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust4Value>() const {
        return _Adjust4Value.isValid();
    }
    template <> Adjust5Value OfficeArtFOPTEChoice::C_anon::get<Adjust5Value>() const {
        return _Adjust5Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust5Value>() const {
        return _Adjust5Value.isValid();
    }
    template <> Adjust6Value OfficeArtFOPTEChoice::C_anon::get<Adjust6Value>() const {
        return _Adjust6Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust6Value>() const {
        return _Adjust6Value.isValid();
    }
    template <> Adjust7Value OfficeArtFOPTEChoice::C_anon::get<Adjust7Value>() const {
        return _Adjust7Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust7Value>() const {
        return _Adjust7Value.isValid();
    }
    template <> Adjust8Value OfficeArtFOPTEChoice::C_anon::get<Adjust8Value>() const {
        return _Adjust8Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust8Value>() const {
        return _Adjust8Value.isValid();
    }
    template <> GeometryBooleanProperties OfficeArtFOPTEChoice::C_anon::get<GeometryBooleanProperties>() const {
        return _GeometryBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeometryBooleanProperties>() const {
        return _GeometryBooleanProperties.isValid();
    }
    template <> FillType OfficeArtFOPTEChoice::C_anon::get<FillType>() const {
        return _FillType;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillType>() const {
        return _FillType.isValid();
    }
    template <> FillColor OfficeArtFOPTEChoice::C_anon::get<FillColor>() const {
        return _FillColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillColor>() const {
        return _FillColor.isValid();
    }
    template <> FillOpacity OfficeArtFOPTEChoice::C_anon::get<FillOpacity>() const {
        return _FillOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillOpacity>() const {
        return _FillOpacity.isValid();
    }
    template <> FillBackColor OfficeArtFOPTEChoice::C_anon::get<FillBackColor>() const {
        return _FillBackColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBackColor>() const {
        return _FillBackColor.isValid();
    }
    template <> FillBackOpacity OfficeArtFOPTEChoice::C_anon::get<FillBackOpacity>() const {
        return _FillBackOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBackOpacity>() const {
        return _FillBackOpacity.isValid();
    }
    template <> FillCrMod OfficeArtFOPTEChoice::C_anon::get<FillCrMod>() const {
        return _FillCrMod;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillCrMod>() const {
        return _FillCrMod.isValid();
    }
    template <> FillBlip OfficeArtFOPTEChoice::C_anon::get<FillBlip>() const {
        return _FillBlip;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBlip>() const {
        return _FillBlip.isValid();
    }
    template <> FillBlipName OfficeArtFOPTEChoice::C_anon::get<FillBlipName>() const {
        return _FillBlipName;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBlipName>() const {
        return _FillBlipName.isValid();
    }
    template <> FillBlipFlags OfficeArtFOPTEChoice::C_anon::get<FillBlipFlags>() const {
        return _FillBlipFlags;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBlipFlags>() const {
        return _FillBlipFlags.isValid();
    }
    template <> FillWidth OfficeArtFOPTEChoice::C_anon::get<FillWidth>() const {
        return _FillWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillWidth>() const {
        return _FillWidth.isValid();
    }
    template <> FillHeight OfficeArtFOPTEChoice::C_anon::get<FillHeight>() const {
        return _FillHeight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillHeight>() const {
        return _FillHeight.isValid();
    }
    template <> FillAngle OfficeArtFOPTEChoice::C_anon::get<FillAngle>() const {
        return _FillAngle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillAngle>() const {
        return _FillAngle.isValid();
    }
    template <> FillFocus OfficeArtFOPTEChoice::C_anon::get<FillFocus>() const {
        return _FillFocus;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillFocus>() const {
        return _FillFocus.isValid();
    }
    template <> FillToLeft OfficeArtFOPTEChoice::C_anon::get<FillToLeft>() const {
        return _FillToLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToLeft>() const {
        return _FillToLeft.isValid();
    }
    template <> FillToTop OfficeArtFOPTEChoice::C_anon::get<FillToTop>() const {
        return _FillToTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToTop>() const {
        return _FillToTop.isValid();
    }
    template <> FillToRight OfficeArtFOPTEChoice::C_anon::get<FillToRight>() const {
        return _FillToRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToRight>() const {
        return _FillToRight.isValid();
    }
    template <> FillToBottom OfficeArtFOPTEChoice::C_anon::get<FillToBottom>() const {
        return _FillToBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToBottom>() const {
        return _FillToBottom.isValid();
    }
    template <> FillRectLeft OfficeArtFOPTEChoice::C_anon::get<FillRectLeft>() const {
        return _FillRectLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectLeft>() const {
        return _FillRectLeft.isValid();
    }
    template <> FillRectTop OfficeArtFOPTEChoice::C_anon::get<FillRectTop>() const {
        return _FillRectTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectTop>() const {
        return _FillRectTop.isValid();
    }
    template <> FillRectRight OfficeArtFOPTEChoice::C_anon::get<FillRectRight>() const {
        return _FillRectRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectRight>() const {
        return _FillRectRight.isValid();
    }
    template <> FillRectBottom OfficeArtFOPTEChoice::C_anon::get<FillRectBottom>() const {
        return _FillRectBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectBottom>() const {
        return _FillRectBottom.isValid();
    }
    template <> FillDztype OfficeArtFOPTEChoice::C_anon::get<FillDztype>() const {
        return _FillDztype;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillDztype>() const {
        return _FillDztype.isValid();
    }
    template <> FillShadePreset OfficeArtFOPTEChoice::C_anon::get<FillShadePreset>() const {
        return _FillShadePreset;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShadePreset>() const {
        return _FillShadePreset.isValid();
    }
    template <> FillShadeColors OfficeArtFOPTEChoice::C_anon::get<FillShadeColors>() const {
        return _FillShadeColors;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShadeColors>() const {
        return _FillShadeColors.isValid();
    }
    template <> FillOriginX OfficeArtFOPTEChoice::C_anon::get<FillOriginX>() const {
        return _FillOriginX;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillOriginX>() const {
        return _FillOriginX.isValid();
    }
    template <> FillOriginY OfficeArtFOPTEChoice::C_anon::get<FillOriginY>() const {
        return _FillOriginY;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillOriginY>() const {
        return _FillOriginY.isValid();
    }
    template <> FillShapeOriginX OfficeArtFOPTEChoice::C_anon::get<FillShapeOriginX>() const {
        return _FillShapeOriginX;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShapeOriginX>() const {
        return _FillShapeOriginX.isValid();
    }
    template <> FillShapeOriginY OfficeArtFOPTEChoice::C_anon::get<FillShapeOriginY>() const {
        return _FillShapeOriginY;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShapeOriginY>() const {
        return _FillShapeOriginY.isValid();
    }
    template <> FillColorExt OfficeArtFOPTEChoice::C_anon::get<FillColorExt>() const {
        return _FillColorExt;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillColorExt>() const {
        return _FillColorExt.isValid();
    }
    template <> FillBackColorExt OfficeArtFOPTEChoice::C_anon::get<FillBackColorExt>() const {
        return _FillBackColorExt;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBackColorExt>() const {
        return _FillBackColorExt.isValid();
    }
    template <> FillStyleBooleanProperties OfficeArtFOPTEChoice::C_anon::get<FillStyleBooleanProperties>() const {
        return _FillStyleBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillStyleBooleanProperties>() const {
        return _FillStyleBooleanProperties.isValid();
    }
    template <> LineColor OfficeArtFOPTEChoice::C_anon::get<LineColor>() const {
        return _LineColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineColor>() const {
        return _LineColor.isValid();
    }
    template <> LineOpacity OfficeArtFOPTEChoice::C_anon::get<LineOpacity>() const {
        return _LineOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineOpacity>() const {
        return _LineOpacity.isValid();
    }
    template <> LineBackColor OfficeArtFOPTEChoice::C_anon::get<LineBackColor>() const {
        return _LineBackColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineBackColor>() const {
        return _LineBackColor.isValid();
    }
    template <> LineFillBlip OfficeArtFOPTEChoice::C_anon::get<LineFillBlip>() const {
        return _LineFillBlip;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineFillBlip>() const {
        return _LineFillBlip.isValid();
    }
    template <> LineWidth OfficeArtFOPTEChoice::C_anon::get<LineWidth>() const {
        return _LineWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineWidth>() const {
        return _LineWidth.isValid();
    }
    template <> LineStyle OfficeArtFOPTEChoice::C_anon::get<LineStyle>() const {
        return _LineStyle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStyle>() const {
        return _LineStyle.isValid();
    }
    template <> LineDashing OfficeArtFOPTEChoice::C_anon::get<LineDashing>() const {
        return _LineDashing;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineDashing>() const {
        return _LineDashing.isValid();
    }
    template <> LineStartArrowhead OfficeArtFOPTEChoice::C_anon::get<LineStartArrowhead>() const {
        return _LineStartArrowhead;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStartArrowhead>() const {
        return _LineStartArrowhead.isValid();
    }
    template <> LineEndArrowhead OfficeArtFOPTEChoice::C_anon::get<LineEndArrowhead>() const {
        return _LineEndArrowhead;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineEndArrowhead>() const {
        return _LineEndArrowhead.isValid();
    }
    template <> LineStartArrowWidth OfficeArtFOPTEChoice::C_anon::get<LineStartArrowWidth>() const {
        return _LineStartArrowWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStartArrowWidth>() const {
        return _LineStartArrowWidth.isValid();
    }
    template <> LineStartArrowLength OfficeArtFOPTEChoice::C_anon::get<LineStartArrowLength>() const {
        return _LineStartArrowLength;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStartArrowLength>() const {
        return _LineStartArrowLength.isValid();
    }
    template <> LineEndArrowWidth OfficeArtFOPTEChoice::C_anon::get<LineEndArrowWidth>() const {
        return _LineEndArrowWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineEndArrowWidth>() const {
        return _LineEndArrowWidth.isValid();
    }
    template <> LineEndArrowLength OfficeArtFOPTEChoice::C_anon::get<LineEndArrowLength>() const {
        return _LineEndArrowLength;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineEndArrowLength>() const {
        return _LineEndArrowLength.isValid();
    }
    template <> LineJoinStyle OfficeArtFOPTEChoice::C_anon::get<LineJoinStyle>() const {
        return _LineJoinStyle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineJoinStyle>() const {
        return _LineJoinStyle.isValid();
    }
    template <> LineStyleBooleanProperties OfficeArtFOPTEChoice::C_anon::get<LineStyleBooleanProperties>() const {
        return _LineStyleBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStyleBooleanProperties>() const {
        return _LineStyleBooleanProperties.isValid();
    }
    template <> ShadowType OfficeArtFOPTEChoice::C_anon::get<ShadowType>() const {
        return _ShadowType;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowType>() const {
        return _ShadowType.isValid();
    }
    template <> ShadowColor OfficeArtFOPTEChoice::C_anon::get<ShadowColor>() const {
        return _ShadowColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowColor>() const {
        return _ShadowColor.isValid();
    }
    template <> ShadowOpacity OfficeArtFOPTEChoice::C_anon::get<ShadowOpacity>() const {
        return _ShadowOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowOpacity>() const {
        return _ShadowOpacity.isValid();
    }
    template <> ShadowOffsetX OfficeArtFOPTEChoice::C_anon::get<ShadowOffsetX>() const {
        return _ShadowOffsetX;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowOffsetX>() const {
        return _ShadowOffsetX.isValid();
    }
    template <> ShadowOffsetY OfficeArtFOPTEChoice::C_anon::get<ShadowOffsetY>() const {
        return _ShadowOffsetY;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowOffsetY>() const {
        return _ShadowOffsetY.isValid();
    }
    template <> ShadowStyleBooleanProperties OfficeArtFOPTEChoice::C_anon::get<ShadowStyleBooleanProperties>() const {
        return _ShadowStyleBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowStyleBooleanProperties>() const {
        return _ShadowStyleBooleanProperties.isValid();
    }
    template <> HspMaster OfficeArtFOPTEChoice::C_anon::get<HspMaster>() const {
        return _HspMaster;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<HspMaster>() const {
        return _HspMaster.isValid();
    }
    template <> Cxstyle OfficeArtFOPTEChoice::C_anon::get<Cxstyle>() const {
        return _Cxstyle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Cxstyle>() const {
        return _Cxstyle.isValid();
    }
    template <> BWMode OfficeArtFOPTEChoice::C_anon::get<BWMode>() const {
        return _BWMode;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BWMode>() const {
        return _BWMode.isValid();
    }
    template <> ShapeBooleanProperties OfficeArtFOPTEChoice::C_anon::get<ShapeBooleanProperties>() const {
        return _ShapeBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShapeBooleanProperties>() const {
        return _ShapeBooleanProperties.isValid();
    }
    template <> DxyCalloutGap OfficeArtFOPTEChoice::C_anon::get<DxyCalloutGap>() const {
        return _DxyCalloutGap;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxyCalloutGap>() const {
        return _DxyCalloutGap.isValid();
    }
    template <> Spcoa OfficeArtFOPTEChoice::C_anon::get<Spcoa>() const {
        return _Spcoa;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Spcoa>() const {
        return _Spcoa.isValid();
    }
    template <> Spcod OfficeArtFOPTEChoice::C_anon::get<Spcod>() const {
        return _Spcod;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Spcod>() const {
        return _Spcod.isValid();
    }
    template <> DxyCalloutDropSpecified OfficeArtFOPTEChoice::C_anon::get<DxyCalloutDropSpecified>() const {
        return _DxyCalloutDropSpecified;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxyCalloutDropSpecified>() const {
        return _DxyCalloutDropSpecified.isValid();
    }
    template <> DxyCalloutLengthSpecified OfficeArtFOPTEChoice::C_anon::get<DxyCalloutLengthSpecified>() const {
        return _DxyCalloutLengthSpecified;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxyCalloutLengthSpecified>() const {
        return _DxyCalloutLengthSpecified.isValid();
    }
    template <> CalloutBooleanProperties OfficeArtFOPTEChoice::C_anon::get<CalloutBooleanProperties>() const {
        return _CalloutBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CalloutBooleanProperties>() const {
        return _CalloutBooleanProperties.isValid();
    }
    template <> PWrapPolygonVertices OfficeArtFOPTEChoice::C_anon::get<PWrapPolygonVertices>() const {
        return _PWrapPolygonVertices;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PWrapPolygonVertices>() const {
        return _PWrapPolygonVertices.isValid();
    }
    template <> DxWrapDistLeft OfficeArtFOPTEChoice::C_anon::get<DxWrapDistLeft>() const {
        return _DxWrapDistLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxWrapDistLeft>() const {
        return _DxWrapDistLeft.isValid();
    }
    template <> DyWrapDistTop OfficeArtFOPTEChoice::C_anon::get<DyWrapDistTop>() const {
        return _DyWrapDistTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyWrapDistTop>() const {
        return _DyWrapDistTop.isValid();
    }
    template <> DxWrapDistRight OfficeArtFOPTEChoice::C_anon::get<DxWrapDistRight>() const {
        return _DxWrapDistRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxWrapDistRight>() const {
        return _DxWrapDistRight.isValid();
    }
    template <> DyWrapDistBottom OfficeArtFOPTEChoice::C_anon::get<DyWrapDistBottom>() const {
        return _DyWrapDistBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyWrapDistBottom>() const {
        return _DyWrapDistBottom.isValid();
    }
    template <> LidRegroup OfficeArtFOPTEChoice::C_anon::get<LidRegroup>() const {
        return _LidRegroup;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LidRegroup>() const {
        return _LidRegroup.isValid();
    }
    template <> PosH OfficeArtFOPTEChoice::C_anon::get<PosH>() const {
        return _PosH;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosH>() const {
        return _PosH.isValid();
    }
    template <> PosRelH OfficeArtFOPTEChoice::C_anon::get<PosRelH>() const {
        return _PosRelH;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosRelH>() const {
        return _PosRelH.isValid();
    }
    template <> PosV OfficeArtFOPTEChoice::C_anon::get<PosV>() const {
        return _PosV;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosV>() const {
        return _PosV.isValid();
    }
    template <> PosRelV OfficeArtFOPTEChoice::C_anon::get<PosRelV>() const {
        return _PosRelV;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosRelV>() const {
        return _PosRelV.isValid();
    }
    template <> PctHR OfficeArtFOPTEChoice::C_anon::get<PctHR>() const {
        return _PctHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PctHR>() const {
        return _PctHR.isValid();
    }
    template <> AlignHR OfficeArtFOPTEChoice::C_anon::get<AlignHR>() const {
        return _AlignHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<AlignHR>() const {
        return _AlignHR.isValid();
    }
    template <> DxHeightHR OfficeArtFOPTEChoice::C_anon::get<DxHeightHR>() const {
        return _DxHeightHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxHeightHR>() const {
        return _DxHeightHR.isValid();
    }
    template <> DxWidthHR OfficeArtFOPTEChoice::C_anon::get<DxWidthHR>() const {
        return _DxWidthHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxWidthHR>() const {
        return _DxWidthHR.isValid();
    }
    template <> BorderTopColor OfficeArtFOPTEChoice::C_anon::get<BorderTopColor>() const {
        return _BorderTopColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BorderTopColor>() const {
        return _BorderTopColor.isValid();
    }
    template <> BorderLeftColor OfficeArtFOPTEChoice::C_anon::get<BorderLeftColor>() const {
        return _BorderLeftColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BorderLeftColor>() const {
        return _BorderLeftColor.isValid();
    }
    template <> BorderBottomColor OfficeArtFOPTEChoice::C_anon::get<BorderBottomColor>() const {
        return _BorderBottomColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BorderBottomColor>() const {
        return _BorderBottomColor.isValid();
    }
    template <> BorderRightColor OfficeArtFOPTEChoice::C_anon::get<BorderRightColor>() const {
        return _BorderRightColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BorderRightColor>() const {
        return _BorderRightColor.isValid();
    }
    template <> GroupShapeBooleanProperties OfficeArtFOPTEChoice::C_anon::get<GroupShapeBooleanProperties>() const {
        return _GroupShapeBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GroupShapeBooleanProperties>() const {
        return _GroupShapeBooleanProperties.isValid();
    }
    template <> WzFillId OfficeArtFOPTEChoice::C_anon::get<WzFillId>() const {
        return _WzFillId;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<WzFillId>() const {
        return _WzFillId.isValid();
    }
    template <> DiagramBooleanProperties OfficeArtFOPTEChoice::C_anon::get<DiagramBooleanProperties>() const {
        return _DiagramBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DiagramBooleanProperties>() const {
        return _DiagramBooleanProperties.isValid();
    }
    template <> OfficeArtFOPTE OfficeArtFOPTEChoice::C_anon::get<OfficeArtFOPTE>() const {
        return _OfficeArtFOPTE;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<OfficeArtFOPTE>() const {
        return _OfficeArtFOPTE.isValid();
    }
}
MSO::OfficeArtClientAnchor::OfficeArtClientAnchor(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._PptOfficeArtClientAnchor = PptOfficeArtClientAnchor(_d + _position, _maxsize - _position);
    _msize = m_anon._PptOfficeArtClientAnchor.getSize();
    if (_msize == 0) {
        m_anon._DocOfficeArtClientAnchor = DocOfficeArtClientAnchor(_d + _position);
        _msize = (m_anon._DocOfficeArtClientAnchor.isValid()) ?DocOfficeArtClientAnchor::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._XlsOfficeArtClientAnchor = XlsOfficeArtClientAnchor(_d + _position, _maxsize - _position);
        _msize = m_anon._XlsOfficeArtClientAnchor.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> PptOfficeArtClientAnchor OfficeArtClientAnchor::C_anon::get<PptOfficeArtClientAnchor>() const {
        return _PptOfficeArtClientAnchor;
    }
    template <> bool OfficeArtClientAnchor::C_anon::is<PptOfficeArtClientAnchor>() const {
        return _PptOfficeArtClientAnchor.isValid();
    }
    template <> DocOfficeArtClientAnchor OfficeArtClientAnchor::C_anon::get<DocOfficeArtClientAnchor>() const {
        return _DocOfficeArtClientAnchor;
    }
    template <> bool OfficeArtClientAnchor::C_anon::is<DocOfficeArtClientAnchor>() const {
        return _DocOfficeArtClientAnchor.isValid();
    }
    template <> XlsOfficeArtClientAnchor OfficeArtClientAnchor::C_anon::get<XlsOfficeArtClientAnchor>() const {
        return _XlsOfficeArtClientAnchor;
    }
    template <> bool OfficeArtClientAnchor::C_anon::is<XlsOfficeArtClientAnchor>() const {
        return _XlsOfficeArtClientAnchor.isValid();
    }
}
MSO::PptOfficeArtClientData::PptOfficeArtClientData(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0xF011)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_shapeFlagsAtom = ShapeFlagsAtom(_d + _position, _maxsize - _position);
        _msize = (m_shapeFlagsAtom.isPresent()) ?m_shapeFlagsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shapeFlags10Atom = ShapeFlags10Atom(_d + _position, _maxsize - _position);
        _msize = (m_shapeFlags10Atom.isPresent()) ?m_shapeFlags10Atom.getSize() :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        m_exObjRefAtom = ExObjRefAtom(_d + _position);
        _msize = (m_exObjRefAtom.isPresent()) ?m_exObjRefAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_animationInfo = AnimationInfoContainer(_d + _position, _maxsize - _position);
        _msize = (m_animationInfo.isPresent()) ?m_animationInfo.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_mouseClickInteractiveInfo = MouseClickInteractiveInfoContainer(_d + _position, _maxsize - _position);
        _msize = (m_mouseClickInteractiveInfo.isPresent()) ?m_mouseClickInteractiveInfo.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_mouseOverInteractiveInfo = MouseOverInteractiveInfoContainer(_d + _position, _maxsize - _position);
        _msize = (m_mouseOverInteractiveInfo.isPresent()) ?m_mouseOverInteractiveInfo.getSize() :0;
        _position += _msize;
    }
    m_rgShapeClientRoundtripData0 = MSOArray<ShapeClientRoundtripDataSubcontainerOrAtom>(_d + _position, _maxsize - _position);
    if (!m_rgShapeClientRoundtripData0.isValid()) return;
    _msize = m_rgShapeClientRoundtripData0.getSize();
    _position += _msize;
    if (_position + 16 <= _maxsize) {
        m_placeholderAtom = PlaceholderAtom(_d + _position);
        _msize = (m_placeholderAtom.isPresent()) ?m_placeholderAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_recolorInfoAtom = RecolorInfoAtom(_d + _position, _maxsize - _position);
        _msize = (m_recolorInfoAtom.isPresent()) ?m_recolorInfoAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_unknown1 = UnknownOfficeArtClientDataChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown1.isPresent()) ?m_unknown1.getSize() :0;
        _position += _msize;
    }
    m_rgShapeClientRoundtripData = MSOArray<ShapeClientRoundtripDataSubcontainerOrAtom>(_d + _position, _maxsize - _position);
    if (!m_rgShapeClientRoundtripData.isValid()) return;
    _msize = m_rgShapeClientRoundtripData.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_unknown2 = UnknownOfficeArtClientDataChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown2.isPresent()) ?m_unknown2.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::ShapeProgBinaryTagContainer::ShapeProgBinaryTagContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x138A)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_rec = ShapeProgBinaryTagSubContainerOrAtom(_d + _position, _maxsize - _position);
    if (!m_rec.isValid()) return;
    _msize = m_rec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::WordDocument::WordDocument(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_fib = Fib(_d + _position, _maxsize - _position);
    if (!m_fib.isValid()) return;
    _msize = m_fib.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::Table::Table(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 468 > _maxsize) return;
    m_stsh = STSH(_d + _position, _maxsize - _position);
    if (!m_stsh.isValid()) return;
    _msize = m_stsh.getSize();
    _position += _msize;
    if (_position + 20 > _maxsize) return;
    m_plcfSed = PlcfSed(_d + _position, _maxsize - _position);
    if (!m_plcfSed.isValid()) return;
    _msize = m_plcfSed.getSize();
    _position += _msize;
    if (_position + 52 > _maxsize) return;
    m_plcfHdd = Plcfhdd(_d + _position);
    if (!m_plcfHdd.isValid()) return;
    _msize = m_plcfHdd.getSize();
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_plcfBteChpx = PlcBteChpx(_d + _position);
    if (!m_plcfBteChpx.isValid()) return;
    _msize = m_plcfBteChpx.getSize();
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_plcfBtePapx = PlcfBtePapx(_d + _position);
    if (!m_plcfBtePapx.isValid()) return;
    _msize = m_plcfBtePapx.getSize();
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    m_cmds = Tcg(_d + _position);
    if (!m_cmds.isValid()) return;
    _msize = m_cmds.getSize();
    _position += _msize;
    if (_position + 21 > _maxsize) return;
    m_clx = Clx(_d + _position, _maxsize - _position);
    if (!m_clx.isValid()) return;
    _msize = m_clx.getSize();
    _position += _msize;
    if (_position + 246 > _maxsize) return;
    m_sttbfFfn = SttbfFfn(_d + _position, _maxsize - _position);
    if (!m_sttbfFfn.isValid()) return;
    _msize = m_sttbfFfn.getSize();
    _position += _msize;
    if (_position + 600 > _maxsize) return;
    m_dop = MSOCastArray<char>((const char*)(_d + _position), 600);
    _msize = (600)*1;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
const quint32 MSO::Pcd::_size = 8;
MSO::Pcd::Pcd(const char* _d, quint32/*ignored*/) {
    quint32 _position = 0;
    quint32 _msize;
    m_fNoParaLast = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fR1 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fDirtly = readbit_2(_d + _position);
    _msize = 0;
    if (!(((bool)m_fDirtly) == false)) {
         return;
    }
    _position += _msize;
    m_fR2 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    m_fR3 = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    m_fc = FCompressed(_d + _position);
    if (!m_fc.isValid()) return;
    _msize = m_fc.getSize();
    _position += _msize;
    m_prm = Prm(_d + _position);
    if (!m_prm.isValid()) return;
    _msize = m_prm.getSize();
    _position += _msize;
   FixedSizeParsedObject::init(_d);
}
MSO::OfficeArtFBSE::OfficeArtFBSE(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x2)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1 || rh().recInstance() == 2 || rh().recInstance() == 3 || rh().recInstance() == 4 || rh().recInstance() == 5 || rh().recInstance() == 6 || rh().recInstance() == 7 || rh().recInstance() == 0x11 || rh().recInstance() == 0x12)) {
         return;
    }
    if (!(rh().recType() == 0xF007)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_btWin32 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_btMacOS = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_rgbUid = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_tag = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_cRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    m_foDelay = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_unused1 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_cbName = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_unused3 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    bool _has_nameData = cbName()>0;
    if (_has_nameData) {
        m_nameData = MSOCastArray<char>((const char*)(_d + _position), cbName());
        _msize = (cbName())*1;
        _position += _msize;
    }
    if (rh().recLen() > 36 + cbName()) {
        if (_position + 0 > _maxsize) return;
        m_embeddedBlip = OfficeArtBlip(_d + _position, _maxsize - _position);
        if (!m_embeddedBlip.isPresent()) return;
        _msize = m_embeddedBlip.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtBStoreContainerFileBlock::OfficeArtBStoreContainerFileBlock(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._OfficeArtFBSE = OfficeArtFBSE(_d + _position, _maxsize - _position);
    _msize = m_anon._OfficeArtFBSE.getSize();
    if (_msize == 0) {
        m_anon._OfficeArtBlip = OfficeArtBlip(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtBlip.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> OfficeArtFBSE OfficeArtBStoreContainerFileBlock::C_anon::get<OfficeArtFBSE>() const {
        return _OfficeArtFBSE;
    }
    template <> bool OfficeArtBStoreContainerFileBlock::C_anon::is<OfficeArtFBSE>() const {
        return _OfficeArtFBSE.isValid();
    }
    template <> OfficeArtBlip OfficeArtBStoreContainerFileBlock::C_anon::get<OfficeArtBlip>() const {
        return _OfficeArtBlip;
    }
    template <> bool OfficeArtBStoreContainerFileBlock::C_anon::is<OfficeArtBlip>() const {
        return _OfficeArtBlip.isValid();
    }
}
MSO::SlideViewInfoInstance::SlideViewInfoInstance(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1)) {
         return;
    }
    if (!(rh().recType() == 0x3FA)) {
         return;
    }
    _position += _msize;
    if (_position + 11 > _maxsize) return;
    m_slideViewInfoAtom = SlideViewInfoAtom(_d + _position);
    if (!m_slideViewInfoAtom.isValid()) return;
    _msize = m_slideViewInfoAtom.getSize();
    _position += _msize;
    if (_position + 60 <= _maxsize) {
        m_zoomViewInfoAtom = ZoomViewInfoAtom(_d + _position);
        _msize = (m_zoomViewInfoAtom.isPresent()) ?m_zoomViewInfoAtom.getSize() :0;
        _position += _msize;
    }
    m_rgGuideAtom = MSOArray<GuideAtom>(_d + _position, _maxsize - _position);
    if (!m_rgGuideAtom.isValid()) return;
    _msize = m_rgGuideAtom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::DocProgBinaryTagSubContainerOrAtom::DocProgBinaryTagSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._PP9DocBinaryTagExtension = PP9DocBinaryTagExtension(_d + _position, _maxsize - _position);
    _msize = m_anon._PP9DocBinaryTagExtension.getSize();
    if (_msize == 0) {
        m_anon._PP10DocBinaryTagExtension = PP10DocBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP10DocBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._PP11DocBinaryTagExtension = PP11DocBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP11DocBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._PP12DocBinaryTagExtension = PP12DocBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP12DocBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._UnknownBinaryTag = UnknownBinaryTag(_d + _position, _maxsize - _position);
        _msize = m_anon._UnknownBinaryTag.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> PP9DocBinaryTagExtension DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP9DocBinaryTagExtension>() const {
        return _PP9DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP9DocBinaryTagExtension>() const {
        return _PP9DocBinaryTagExtension.isValid();
    }
    template <> PP10DocBinaryTagExtension DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP10DocBinaryTagExtension>() const {
        return _PP10DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP10DocBinaryTagExtension>() const {
        return _PP10DocBinaryTagExtension.isValid();
    }
    template <> PP11DocBinaryTagExtension DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP11DocBinaryTagExtension>() const {
        return _PP11DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP11DocBinaryTagExtension>() const {
        return _PP11DocBinaryTagExtension.isValid();
    }
    template <> PP12DocBinaryTagExtension DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP12DocBinaryTagExtension>() const {
        return _PP12DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP12DocBinaryTagExtension>() const {
        return _PP12DocBinaryTagExtension.isValid();
    }
    template <> UnknownBinaryTag DocProgBinaryTagSubContainerOrAtom::C_anon::get<UnknownBinaryTag>() const {
        return _UnknownBinaryTag;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<UnknownBinaryTag>() const {
        return _UnknownBinaryTag.isValid();
    }
}
MSO::TextMasterStyle9Atom::TextMasterStyle9Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1 || rh().recInstance() == 2 || rh().recInstance() == 3 || rh().recInstance() == 4 || rh().recInstance() == 5 || rh().recInstance() == 6 || rh().recInstance() == 7 || rh().recInstance() == 8)) {
         return;
    }
    if (!(rh().recType() == 0x0FAD)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cLevels = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cLevels)<=5)) {
         return;
    }
    _position += _msize;
    if (cLevels()>0) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl1 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl1.isPresent()) return;
        _msize = m_lstLvl1.getSize();
        _position += _msize;
    }
    if (cLevels()>1) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl2 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl2.isPresent()) return;
        _msize = m_lstLvl2.getSize();
        _position += _msize;
    }
    if (cLevels()>2) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl3 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl3.isPresent()) return;
        _msize = m_lstLvl3.getSize();
        _position += _msize;
    }
    if (cLevels()>3) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl4 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl4.isPresent()) return;
        _msize = m_lstLvl4.getSize();
        _position += _msize;
    }
    if (cLevels()>4) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl5 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl5.isPresent()) return;
        _msize = m_lstLvl5.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::BlipEntityAtom::BlipEntityAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0)) {
         return;
    }
    if (!(rh().recInstance()<=128)) {
         return;
    }
    if (!(rh().recType() == 0x07F9)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_winBlipType = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)m_winBlipType) == 0x02 || ((quint8)m_winBlipType) == 0x03 || ((quint8)m_winBlipType) == 0x05 || ((quint8)m_winBlipType) == 0x06)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    m_unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_blip = OfficeArtBStoreContainerFileBlock(_d + _position, _maxsize - _position);
    if (!m_blip.isValid()) return;
    _msize = m_blip.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::TextMasterStyle10Atom::TextMasterStyle10Atom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0x0)) {
         return;
    }
    if (!(rh().recInstance() == 0 || rh().recInstance() == 1 || rh().recInstance() == 2 || rh().recInstance() == 3 || rh().recInstance() == 4 || rh().recInstance() == 5 || rh().recInstance() == 6 || rh().recInstance() == 7 || rh().recInstance() == 8)) {
         return;
    }
    if (!(rh().recType() == 0x0FB2)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    m_cLevels = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)m_cLevels)<=5)) {
         return;
    }
    _position += _msize;
    bool _has_lstLvl1level = cLevels()>0 && rh().recInstance()>=5;
    if (_has_lstLvl1level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl1level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>0) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl1 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl1.isPresent()) return;
        _msize = m_lstLvl1.getSize();
        _position += _msize;
    }
    bool _has_lstLvl2level = cLevels()>1 && rh().recInstance()>=5;
    if (_has_lstLvl2level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl2level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>1) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl2 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl2.isPresent()) return;
        _msize = m_lstLvl2.getSize();
        _position += _msize;
    }
    bool _has_lstLvl3level = cLevels()>2 && rh().recInstance()>=5;
    if (_has_lstLvl3level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl3level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>2) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl3 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl3.isPresent()) return;
        _msize = m_lstLvl3.getSize();
        _position += _msize;
    }
    bool _has_lstLvl4level = cLevels()>3 && rh().recInstance()>=5;
    if (_has_lstLvl4level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl4level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>3) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl4 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl4.isPresent()) return;
        _msize = m_lstLvl4.getSize();
        _position += _msize;
    }
    bool _has_lstLvl5level = cLevels()>4 && rh().recInstance()>=5;
    if (_has_lstLvl5level) {
        if (_position + 2 > _maxsize) return;
        m_lstLvl5level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels()>4) {
        if (_position + 0 > _maxsize) return;
        m_lstLvl5 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (!m_lstLvl5.isPresent()) return;
        _msize = m_lstLvl5.getSize();
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::TextContainerInteractiveInfo::TextContainerInteractiveInfo(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_interactive._MouseClickTextInfo = MouseClickTextInfo(_d + _position, _maxsize - _position);
    _msize = m_interactive._MouseClickTextInfo.getSize();
    if (_msize == 0) {
        m_interactive._MouseOverTextInfo = MouseOverTextInfo(_d + _position, _maxsize - _position);
        _msize = m_interactive._MouseOverTextInfo.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> MouseClickTextInfo TextContainerInteractiveInfo::C_interactive::get<MouseClickTextInfo>() const {
        return _MouseClickTextInfo;
    }
    template <> bool TextContainerInteractiveInfo::C_interactive::is<MouseClickTextInfo>() const {
        return _MouseClickTextInfo.isValid();
    }
    template <> MouseOverTextInfo TextContainerInteractiveInfo::C_interactive::get<MouseOverTextInfo>() const {
        return _MouseOverTextInfo;
    }
    template <> bool TextContainerInteractiveInfo::C_interactive::is<MouseOverTextInfo>() const {
        return _MouseOverTextInfo.isValid();
    }
}
MSO::DocumentTextInfoContainer::DocumentTextInfoContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x03F2)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_kinsoku = KinsokuContainer(_d + _position, _maxsize - _position);
        _msize = (m_kinsoku.isPresent()) ?m_kinsoku.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_fontCollection = FontCollectionContainer(_d + _position, _maxsize - _position);
        _msize = (m_fontCollection.isPresent()) ?m_fontCollection.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_textCFDefaultsAtom = TextCFExceptionAtom(_d + _position, _maxsize - _position);
        _msize = (m_textCFDefaultsAtom.isPresent()) ?m_textCFDefaultsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_textPFDefaultsAtom = TextPFExceptionAtom(_d + _position, _maxsize - _position);
        _msize = (m_textPFDefaultsAtom.isPresent()) ?m_textPFDefaultsAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_defaultRulerAtom = DefaultRulerAtom(_d + _position, _maxsize - _position);
        _msize = (m_defaultRulerAtom.isPresent()) ?m_defaultRulerAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_textSIDefaultsAtom = TextSIExceptionAtom(_d + _position, _maxsize - _position);
    if (!m_textSIDefaultsAtom.isValid()) return;
    _msize = m_textSIDefaultsAtom.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_textMasterStyleAtom = TextMasterStyleAtom(_d + _position, _maxsize - _position);
    if (!m_textMasterStyleAtom.isValid()) return;
    _msize = m_textMasterStyleAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_textMasterStyleAtom2 = TextMasterStyleAtom(_d + _position, _maxsize - _position);
        _msize = (m_textMasterStyleAtom2.isPresent()) ?m_textMasterStyleAtom2.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::SlideProgBinaryTagSubContainerOrAtom::SlideProgBinaryTagSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._PP9SlideBinaryTagExtension = PP9SlideBinaryTagExtension(_d + _position, _maxsize - _position);
    _msize = m_anon._PP9SlideBinaryTagExtension.getSize();
    if (_msize == 0) {
        m_anon._PP12SlideBinaryTagExtension = PP12SlideBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP12SlideBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._PP10SlideBinaryTagExtension = PP10SlideBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = m_anon._PP10SlideBinaryTagExtension.getSize();
    }
    if (_msize == 0) {
        m_anon._UnknownBinaryTag = UnknownBinaryTag(_d + _position, _maxsize - _position);
        _msize = m_anon._UnknownBinaryTag.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> PP9SlideBinaryTagExtension SlideProgBinaryTagSubContainerOrAtom::C_anon::get<PP9SlideBinaryTagExtension>() const {
        return _PP9SlideBinaryTagExtension;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<PP9SlideBinaryTagExtension>() const {
        return _PP9SlideBinaryTagExtension.isValid();
    }
    template <> PP12SlideBinaryTagExtension SlideProgBinaryTagSubContainerOrAtom::C_anon::get<PP12SlideBinaryTagExtension>() const {
        return _PP12SlideBinaryTagExtension;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<PP12SlideBinaryTagExtension>() const {
        return _PP12SlideBinaryTagExtension.isValid();
    }
    template <> PP10SlideBinaryTagExtension SlideProgBinaryTagSubContainerOrAtom::C_anon::get<PP10SlideBinaryTagExtension>() const {
        return _PP10SlideBinaryTagExtension;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<PP10SlideBinaryTagExtension>() const {
        return _PP10SlideBinaryTagExtension.isValid();
    }
    template <> UnknownBinaryTag SlideProgBinaryTagSubContainerOrAtom::C_anon::get<UnknownBinaryTag>() const {
        return _UnknownBinaryTag;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<UnknownBinaryTag>() const {
        return _UnknownBinaryTag.isValid();
    }
}
MSO::DrawingGroupContainer::DrawingGroupContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x040B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_OfficeArtDgg = OfficeArtDggContainer(_d + _position, _maxsize - _position);
    if (!m_OfficeArtDgg.isValid()) return;
    _msize = m_OfficeArtDgg.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtClientData::OfficeArtClientData(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._DocOfficeArtClientData = DocOfficeArtClientData(_d + _position);
    _msize = (m_anon._DocOfficeArtClientData.isValid()) ?DocOfficeArtClientData::getSize() : 0;
    if (_msize == 0) {
        m_anon._PptOfficeArtClientData = PptOfficeArtClientData(_d + _position, _maxsize - _position);
        _msize = m_anon._PptOfficeArtClientData.getSize();
    }
    if (_msize == 0) {
        m_anon._XlsOfficeArtClientData = XlsOfficeArtClientData(_d + _position);
        _msize = (m_anon._XlsOfficeArtClientData.isValid()) ?XlsOfficeArtClientData::getSize() : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> DocOfficeArtClientData OfficeArtClientData::C_anon::get<DocOfficeArtClientData>() const {
        return _DocOfficeArtClientData;
    }
    template <> bool OfficeArtClientData::C_anon::is<DocOfficeArtClientData>() const {
        return _DocOfficeArtClientData.isValid();
    }
    template <> PptOfficeArtClientData OfficeArtClientData::C_anon::get<PptOfficeArtClientData>() const {
        return _PptOfficeArtClientData;
    }
    template <> bool OfficeArtClientData::C_anon::is<PptOfficeArtClientData>() const {
        return _PptOfficeArtClientData.isValid();
    }
    template <> XlsOfficeArtClientData OfficeArtClientData::C_anon::get<XlsOfficeArtClientData>() const {
        return _XlsOfficeArtClientData;
    }
    template <> bool OfficeArtClientData::C_anon::is<XlsOfficeArtClientData>() const {
        return _XlsOfficeArtClientData.isValid();
    }
}
MSO::ShapeProgTagsSubContainerOrAtom::ShapeProgTagsSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._ProgStringTagContainer = ProgStringTagContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._ProgStringTagContainer.getSize();
    if (_msize == 0) {
        m_anon._ShapeProgBinaryTagContainer = ShapeProgBinaryTagContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._ShapeProgBinaryTagContainer.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> ProgStringTagContainer ShapeProgTagsSubContainerOrAtom::C_anon::get<ProgStringTagContainer>() const {
        return _ProgStringTagContainer;
    }
    template <> bool ShapeProgTagsSubContainerOrAtom::C_anon::is<ProgStringTagContainer>() const {
        return _ProgStringTagContainer.isValid();
    }
    template <> ShapeProgBinaryTagContainer ShapeProgTagsSubContainerOrAtom::C_anon::get<ShapeProgBinaryTagContainer>() const {
        return _ShapeProgBinaryTagContainer;
    }
    template <> bool ShapeProgTagsSubContainerOrAtom::C_anon::is<ShapeProgBinaryTagContainer>() const {
        return _ShapeProgBinaryTagContainer.isValid();
    }
}
MSO::DocumentContainer::DocumentContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x03E8)) {
         return;
    }
    _position += _msize;
    if (_position + 48 > _maxsize) return;
    m_documentAtom = DocumentAtom(_d + _position);
    if (!m_documentAtom.isValid()) return;
    _msize = m_documentAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_exObjList = ExObjListContainer(_d + _position, _maxsize - _position);
        _msize = (m_exObjList.isPresent()) ?m_exObjList.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_documentTextInfo = DocumentTextInfoContainer(_d + _position, _maxsize - _position);
    if (!m_documentTextInfo.isValid()) return;
    _msize = m_documentTextInfo.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_soundCollection = SoundCollectionContainer(_d + _position, _maxsize - _position);
        _msize = (m_soundCollection.isPresent()) ?m_soundCollection.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_drawingGroup = DrawingGroupContainer(_d + _position, _maxsize - _position);
    if (!m_drawingGroup.isValid()) return;
    _msize = m_drawingGroup.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_masterList = MasterListWithTextContainer(_d + _position, _maxsize - _position);
    if (!m_masterList.isValid()) return;
    _msize = m_masterList.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_docInfoList = DocInfoListContainer(_d + _position, _maxsize - _position);
        _msize = (m_docInfoList.isPresent()) ?m_docInfoList.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideHF = SlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_slideHF.isPresent()) ?m_slideHF.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_notesHF = NotesHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_notesHF.isPresent()) ?m_notesHF.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideList = SlideListWithTextContainer(_d + _position, _maxsize - _position);
        _msize = (m_slideList.isPresent()) ?m_slideList.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideHF2 = SlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_slideHF2.isPresent()) ?m_slideHF2.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_notesList = NotesListWithTextContainer(_d + _position, _maxsize - _position);
        _msize = (m_notesList.isPresent()) ?m_notesList.getSize() :0;
        _position += _msize;
    }
    if (_position + 88 <= _maxsize) {
        m_slideShowDocInfoAtom = SlideShowDocInfoAtom(_d + _position);
        _msize = (m_slideShowDocInfoAtom.isPresent()) ?m_slideShowDocInfoAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_namedShows = NamedShowsContainer(_d + _position, _maxsize - _position);
        _msize = (m_namedShows.isPresent()) ?m_namedShows.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_summary = SummaryContainer(_d + _position, _maxsize - _position);
        _msize = (m_summary.isPresent()) ?m_summary.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_docRoutingSlipAtom = DocRoutingSlipAtom(_d + _position, _maxsize - _position);
        _msize = (m_docRoutingSlipAtom.isPresent()) ?m_docRoutingSlipAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_printOptionsAtom = PrintOptionsAtom(_d + _position, _maxsize - _position);
        _msize = (m_printOptionsAtom.isPresent()) ?m_printOptionsAtom.getSize() :0;
        _position += _msize;
    }
    m_unknown0 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (!m_unknown0.isValid()) return;
    _msize = m_unknown0.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_rtCustomTableStylesAtom1 = RoundTripCustomTableStyles12Atom(_d + _position, _maxsize - _position);
        _msize = (m_rtCustomTableStylesAtom1.isPresent()) ?m_rtCustomTableStylesAtom1.getSize() :0;
        _position += _msize;
    }
    m_unknown1 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (!m_unknown1.isValid()) return;
    _msize = m_unknown1.getSize();
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    m_endDocumentAtom = EndDocumentAtom(_d + _position);
    if (!m_endDocumentAtom.isValid()) return;
    _msize = m_endDocumentAtom.getSize();
    _position += _msize;
    m_unknown2 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (!m_unknown2.isValid()) return;
    _msize = m_unknown2.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_rtCustomTableStylesAtom2 = RoundTripCustomTableStyles12Atom(_d + _position, _maxsize - _position);
        _msize = (m_rtCustomTableStylesAtom2.isPresent()) ?m_rtCustomTableStylesAtom2.getSize() :0;
        _position += _msize;
    }
    m_unknown4 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (!m_unknown4.isValid()) return;
    _msize = m_unknown4.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_unknown5 = TextMasterStyle10Atom(_d + _position, _maxsize - _position);
        _msize = (m_unknown5.isPresent()) ?m_unknown5.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::DocInfoListSubContainerOrAtom::DocInfoListSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._DocProgTagsContainer = DocProgTagsContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._DocProgTagsContainer.getSize();
    if (_msize == 0) {
        m_anon._NormalViewSetInfoContainer = NormalViewSetInfoContainer(_d + _position);
        _msize = (m_anon._NormalViewSetInfoContainer.isValid()) ?NormalViewSetInfoContainer::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._NotesTextViewInfoContainer = NotesTextViewInfoContainer(_d + _position);
        _msize = (m_anon._NotesTextViewInfoContainer.isValid()) ?NotesTextViewInfoContainer::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._OutlineViewInfoContainer = OutlineViewInfoContainer(_d + _position);
        _msize = (m_anon._OutlineViewInfoContainer.isValid()) ?OutlineViewInfoContainer::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._SlideViewInfoInstance = SlideViewInfoInstance(_d + _position, _maxsize - _position);
        _msize = m_anon._SlideViewInfoInstance.getSize();
    }
    if (_msize == 0) {
        m_anon._SorterViewInfoContainer = SorterViewInfoContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._SorterViewInfoContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._VBAInfoContainer = VBAInfoContainer(_d + _position);
        _msize = (m_anon._VBAInfoContainer.isValid()) ?VBAInfoContainer::getSize() : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> DocProgTagsContainer DocInfoListSubContainerOrAtom::C_anon::get<DocProgTagsContainer>() const {
        return _DocProgTagsContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<DocProgTagsContainer>() const {
        return _DocProgTagsContainer.isValid();
    }
    template <> NormalViewSetInfoContainer DocInfoListSubContainerOrAtom::C_anon::get<NormalViewSetInfoContainer>() const {
        return _NormalViewSetInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<NormalViewSetInfoContainer>() const {
        return _NormalViewSetInfoContainer.isValid();
    }
    template <> NotesTextViewInfoContainer DocInfoListSubContainerOrAtom::C_anon::get<NotesTextViewInfoContainer>() const {
        return _NotesTextViewInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<NotesTextViewInfoContainer>() const {
        return _NotesTextViewInfoContainer.isValid();
    }
    template <> OutlineViewInfoContainer DocInfoListSubContainerOrAtom::C_anon::get<OutlineViewInfoContainer>() const {
        return _OutlineViewInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<OutlineViewInfoContainer>() const {
        return _OutlineViewInfoContainer.isValid();
    }
    template <> SlideViewInfoInstance DocInfoListSubContainerOrAtom::C_anon::get<SlideViewInfoInstance>() const {
        return _SlideViewInfoInstance;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<SlideViewInfoInstance>() const {
        return _SlideViewInfoInstance.isValid();
    }
    template <> SorterViewInfoContainer DocInfoListSubContainerOrAtom::C_anon::get<SorterViewInfoContainer>() const {
        return _SorterViewInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<SorterViewInfoContainer>() const {
        return _SorterViewInfoContainer.isValid();
    }
    template <> VBAInfoContainer DocInfoListSubContainerOrAtom::C_anon::get<VBAInfoContainer>() const {
        return _VBAInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<VBAInfoContainer>() const {
        return _VBAInfoContainer.isValid();
    }
}
MSO::DocProgBinaryTagContainer::DocProgBinaryTagContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x138A)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_rec = DocProgBinaryTagSubContainerOrAtom(_d + _position, _maxsize - _position);
    if (!m_rec.isValid()) return;
    _msize = m_rec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::SlideProgBinaryTagContainer::SlideProgBinaryTagContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x138A)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_rec = SlideProgBinaryTagSubContainerOrAtom(_d + _position, _maxsize - _position);
    if (!m_rec.isValid()) return;
    _msize = m_rec.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtSpContainer::OfficeArtSpContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x0F004)) {
         return;
    }
    _position += _msize;
    if (_position + 24 <= _maxsize) {
        m_shapeGroup = OfficeArtFSPGR(_d + _position);
        _msize = (m_shapeGroup.isPresent()) ?m_shapeGroup.getSize() :0;
        _position += _msize;
    }
    if (_position + 16 > _maxsize) return;
    m_shapeProp = OfficeArtFSP(_d + _position);
    if (!m_shapeProp.isValid()) return;
    _msize = m_shapeProp.getSize();
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        m_deletedshape = OfficeArtFPSPL(_d + _position);
        _msize = (m_deletedshape.isPresent()) ?m_deletedshape.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shapePrimaryOptions = OfficeArtFOPT(_d + _position, _maxsize - _position);
        _msize = (m_shapePrimaryOptions.isPresent()) ?m_shapePrimaryOptions.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shapeSecondaryOptions1 = OfficeArtSecondaryFOPT(_d + _position, _maxsize - _position);
        _msize = (m_shapeSecondaryOptions1.isPresent()) ?m_shapeSecondaryOptions1.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shapeTertiaryOptions1 = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (m_shapeTertiaryOptions1.isPresent()) ?m_shapeTertiaryOptions1.getSize() :0;
        _position += _msize;
    }
    if (_position + 24 <= _maxsize) {
        m_childAnchor = OfficeArtChildAnchor(_d + _position);
        _msize = (m_childAnchor.isPresent()) ?m_childAnchor.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_clientAnchor = OfficeArtClientAnchor(_d + _position, _maxsize - _position);
        _msize = (m_clientAnchor.isPresent()) ?m_clientAnchor.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_clientData = OfficeArtClientData(_d + _position, _maxsize - _position);
        _msize = (m_clientData.isPresent()) ?m_clientData.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_clientTextbox = OfficeArtClientTextBox(_d + _position, _maxsize - _position);
        _msize = (m_clientTextbox.isPresent()) ?m_clientTextbox.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shapeSecondaryOptions2 = OfficeArtSecondaryFOPT(_d + _position, _maxsize - _position);
        _msize = (m_shapeSecondaryOptions2.isPresent()) ?m_shapeSecondaryOptions2.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shapeTertiaryOptions2 = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (m_shapeTertiaryOptions2.isPresent()) ?m_shapeTertiaryOptions2.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_unknown = UnknownTextContainerChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown.isPresent()) ?m_unknown.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtInlineSpContainer::OfficeArtInlineSpContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_shape = OfficeArtSpContainer(_d + _position, _maxsize - _position);
    if (!m_shape.isValid()) return;
    _msize = m_shape.getSize();
    _position += _msize;
    m_rgfb = MSOArray<OfficeArtBStoreContainerFileBlock>(_d + _position, _maxsize - _position);
    if (!m_rgfb.isValid()) return;
    _msize = m_rgfb.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::DocProgTagsSubContainerOrAtom::DocProgTagsSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._ProgStringTagContainer = ProgStringTagContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._ProgStringTagContainer.getSize();
    if (_msize == 0) {
        m_anon._DocProgBinaryTagContainer = DocProgBinaryTagContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._DocProgBinaryTagContainer.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> ProgStringTagContainer DocProgTagsSubContainerOrAtom::C_anon::get<ProgStringTagContainer>() const {
        return _ProgStringTagContainer;
    }
    template <> bool DocProgTagsSubContainerOrAtom::C_anon::is<ProgStringTagContainer>() const {
        return _ProgStringTagContainer.isValid();
    }
    template <> DocProgBinaryTagContainer DocProgTagsSubContainerOrAtom::C_anon::get<DocProgBinaryTagContainer>() const {
        return _DocProgBinaryTagContainer;
    }
    template <> bool DocProgTagsSubContainerOrAtom::C_anon::is<DocProgBinaryTagContainer>() const {
        return _DocProgBinaryTagContainer.isValid();
    }
}
MSO::SlideProgTagsSubContainerOrAtom::SlideProgTagsSubContainerOrAtom(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._ProgStringTagContainer = ProgStringTagContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._ProgStringTagContainer.getSize();
    if (_msize == 0) {
        m_anon._SlideProgBinaryTagContainer = SlideProgBinaryTagContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._SlideProgBinaryTagContainer.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> ProgStringTagContainer SlideProgTagsSubContainerOrAtom::C_anon::get<ProgStringTagContainer>() const {
        return _ProgStringTagContainer;
    }
    template <> bool SlideProgTagsSubContainerOrAtom::C_anon::is<ProgStringTagContainer>() const {
        return _ProgStringTagContainer.isValid();
    }
    template <> SlideProgBinaryTagContainer SlideProgTagsSubContainerOrAtom::C_anon::get<SlideProgBinaryTagContainer>() const {
        return _SlideProgBinaryTagContainer;
    }
    template <> bool SlideProgTagsSubContainerOrAtom::C_anon::is<SlideProgBinaryTagContainer>() const {
        return _SlideProgBinaryTagContainer.isValid();
    }
}
MSO::OfficeArtDgContainer::OfficeArtDgContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = OfficeArtRecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0xF002)) {
         return;
    }
    _position += _msize;
    if (_position + 16 <= _maxsize) {
        m_drawingData = OfficeArtFDG(_d + _position);
        _msize = (m_drawingData.isPresent()) ?m_drawingData.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_regroupItems = OfficeArtFRITContainer(_d + _position, _maxsize - _position);
        _msize = (m_regroupItems.isPresent()) ?m_regroupItems.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_groupShape = OfficeArtSpgrContainer(_d + _position, _maxsize - _position);
        _msize = (m_groupShape.isPresent()) ?m_groupShape.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_shape = OfficeArtSpContainer(_d + _position, _maxsize - _position);
        _msize = (m_shape.isPresent()) ?m_shape.getSize() :0;
        _position += _msize;
    }
    m_deletedShapes = MSOArray<OfficeArtSpgrContainerFileBlock>(_d + _position, _maxsize - _position);
    if (!m_deletedShapes.isValid()) return;
    _msize = m_deletedShapes.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_solvers = OfficeArtSolverContainer(_d + _position, _maxsize - _position);
        _msize = (m_solvers.isPresent()) ?m_solvers.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::OfficeArtSpgrContainerFileBlock::OfficeArtSpgrContainerFileBlock(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._OfficeArtSpContainer = OfficeArtSpContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._OfficeArtSpContainer.getSize();
    if (_msize == 0) {
        m_anon._OfficeArtSpgrContainer = OfficeArtSpgrContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtSpgrContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtFSP = OfficeArtFSP(_d + _position);
        _msize = (m_anon._OfficeArtFSP.isValid()) ?OfficeArtFSP::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._OfficeArtFSPGR = OfficeArtFSPGR(_d + _position);
        _msize = (m_anon._OfficeArtFSPGR.isValid()) ?OfficeArtFSPGR::getSize() : 0;
    }
    if (_msize == 0) {
        m_anon._OfficeArtClientAnchor = OfficeArtClientAnchor(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtClientAnchor.getSize();
    }
    if (_msize == 0) {
        m_anon._OfficeArtClientData = OfficeArtClientData(_d + _position, _maxsize - _position);
        _msize = m_anon._OfficeArtClientData.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> OfficeArtSpContainer OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtSpContainer>() const {
        return _OfficeArtSpContainer;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtSpContainer>() const {
        return _OfficeArtSpContainer.isValid();
    }
    template <> OfficeArtSpgrContainer OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtSpgrContainer>() const {
        return _OfficeArtSpgrContainer;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtSpgrContainer>() const {
        return _OfficeArtSpgrContainer.isValid();
    }
    template <> OfficeArtFSP OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtFSP>() const {
        return _OfficeArtFSP;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtFSP>() const {
        return _OfficeArtFSP.isValid();
    }
    template <> OfficeArtFSPGR OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtFSPGR>() const {
        return _OfficeArtFSPGR;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtFSPGR>() const {
        return _OfficeArtFSPGR.isValid();
    }
    template <> OfficeArtClientAnchor OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtClientAnchor>() const {
        return _OfficeArtClientAnchor;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtClientAnchor>() const {
        return _OfficeArtClientAnchor.isValid();
    }
    template <> OfficeArtClientData OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtClientData>() const {
        return _OfficeArtClientData;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtClientData>() const {
        return _OfficeArtClientData.isValid();
    }
}
MSO::DrawingContainer::DrawingContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x040C)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_OfficeArtDg = OfficeArtDgContainer(_d + _position, _maxsize - _position);
    if (!m_OfficeArtDg.isValid()) return;
    _msize = m_OfficeArtDg.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::MainMasterContainer::MainMasterContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x03F8)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_slideAtom = SlideAtom(_d + _position);
    if (!m_slideAtom.isValid()) return;
    _msize = m_slideAtom.getSize();
    _position += _msize;
    if (_position + 24 <= _maxsize) {
        m_unknown = SlideShowSlideInfoAtom(_d + _position);
        _msize = (m_unknown.isPresent()) ?m_unknown.getSize() :0;
        _position += _msize;
    }
    m_rgSchemeListElementColorScheme = MSOArray<SchemeListElementColorSchemeAtom>(_d + _position, _maxsize - _position);
    if (!m_rgSchemeListElementColorScheme.isValid()) return;
    _msize = m_rgSchemeListElementColorScheme.getSize();
    _position += _msize;
    m_rgTextMasterStyle = MSOArray<TextMasterStyleAtom>(_d + _position, _maxsize - _position);
    if (!m_rgTextMasterStyle.isValid()) return;
    _msize = m_rgTextMasterStyle.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_roundTripOArtTextSTyles12Atom = RoundTripOArtTextStyles12Atom(_d + _position, _maxsize - _position);
        _msize = (m_roundTripOArtTextSTyles12Atom.isPresent()) ?m_roundTripOArtTextSTyles12Atom.getSize() :0;
        _position += _msize;
    }
    if (_position + 24 <= _maxsize) {
        m_slideShowInfoAtom = SlideShowSlideInfoAtom(_d + _position);
        _msize = (m_slideShowInfoAtom.isPresent()) ?m_slideShowInfoAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_perSlideHeadersFootersContainer = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_perSlideHeadersFootersContainer.isPresent()) ?m_perSlideHeadersFootersContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_drawing = DrawingContainer(_d + _position, _maxsize - _position);
    if (!m_drawing.isValid()) return;
    _msize = m_drawing.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_slideSchemeColorSchemeAtom = SlideSchemeColorSchemeAtom(_d + _position, _maxsize - _position);
    if (!m_slideSchemeColorSchemeAtom.isValid()) return;
    _msize = m_slideSchemeColorSchemeAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_slideNameAtom = SlideNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_slideNameAtom.isPresent()) ?m_slideNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideProgTagsContainer = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (m_slideProgTagsContainer.isPresent()) ?m_slideProgTagsContainer.getSize() :0;
        _position += _msize;
    }
    m_rgRoundTripMainMaster = MSOArray<RoundTripMainMasterRecord>(_d + _position, _maxsize - _position);
    if (!m_rgRoundTripMainMaster.isValid()) return;
    _msize = m_rgRoundTripMainMaster.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_templateNameAtom = TemplateNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_templateNameAtom.isPresent()) ?m_templateNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_unknown3 = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (m_unknown3.isPresent()) ?m_unknown3.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::SlideContainer::SlideContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0x0)) {
         return;
    }
    if (!(rh().recType() == 0x03EE)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    m_slideAtom = SlideAtom(_d + _position);
    if (!m_slideAtom.isValid()) return;
    _msize = m_slideAtom.getSize();
    _position += _msize;
    if (_position + 24 <= _maxsize) {
        m_slideShowSlideInfoAtom = SlideShowSlideInfoAtom(_d + _position);
        _msize = (m_slideShowSlideInfoAtom.isPresent()) ?m_slideShowSlideInfoAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_perSlideHFContainer = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_perSlideHFContainer.isPresent()) ?m_perSlideHFContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_rtSlideSyncInfo12 = RoundTripSlideSyncInfo12Container(_d + _position, _maxsize - _position);
        _msize = (m_rtSlideSyncInfo12.isPresent()) ?m_rtSlideSyncInfo12.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_drawing = DrawingContainer(_d + _position, _maxsize - _position);
    if (!m_drawing.isValid()) return;
    _msize = m_drawing.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_slideSchemeColorSchemeAtom = SlideSchemeColorSchemeAtom(_d + _position, _maxsize - _position);
    if (!m_slideSchemeColorSchemeAtom.isValid()) return;
    _msize = m_slideSchemeColorSchemeAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_slideNameAtom = SlideNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_slideNameAtom.isPresent()) ?m_slideNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideProgTagsContainer = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (m_slideProgTagsContainer.isPresent()) ?m_slideProgTagsContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_unknown = UnknownSlideContainerChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown.isPresent()) ?m_unknown.getSize() :0;
        _position += _msize;
    }
    m_rgRoundTripSlide = MSOArray<RoundTripSlideRecord>(_d + _position, _maxsize - _position);
    if (!m_rgRoundTripSlide.isValid()) return;
    _msize = m_rgRoundTripSlide.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_unknown2 = UnknownSlideContainerChild(_d + _position, _maxsize - _position);
        _msize = (m_unknown2.isPresent()) ?m_unknown2.getSize() :0;
        _position += _msize;
    }
   ParsedObject::init(_d, _position);
}
MSO::NotesContainer::NotesContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    m_rh = RecordHeader(_d + _position);
    if (!m_rh.isValid()) return;
    _msize = m_rh.getSize();
    if (!(rh().recVer() == 0xF)) {
         return;
    }
    if (!(rh().recInstance() == 0)) {
         return;
    }
    if (!(rh().recType() == 0x03F0)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    m_notesAtom = NotesAtom(_d + _position);
    if (!m_notesAtom.isValid()) return;
    _msize = m_notesAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_perSlideHFContainer = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_perSlideHFContainer.isPresent()) ?m_perSlideHFContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    m_drawing = DrawingContainer(_d + _position, _maxsize - _position);
    if (!m_drawing.isValid()) return;
    _msize = m_drawing.getSize();
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    m_slideSchemeColorSchemeAtom = SlideSchemeColorSchemeAtom(_d + _position, _maxsize - _position);
    if (!m_slideSchemeColorSchemeAtom.isValid()) return;
    _msize = m_slideSchemeColorSchemeAtom.getSize();
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        m_slideNameAtom = SlideNameAtom(_d + _position, _maxsize - _position);
        _msize = (m_slideNameAtom.isPresent()) ?m_slideNameAtom.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_slideProgTagsContainer = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (m_slideProgTagsContainer.isPresent()) ?m_slideProgTagsContainer.getSize() :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        m_perSlideHFContainer2 = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (m_perSlideHFContainer2.isPresent()) ?m_perSlideHFContainer2.getSize() :0;
        _position += _msize;
    }
    m_rgNotesRoundTripAtom = MSOArray<NotesRoundTripAtom>(_d + _position, _maxsize - _position);
    if (!m_rgNotesRoundTripAtom.isValid()) return;
    _msize = m_rgNotesRoundTripAtom.getSize();
    _position += _msize;
   ParsedObject::init(_d, _position);
}
MSO::MasterOrSlideContainer::MasterOrSlideContainer(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._MainMasterContainer = MainMasterContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._MainMasterContainer.getSize();
    if (_msize == 0) {
        m_anon._SlideContainer = SlideContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._SlideContainer.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> MainMasterContainer MasterOrSlideContainer::C_anon::get<MainMasterContainer>() const {
        return _MainMasterContainer;
    }
    template <> bool MasterOrSlideContainer::C_anon::is<MainMasterContainer>() const {
        return _MainMasterContainer.isValid();
    }
    template <> SlideContainer MasterOrSlideContainer::C_anon::get<SlideContainer>() const {
        return _SlideContainer;
    }
    template <> bool MasterOrSlideContainer::C_anon::is<SlideContainer>() const {
        return _SlideContainer.isValid();
    }
}
MSO::PowerPointStruct::PowerPointStruct(const char* _d, quint32 _maxsize) {
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    m_anon._DocumentContainer = DocumentContainer(_d + _position, _maxsize - _position);
    _msize = m_anon._DocumentContainer.getSize();
    if (_msize == 0) {
        m_anon._MasterOrSlideContainer = MasterOrSlideContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._MasterOrSlideContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._PersistDirectoryAtom = PersistDirectoryAtom(_d + _position, _maxsize - _position);
        _msize = m_anon._PersistDirectoryAtom.getSize();
    }
    if (_msize == 0) {
        m_anon._NotesContainer = NotesContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._NotesContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._HandoutContainer = HandoutContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._HandoutContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._SlideContainer = SlideContainer(_d + _position, _maxsize - _position);
        _msize = m_anon._SlideContainer.getSize();
    }
    if (_msize == 0) {
        m_anon._ExOleObjStg = ExOleObjStg(_d + _position, _maxsize - _position);
        _msize = m_anon._ExOleObjStg.getSize();
    }
    if (_msize == 0) {
        m_anon._ExControlStg = ExControlStg(_d + _position, _maxsize - _position);
        _msize = m_anon._ExControlStg.getSize();
    }
    if (_msize == 0) {
        m_anon._VbaProjectStg = VbaProjectStg(_d + _position, _maxsize - _position);
        _msize = m_anon._VbaProjectStg.getSize();
    }
    if (_msize == 0) {
        m_anon._UserEditAtom = UserEditAtom(_d + _position, _maxsize - _position);
        _msize = m_anon._UserEditAtom.getSize();
    }
    if (_msize == 0) return;
    _position += _msize;
   ParsedObject::init(_d, _position);
}
namespace MSO {
    template <> DocumentContainer PowerPointStruct::C_anon::get<DocumentContainer>() const {
        return _DocumentContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<DocumentContainer>() const {
        return _DocumentContainer.isValid();
    }
    template <> MasterOrSlideContainer PowerPointStruct::C_anon::get<MasterOrSlideContainer>() const {
        return _MasterOrSlideContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<MasterOrSlideContainer>() const {
        return _MasterOrSlideContainer.isValid();
    }
    template <> PersistDirectoryAtom PowerPointStruct::C_anon::get<PersistDirectoryAtom>() const {
        return _PersistDirectoryAtom;
    }
    template <> bool PowerPointStruct::C_anon::is<PersistDirectoryAtom>() const {
        return _PersistDirectoryAtom.isValid();
    }
    template <> NotesContainer PowerPointStruct::C_anon::get<NotesContainer>() const {
        return _NotesContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<NotesContainer>() const {
        return _NotesContainer.isValid();
    }
    template <> HandoutContainer PowerPointStruct::C_anon::get<HandoutContainer>() const {
        return _HandoutContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<HandoutContainer>() const {
        return _HandoutContainer.isValid();
    }
    template <> SlideContainer PowerPointStruct::C_anon::get<SlideContainer>() const {
        return _SlideContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<SlideContainer>() const {
        return _SlideContainer.isValid();
    }
    template <> ExOleObjStg PowerPointStruct::C_anon::get<ExOleObjStg>() const {
        return _ExOleObjStg;
    }
    template <> bool PowerPointStruct::C_anon::is<ExOleObjStg>() const {
        return _ExOleObjStg.isValid();
    }
    template <> ExControlStg PowerPointStruct::C_anon::get<ExControlStg>() const {
        return _ExControlStg;
    }
    template <> bool PowerPointStruct::C_anon::is<ExControlStg>() const {
        return _ExControlStg.isValid();
    }
    template <> VbaProjectStg PowerPointStruct::C_anon::get<VbaProjectStg>() const {
        return _VbaProjectStg;
    }
    template <> bool PowerPointStruct::C_anon::is<VbaProjectStg>() const {
        return _VbaProjectStg.isValid();
    }
    template <> UserEditAtom PowerPointStruct::C_anon::get<UserEditAtom>() const {
        return _UserEditAtom;
    }
    template <> bool PowerPointStruct::C_anon::is<UserEditAtom>() const {
        return _UserEditAtom.isValid();
    }
}
