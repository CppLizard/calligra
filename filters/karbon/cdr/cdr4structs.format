<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE format>
<format version="1.0">
  <includes>
    <file name="QtCore/QtGlobal">
      <type name="qint16" size="2" />
      <type name="quint16" />
      <type name="qint32" />
      <type name="quint32" />
    </file>
    <file name="QtCore/QPoint">
      <type name="QPoint" />
    </file>
    <file name="QtGui/QColor">
      <type name="QColor" />
    </file>
  </includes>

  <typedefs>
    <type name="Cdr4Coord" original="qint16">
      <description>2-byte signed integer is used to describe the x and the y coordinates.</description>
    </type>
  </typedefs>

  <enums>
    <enum name="CdrObjectIds">
      <description>id for the type of the graphical object.</description>
      <item name="CdrLayerObjectId" value="0">
        <description>"Ebene1"</description>
      </item>
      <item name="CdrRectangleObjectId" value="1">
        <description>Rectangle</description>
      </item>
      <item name="CdrEllipseObjectId" value="2">
        <description>Ellipse</description>
      </item>
      <item name="CdrPathObjectId" value="3">
        <description>Path</description>
      </item>
      <item name="CdrTextObjectId" value="4">
        <description>Text</description>
      </item>
      <item name="CdrBitmapObjectId" value="5">
        <description>Bitmap</description>
      </item>
      <item name="CdrUnknown1ObjectId" value="6">
      </item>
      <item name="CdrGridObjectId" value="11">
        <description>"Gitter"</description>
      </item>
      <item name="CdrGuidesObjectId" value="12">
        <description>"Hilfslinien"</description>
      </item>
      <item name="CdrDesktopObjectId" value="17">
        <description>"Desktop"</description>
      </item>
    </enum>
  </enums>

  <structs>
    <struct name="Cdr4Point">
      <description>A point given by its x and y coordinates.</description>
      <!-- 0..1 -->
      <member type="Cdr4Coord" name="mX">
        <description>The x coordinate of the point.</description>
      </member>
      <!-- 2..3 -->
      <member type="Cdr4Coord" name="mY">
        <description>The y coordinate of the point.</description>
      </member>
    </struct>

    <struct name="Cdr4BoundingBox">
      <description></description>
      <!-- 0..3 -->
      <member type="Cdr4Point" name="mUpperLeft">
        <description>The upper-left corner of the box.</description>
      </member>
      <!-- 4..7 -->
      <member type="Cdr4Point" name="mLowerRight">
      </member>
    </struct>

    <struct name="CdrCmyk">
      <!-- 0..0 -->
      <member type="quint8" name="mC" />
      <!-- 1..1 -->
      <member type="quint8" name="mM" />
      <!-- 2..2 -->
      <member type="quint8" name="mY" />
      <!-- 3..3 -->
      <member type="quint8" name="mK" />
    </struct>

    <struct name="CdrArgumentData">
<!--    // TODO: convert endianness on bigendian system // void convertToBugEndian(); -->
      <method>
<code><![CDATA[const quint16* argOffsets() const
{ return reinterpret_cast<const quint16*>( reinterpret_cast<const char*>(this)+startOfArgs ); }]]></code>
      </method>
      <method>
<code><![CDATA[template<typename T>
T arg( int i ) const
{ return *reinterpret_cast<const T*>( reinterpret_cast<const char*>(this)+argOffsets()[i] ); }]]></code>
      </method>
      <method>
<code><![CDATA[template<typename T>
const T* argPtr( int i ) const
{ return reinterpret_cast<const T*>( reinterpret_cast<const char*>(this)+argOffsets()[i] ); }]]></code>
      </method>

      <!-- 0..1 -->
      <member name="mChunkLength" type="quint16">
        <description>size of data</description>
      </member>
      <!-- 2..3 -->
      <member name="count" type="quint16">
        <description>number of arguments</description>
      </member>
      <!-- 4..5 -->
      <member name="startOfArgs" type="quint16">
        <description>start of arguments</description>
      </member>
    </struct>

    <struct name="CdrArgumentWithTypeData" base="CdrArgumentData">
      <method>
<code><![CDATA[const quint16* argTypes() const
{ return reinterpret_cast<const quint16*>( reinterpret_cast<const char*>(this)+startOfArgTypes ); }]]></code>
      </method>
      <method><!--order of types seems inverted...-->
<code><![CDATA[quint16 argType( int i ) const { return argTypes()[count-i-1]; }]]></code>
      </method>
      <!-- 6..7: start of arguments types-->
      <member name="startOfArgTypes" type="quint16" />
    </struct>

    <struct name="CdrObjectArgumentData" base="CdrArgumentWithTypeData">
      <!-- 8..9: type of loda-->
      <member name="chunkType" type="quint16" />
    </struct>

    <struct name="CdrStyleArgumentData" base="CdrArgumentWithTypeData">
      <!-- 8..9: ?-->
      <member name="_unknown0" type="qint16" />
      <!-- 10..11: ?-->
      <member name="_unknown1" type="qint16" />
      <!-- 12..13: ?-->
      <member name="_unknown2" type="qint16" />
      <!-- 14..15: ?-->
      <member name="_unknown3" type="qint16" />
      <!-- 16..17: ?-->
      <member name="_unknown4" type="qint16" />
    </struct>

    <struct name="CdrTrflArgumentData" base="CdrArgumentData">
      <!-- 6..7: seen FF FF-->
      <member name="_unknown0" type="qint16" />
      <!-- 8..9: seen 00 00-->
      <member name="_unknown1" type="qint16" />
    </struct>

    <!-- 0D 00 16 01 01 00 - also size, bold, italic etc. ?-->
    <struct name="CdrStyleFontArgumentData">
      <!-- 0..1: font index-->
      <member name="mFontIndex" type="quint16">
        <description>The index of the font in the font table.</description>
      </member>
      <!-- 2..2: fontsize?-->
      <member name="mFontSize" type="quint8" />
      <!-- 3..3: ?-->
      <member name="_unknown1" type="quint8" />
      <!-- 4..4: ?-->
      <member name="_unknown2" type="quint8" />
      <!-- 5..5: ?-->
      <member name="_unknown3" type="quint8" />
    </struct>
  </structs>

  <enums>
    <enum name="CdrFillType">
      <item name="CdrTransparent" value="0" />
      <item name="CdrSolid" value="1" />
    </enum>
  </enums>

  <structs>
<!--
// 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00
// 01 00 00 00 00 00 00 00 14 00 00 00 00 00 00 00 C2 01 3C 00 00 00
// 01 00 00 00 00 00 00 00 3C 00 00 00 00 00 00 00 C2 01 3C 00 00 00
// 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C2 01 3C 00 00 00

// 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00
// 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 00 00 00 00 00 00
// 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
//            |           |           |           |           |
// colormd                 CMYK?
// possible data: color
-->
    <struct name="CdrSolidFillData">
      <method>
<code><![CDATA[QColor color() const
//     { return QColor::fromCmyk(mColor.mC, mColor.mM, mColor.mY, mColor.mK); }
    { return QColor::fromCmyk(0, 0, 0, 255-mColor.mC); }
//     { return QColor::fromCmyk(0, 0, 0, 1); }]]></code>
      </method>
      <!-- 0..3: seen 1-->
      <member name="_unknown1" type="quint32" />
      <!-- 4..7: seen 0-->
      <member name="_unknown2" type="quint32" />
      <!-- 8..11: seen 0, 20, 60, 100-->
      <member name="mColor" type="CdrCmyk" />
      <!-- 12..15: seen 0-->
      <member name="_unknown4" type="quint32" />
      <!-- 16..19: seen 0, C2 01 3C 00 (3932610 oder 450,60 oder 194,1,60,0)-->
      <member name="_unknown5" type="quint32" />
      <!-- 20..21: seen 0-->
      <member name="_unknown6" type="quint16" />
    </struct>

    <struct name="CdrFillData">
      <method>
          <code><![CDATA[const CdrSolidFillData* solidFillData() const
          { return reinterpret_cast<const CdrSolidFillData*>(&firstFillTypeData); }]]></code></method>
      <!-- 0..3: uint32 index/key/id? would match loda-->
      <member type="quint32" name="mFillIndex" />
      <!-- 4..7: filltype (?)-->
      <member type="quint32" name="mFillType" />
      <!-- 8..end: fill specific data, size depends on type-->
      <member type="char" name="firstFillTypeData" />
    </struct>
<!--
// 01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 02 00 00 00 02 00 00 00 00 00 03 00 64 00 00 00 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

// 01 00 00 00 01 00 00 00 00 00 0E 00 64 00 00 00 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 02 00 00 00 02 00 00 00 00 00 03 00 64 00 00 00 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 03 00 00 00 01 00 00 00 00 00 03 00 64 00 00 00 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 04 00 00 00 32 00 00 00 00 00 4A 00 0A 00 8E FE 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 05 00 00 00 32 00 00 00 00 00 4A 00 0A 00 8E FE 01 00 00 00 00 00 00 00 32 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 06 00 00 00 32 00 00 00 00 00 1E 00 0A 00 8E FE 01 00 00 00 00 00 00 00 3C 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
// 07 00 00 00 32 00 00 00 00 00 1E 00 0A 00 8E FE 01 00 00 00 00 00 00 00 64 00 00 00 00 00 00 00 C2 01 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
//            |     |     |     |     |     |     |           |           |           |           |           |
// 0           4     6     8     10    12    14    16          20          24          28          32          36
// possible data: line type, line ending type, color
// 68 bytes:
-->
    <struct name="CdrOutlineData">
      <!-- 0..3: uint32 index/key/id? would match loda-->
      <member name="mIndex" type="quint32" />
      <!-- 4..5: type (?) seen 1, 2, 50-->
      <member name="mType" type="quint16" />
      <!-- 6..7: always 00 00 caps-->
      <member name="_unknown0" type="quint16" />
      <!-- 8..9: always 00 00 corner-->
      <member name="_unknown1" type="quint16" />
      <!-- 10..11: line width? seen 0, 3, 14, 30, 74-->
      <member name="mLineWidth" type="quint16" />
      <!-- 12..13: seen 0, 10, 100-->
      <member name="_unknown3" type="quint16" />
      <!-- 14..15: seen 0, -370-->
      <member name="_unknown4" type="quint16" />
      <!-- 16..37: sample data hints to be like CdrSolidFillData-->
      <member name="mFillData" type="CdrSolidFillData" />
      <!-- 16..19: seen 0, 1>
//     quint32 _unknown5;
      // 20..23: seen 0
//     quint32 _unknown6;
      // 24..27: seen 0, 50, 60, 100
//     quint32 _unknown7;
      // 28..31: seen 0
//     quint32 _unknown8;
      // 32..35: seen 0, C2 01 3C 00 (3932610 oder 450,60 oder 194,1,60,0)
//     quint32 _unknown9;
      // 36..37: seen 0
//     quint16 _unknown10;-->
      <!-- 38..67: seen 0-->
      <member name="_data[30]" type="char" />
    </struct>

    <!-- sample data: AC 2D B6 DF 00 00-->
    <struct name="Cdr4RectangleData">
      <!-- 0..1: width?-->
      <member name="mWidth" type="quint16" />
      <!-- 2..3: height?-->
      <member name="mHeight" type="quint16" />
      <!-- 4..5: ? rounded corners?-->
      <member name="_unknown" type="quint16" />
    </struct>

    <!-- sample data: 4F FA 28 FC 8C 0A 8C 0A 00 00-->
    <struct name="Cdr4EllipseData">
      <!-- 0..3: center?-->
      <member name="mCenterPoint" type="Cdr4Point" />
      <!-- 4..5: x radius?-->
      <member name="mXRadius" type="quint16" />
      <!-- 6..7: y radius?-->
      <member name="mYRadius" type="quint16" />
      <!-- 8..9: ?-->
      <member name="_unknown" type="quint16" />
    </struct>
  </structs>
<!--
// point types:
// 0C
// 44
// 48
// 64
// C0
// 84
// first point has 0C (or 0D)
// last point has 48 (or 49)
// a break in the line are points with 48 0C
// but there is also C0 84, difference is?
// lots of connected straight lines seem 44 44 44
// no idea about this example yet:
// -63.5019 , 115.261 : "c" 
// 19.6554 , 47.2277 : "44" 
// 114.116 , 98.271 : "64" 
// 114.116 , 98.271 : "c0" 
// 42.3346 , 188.911 : "c0" 
// 42.3346 , 188.911 : "84" 
// -63.5019 , 115.261 : "48" 

// looks like flags, a nibble per direction?
// 0  0000
// 4  0100
// 6  0110
// 8  1000
// 9  1001
// C  1100
// D  1101
-->
  <typedefs>
    <type name="PointType" original="unsigned char" />
  </typedefs>

  <enums>
    <enum name="PointFlags">
      <item name="UnknownPointFlag" value="1" />
      <item name="LineCurved" value="2" />
      <item name="LineStart" value="4 " />
      <item name="UnknownPointFlag2" value="8" />
    </enum>
  </enums>

  <structs>
    <struct name="Cdr4PointList">
      <method>
<code><![CDATA[Cdr4Point point( int i ) const
    { return (&firstPoint)[i]; }]]></code>
      </method>
      <method>
        <!-- TODO: check that type is not inverted like arg types are-->
<code><![CDATA[PointType pointType( int i ) const
    { return reinterpret_cast<const PointType*>(&firstPoint+count)[i]; }]]></code>
      </method>
      <!-- 0..1: number of points-->
      <member name="count" type="quint16" />
      <!-- 2..3: ?-->
      <member name="_unknown" type="quint16" />
      <!-- 4..4+num*4: num of 16bit coord pairs-->
      <member name="firstPoint" type="Cdr4Point" /> // used to get pointer in pointType(...)
      <!-- 4+num*4+1..4+num*5: point types (inverted?)-->
      <!-- seems types are padded to full 32 bit slots, but no need to care while reading-->
    </struct>

    <struct name="Cdr4CharData">
      <member name="_unknown" type="quint8" />
      <member name="mChar" type="char" />
      <member name="_unknown2" type="quint8" />
    </struct>

    <struct name="Cdr4TextData">
      <method>
<code><![CDATA[Cdr4CharData charData( int i ) const
    { return (&firstChar)[i]; }]]></code>
      </method>
      <!-- 0..1: ? is 00 00 in samples-->
      <member name="_unknown" type="quint16" />
      <!-- 2..3: length of text-->
      <member name="mLength" type="quint16" />
      <!-- 4..5: size of complete data-->
      <member name="mDataSize" type="quint16" />
      <!-- now the chars, have two \0 bytes between them,
           one before the first, not sure if the first has meaning or belongs to char
           assume this for now, see CharData
           "ä" was seen, so encoding is local one (was 8-bit one for me, visible with iso-8859-1)
           linebreak is with 0D 0A chars-->
      <!-- 4..4+num*4: num of 16bit coord pairs-->
      <member name="firstChar" type="Cdr4CharData" />; // used to get pointer in pointType(...)
    </struct>

<!--
// possible transformations:
// translate: needs two coords, qint16 -> 4 byte
// scale: needs two scale, qint16 -> 4 byte
// rotate: needs center coords + angle -> 4+x byte
// skewX: needs angle -> x byte
// skewY: needs angle -> x byte
// sample: 08 00 00 00 01 00 00 00 00 00 04 EC FF FF 00 00 00 00 00 00 01 00 13 0E 00 00
// sample: 08 00 29 B6 05 00 86 6A FE FF 83 F7 FF FF 7A 95 01 00 29 B6 05 00 6F FC FF FF
// sample: 08 00 29 B6 05 00 86 6A FE FF D6 F7 FF FF 7A 95 01 00 29 B6 05 00 34 FC FF FF
// sample: 08 00 1A EF 00 00 00 00 00 00 D8 F0 FF FF 00 00 00 00 00 00 01 00 8B 0B 00 00
// sample: 08 00 00 00 01 00 00 00 00 00 2A E9 FF FF 00 00 00 00 00 00 01 00 25 10 00 00
// sample: 08 00 00 00 01 00 00 00 00 00 3E 04 00 00 00 00 00 00 00 00 01 00 DF 03 00 00
// sample: 08 00 00 00 01 00 00 00 00 00 87 F3 FF FF 00 00 00 00 00 00 01 00 98 F8 FF FF
//              |     |     |           |           |           |     |     |           |
// Also found this in a list of data, size 72 bytes:
// sample: 02 00 01 00 00 00 BC F3 13 08 FB 0F E9 F7 BC F3 E9 F7 BC F3 13 08 FB 0F 13 08 FB 0F E9 F7 BC F3 E9 F7 E8 1C 00 00 00 00 80 84 2E 41 00 00 00 00 00 00 00 C0 D0 1C 00 00 00 00 00 B8 7D 40 00 00 00 00 80 84 2E 41 00 00
// for type 3 number of trfd args: 2, 15, 1, 12, in sync with arg type 10 (outline index?)
-->
    <struct name="TransformData">
      <member name="_unknown[26]" type="char" />
    </struct>

   <!-- CDR4 has 54 bytes, CDR5 56 bytes (const structure?)-->
   <struct name="MCfgData">
      <!-- 0..1: width-->
      <member name="width" type="quint16" />
      <!-- 2..3: height-->
      <member name="height" type="quint16" />
    </struct>

<!--
// 0000:0020 |       61 00  01 00 00 00  00 00 00 00  00 00 00 00 |   a.............
// 0000:0030 | 04 00 C2 00  98 1F                                 | ..Â...
-->
    <struct name="LnkData">
      <!-- 0..19: unknown-->
      <member name="unknown[20]" type="char" />
    </struct>
  </structs>
</format>
