/* This code was generated by msoscheme (http://gitorious.org/msoscheme) */
#include "api.h"
const quint32 MSO::RecordHeader::_size = 8;
MSO::RecordHeader::RecordHeader(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    recVer = readuint4(_d + _position);
    _msize = 0;
    _position += _msize;
    recInstance = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    recType = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    recLen = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::CurrentUserAtom::CurrentUserAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FF6)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    size = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)size) == 0x14)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    headerToken = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)headerToken) == 0xE391C05F || ((quint32)headerToken) == 0xF3D1C4DF)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    offsetToCurrentEdit = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    lenUserName = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)lenUserName)<=255)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    docFileVersion = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)docFileVersion) == 0x03F4)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    majorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)majorVersion) == 0x03)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    minorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)minorVersion) == 0x00)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    ansiUserName = MSOCastArray<char>((const char*)(_d + _position), lenUserName);
    _msize = (lenUserName)*1;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    relVersion = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)relVersion) == 0x8 || ((quint32)relVersion) == 0x9)) {
         return;
    }
    _position += _msize;
    _has_unicodeUserName = rh.recLen>3*lenUserName+0x18;
    if (_has_unicodeUserName) {
        unicodeUserName = MSOCastArray<quint16>((const quint16*)(_d + _position), lenUserName);
        _msize = (lenUserName)*2;
        _position += _msize;
    }
    _has_unknown = rh.recLen-0x18-3*lenUserName>0;
    if (_has_unknown) {
        unknown = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-0x18-3*lenUserName);
        _msize = (rh.recLen-0x18-3*lenUserName)*1;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TODOS::TODOS(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    anon = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (anon._data == 0) return;
        _msize = anon._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::Byte::_size = 1;
MSO::Byte::Byte(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ZeroByte::_size = 1;
MSO::ZeroByte::ZeroByte(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)b) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::CurrentUserStream::CurrentUserStream(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon1 = CurrentUserAtom(_d + _position, _maxsize - _position);
    if (anon1._data == 0) return;
    _msize = anon1._size;
    _position += _msize;
    trailing = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (trailing._data == 0) return;
        _msize = trailing._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBStoreDelay::OfficeArtBStoreDelay(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rgfb = MSOArray<OfficeArtBStoreContainerFileBlock>(_d + _position, _maxsize - _position);
    if (rgfb._data == 0) return;
        _msize = rgfb._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtRecordHeader::_size = 8;
MSO::OfficeArtRecordHeader::OfficeArtRecordHeader(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    recVer = readuint4(_d + _position);
    _msize = 0;
    _position += _msize;
    recInstance = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    recType = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    recLen = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::OfficeArtBlipJPEG::OfficeArtBlipJPEG(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x46A || rh.recInstance == 0x46B || rh.recInstance == 0x6E2 || rh.recInstance == 0x6E3)) {
         return;
    }
    if (!(rh.recType == 0xF01D)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x46B || rh.recInstance == 0x6E3;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance == 0x46A || rh.recInstance == 0x6E2)?17:33));
    _msize = (rh.recLen-((rh.recInstance == 0x46A || rh.recInstance == 0x6E2)?17:33))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBlipPNG::OfficeArtBlipPNG(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x6E0 || rh.recInstance == 0x6E1)) {
         return;
    }
    if (!(rh.recType == 0xF01E)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x6E1;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance==0x6E0)?17:33));
    _msize = (rh.recLen-((rh.recInstance==0x6E0)?17:33))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBlipDIB::OfficeArtBlipDIB(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x7A8 || rh.recInstance == 0x7A9)) {
         return;
    }
    if (!(rh.recType == 0xF01F)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x7A9;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance==0x7A8)?17:33));
    _msize = (rh.recLen-((rh.recInstance==0x7A8)?17:33))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBlipTIFF::OfficeArtBlipTIFF(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x6E4 || rh.recInstance == 0x6E5)) {
         return;
    }
    if (!(rh.recType == 0xF020)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x6E5;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 1 > _maxsize) return;
    tag = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance==0x6E4)?17:33));
    _msize = (rh.recLen-((rh.recInstance==0x6E4)?17:33))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::RECT::_size = 16;
MSO::RECT::RECT(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    left = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    top = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    right = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    bottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::POINT::_size = 8;
MSO::POINT::POINT(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    x = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    y = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::PowerPointStructs::PowerPointStructs(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    anon = MSOArray<PowerPointStruct>(_d + _position, _maxsize - _position);
    if (anon._data == 0) return;
        _msize = anon._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::SoundCollectionAtom::_size = 12;
MSO::SoundCollectionAtom::SoundCollectionAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x7e5)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    soundIdSeed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::HeadersFootersAtom::_size = 12;
MSO::HeadersFootersAtom::HeadersFootersAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFDA)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    formatId = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)formatId)>=0)) {
         return;
    }
    if (!(((qint16)formatId)<=13)) {
         return;
    }
    _position += _msize;
    fHasDate = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasTodayDate = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasUserDate = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasSlideNumber = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasHeader = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasFooter = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    reserved2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::UserDateAtom::UserDateAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    if (!(rh.recLen<=510)) {
         return;
    }
    _position += _msize;
    userDate = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::HeaderAtom::HeaderAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    header = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::FooterAtom::FooterAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 2)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    footer = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PerSlideHeadersFootersContainer::PerSlideHeadersFootersContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFD9)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    hfAtom = HeadersFootersAtom(_d + _position);
    if (hfAtom._data == 0) return;
    _msize = hfAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        userDateAtom = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (userDateAtom._data) ?userDateAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        headerAtom = HeaderAtom(_d + _position, _maxsize - _position);
        _msize = (headerAtom._data) ?headerAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        footerAtom = FooterAtom(_d + _position, _maxsize - _position);
        _msize = (footerAtom._data) ?footerAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        userDateAtom2 = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (userDateAtom2._data) ?userDateAtom2._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
const quint32 MSO::EndDocumentAtom::_size = 8;
MSO::EndDocumentAtom::EndDocumentAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3EA)) {
         return;
    }
    if (!(rh.recLen == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::DocInfoListContainer::DocInfoListContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x7D0)) {
         return;
    }
    _position += _msize;
    rgChildRec = MSOArray<DocInfoListSubContainerOrAtom>(_d + _position, _maxsize - _position);
    if (rgChildRec._data == 0) return;
        _msize = rgChildRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::SlideViewInfoAtom::_size = 11;
MSO::SlideViewInfoAtom::SlideViewInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3FE)) {
         return;
    }
    if (!(rh.recLen == 3)) {
         return;
    }
    _position += _msize;
    unused1 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fSnapToGrid = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fSnapToShape = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GuideAtom::_size = 16;
MSO::GuideAtom::GuideAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 7)) {
         return;
    }
    if (!(rh.recType == 0x3FB)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    type = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)type) == 0 || ((quint32)type) == 1)) {
         return;
    }
    _position += _msize;
    pos = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)pos)>=-15840)) {
         return;
    }
    if (!(((qint32)pos)<=32255)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::DocProgTagsContainer::DocProgTagsContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x1388)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgChildRec = MSOArray<DocProgTagsSubContainerOrAtom>(_d + _position, rh.recLen);
    if (rgChildRec._size != rh.recLen) return;
        _msize = rgChildRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::TextAutoNumberScheme::_size = 4;
MSO::TextAutoNumberScheme::TextAutoNumberScheme(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    scheme = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)scheme)<=40)) {
         return;
    }
    _position += _msize;
    startNum = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)startNum)>=1)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::BlipCollection9Container::BlipCollection9Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x07F8)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgBlipEntityAtom = MSOArray<BlipEntityAtom>(_d + _position, rh.recLen);
    if (rgBlipEntityAtom._size != rh.recLen) return;
        _msize = rgBlipEntityAtom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::Kinsoku9Atom::_size = 12;
MSO::Kinsoku9Atom::Kinsoku9Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x3)) {
         return;
    }
    if (!(rh.recType == 0x0FD2)) {
         return;
    }
    if (!(rh.recLen == 0x0004)) {
         return;
    }
    _position += _msize;
    korLevel = readuint2(_d + _position);
    _msize = 0;
    if (!(((quint8)korLevel) == 0x0 || ((quint8)korLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    scLevel = readuint2_2(_d + _position);
    _msize = 0;
    if (!(((quint8)scLevel) == 0x0 || ((quint8)scLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    tcLevel = readuint2_4(_d + _position);
    _msize = 0;
    if (!(((quint8)tcLevel) == 0x0 || ((quint8)tcLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    jpnLevel = readuint2_6(_d + _position);
    _msize = 1;
    if (!(((quint8)jpnLevel) == 0x0 || ((quint8)jpnLevel) == 0x1 || ((quint8)jpnLevel) == 0x2)) {
         return;
    }
    _position += _msize;
    reserveda = readuint4(_d + _position);
    _msize = 0;
    if (!(((quint8)reserveda) == 0)) {
         return;
    }
    _position += _msize;
    reservedb = readuint20_4(_d + _position);
    _msize = 3;
    if (!(((quint32)reservedb) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::ExHyperlink9Container::ExHyperlink9Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFE4)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::PresAdvisorFlags9Atom::_size = 12;
MSO::PresAdvisorFlags9Atom::PresAdvisorFlags9Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x177A)) {
         return;
    }
    if (!(rh.recLen == 0x4)) {
         return;
    }
    _position += _msize;
    fDisableCaseStyleTitleRule = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableCaseStyleBodyRule = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableEndPunctuationTitleRule = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableEndPunctuationBodyRule = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableTooManyBulletsRule = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableFontSizeTitleRule = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableFontSizeBodyRule = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableNumberOfLinesTitleRule = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fDisableNumberOfLinesBodyRule = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisableTooManyFontsRule = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fDisablePrintTip = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserveda = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)reserveda) == 0)) {
         return;
    }
    _position += _msize;
    reservedb = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)reservedb) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::EnvelopeData9Atom::EnvelopeData9Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1785)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::EnvelopeFlags9Atom::_size = 12;
MSO::EnvelopeFlags9Atom::EnvelopeFlags9Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1784)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    fHasEnvelope = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fEnvelopeVisible = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readuint2_2(_d + _position);
    _msize = 0;
    if (!(((quint8)reserved1) == 0)) {
         return;
    }
    _position += _msize;
    fEnvelopeDirty = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2a = readuint3_5(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2a) == 0)) {
         return;
    }
    _position += _msize;
    reserved2b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2b) == 0)) {
         return;
    }
    _position += _msize;
    reserved2c = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)reserved2c) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::HTMLDocInfo9Atom::_size = 24;
MSO::HTMLDocInfo9Atom::HTMLDocInfo9Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x177B)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    unused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    encoding = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    frameColorType = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)frameColorType) == 0 || ((quint16)frameColorType) == 1 || ((quint16)frameColorType) == 2 || ((quint16)frameColorType) == 3 || ((quint16)frameColorType) == 4 || ((quint16)frameColorType) == 5)) {
         return;
    }
    _position += _msize;
    screenSize = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    outputType = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fShowFrame = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fResizeGraphics = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fOrganizeInFolder = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseLongFileNames = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fRelyOnVML = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fAllowPNG = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fShowSlideAnimation = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readbit_7(_d + _position);
    _msize = 1;
    if (!(((bool)reserved1) == false)) {
         return;
    }
    _position += _msize;
    unused3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::HTMLPublishInfo9Container::HTMLPublishInfo9Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x177D)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::BroadcastDocInfo9Container::BroadcastDocInfo9Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x177E)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OutlineTextProps9Container::OutlineTextProps9Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FAE)) {
         return;
    }
    _position += _msize;
    rgOutlineTextProps9Entry = MSOArray<OutlineTextProps9Entry>(_d + _position, _maxsize - _position);
    if (rgOutlineTextProps9Entry._data == 0) return;
        _msize = rgOutlineTextProps9Entry._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OutlineTextPropsHeaderExAtom::_size = 16;
MSO::OutlineTextPropsHeaderExAtom::OutlineTextPropsHeaderExAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance<=5)) {
         return;
    }
    if (!(rh.recType == 0xFAF)) {
         return;
    }
    _position += _msize;
    slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    txType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::StyleTextProp9Atom::StyleTextProp9Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFAC)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgStyleTextProp9 = MSOArray<StyleTextProp9>(_d + _position, rh.recLen);
    if (rgStyleTextProp9._size != rh.recLen) return;
        _msize = rgStyleTextProp9._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::FontCollection10Container::FontCollection10Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x07D6)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgFontCollectionEntry = MSOArray<FontCollectionEntry>(_d + _position, rh.recLen);
    if (rgFontCollectionEntry._size != rh.recLen) return;
        _msize = rgFontCollectionEntry._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::GridSpacing10Atom::_size = 16;
MSO::GridSpacing10Atom::GridSpacing10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x040D)) {
         return;
    }
    if (!(rh.recLen == 0x08)) {
         return;
    }
    _position += _msize;
    x = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)x)>=23224)) {
         return;
    }
    if (!(((quint32)x)<=1179648)) {
         return;
    }
    _position += _msize;
    y = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)y)>=23224)) {
         return;
    }
    if (!(((quint32)y)<=1179648)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::AuthorNameAtom::AuthorNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen<=104)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    authorName = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::CommentIndex10Atom::_size = 16;
MSO::CommentIndex10Atom::CommentIndex10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x2EE5)) {
         return;
    }
    if (!(rh.recLen == 0x08)) {
         return;
    }
    _position += _msize;
    colorIndex = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)colorIndex)>=0)) {
         return;
    }
    _position += _msize;
    commentIndexSeed = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)commentIndexSeed)>=0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FontEmbedFlags10Atom::_size = 12;
MSO::FontEmbedFlags10Atom::FontEmbedFlags10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x32C8)) {
         return;
    }
    if (!(rh.recLen == 0x04)) {
         return;
    }
    _position += _msize;
    fSubset = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fSubsetOptionConfirmed = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unuseda = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    unusedb = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::CopyrightAtom::CopyrightAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x1)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen<=510)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    copyright = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::KeywordsAtom::KeywordsAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x2)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen<=510)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    keywords = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::FilterPrivacyFlags10Atom::_size = 12;
MSO::FilterPrivacyFlags10Atom::FilterPrivacyFlags10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x36B0)) {
         return;
    }
    if (!(rh.recLen == 0x04)) {
         return;
    }
    _position += _msize;
    fRemovePII = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2a = readuint7_1(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2a) == 0x0)) {
         return;
    }
    _position += _msize;
    reserved2b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2b) == 0x0)) {
         return;
    }
    _position += _msize;
    reserved2c = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)reserved2c) == 0x0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::OutlineTextProps10Container::OutlineTextProps10Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FB3)) {
         return;
    }
    _position += _msize;
    rgOutlineTextProps10Entry = MSOArray<OutlineTextProps10Entry>(_d + _position, _maxsize - _position);
    if (rgOutlineTextProps10Entry._data == 0) return;
        _msize = rgOutlineTextProps10Entry._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::StyleTextProp10Atom::StyleTextProp10Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0xFB1)) {
         return;
    }
    _position += _msize;
    rgStyleTextProp10 = MSOArray<TextCFException10>(_d + _position, _maxsize - _position);
    if (rgStyleTextProp10._data == 0) return;
        _msize = rgStyleTextProp10._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::DocToolbarStates10Atom::_size = 9;
MSO::DocToolbarStates10Atom::DocToolbarStates10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x36B1)) {
         return;
    }
    if (!(rh.recLen == 0x01)) {
         return;
    }
    _position += _msize;
    fShowReviewingToolbar = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fShowReviewingGallery = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint6_2(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved) == 0x0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::SlideListTable10Container::SlideListTable10Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EF1)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::DiffTree10Container::DiffTree10Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EEC)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ModifyPasswordAtom::ModifyPasswordAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x03)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen<=510)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    modifyPassword = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::PhotoAlbumInfo10Atom::_size = 14;
MSO::PhotoAlbumInfo10Atom::PhotoAlbumInfo10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x036B2)) {
         return;
    }
    if (!(rh.recLen == 0x06)) {
         return;
    }
    _position += _msize;
    fUseBlackWhite = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fHasCaption = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    layout = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)layout) == 0 || ((quint8)layout) == 1 || ((quint8)layout) == 2 || ((quint8)layout) == 3 || ((quint8)layout) == 4 || ((quint8)layout) == 5 || ((quint8)layout) == 6)) {
         return;
    }
    _position += _msize;
    unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    frameShape = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)frameShape) == 0x0000 || ((quint16)frameShape) == 0x0001 || ((quint16)frameShape) == 0x0002 || ((quint16)frameShape) == 0x0003 || ((quint16)frameShape) == 0x0004 || ((quint16)frameShape) == 0x0005 || ((quint16)frameShape) == 0x0006)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::SmartTagStore11Container::SmartTagStore11Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x36B3)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OutlineTextProps11Container::OutlineTextProps11Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FB5)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::BinaryTagDataBlob::BinaryTagDataBlob(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP12DocBinaryTagExtension::PP12DocBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0x0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rhData.recLen);
    _msize = (rhData.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SorterViewInfoContainer::SorterViewInfoContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x408)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::VBAInfoAtom::_size = 20;
MSO::VBAInfoAtom::VBAInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 2)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x400)) {
         return;
    }
    if (!(rh.recLen == 0xC)) {
         return;
    }
    _position += _msize;
    persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fHasMacros = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)fHasMacros) == 0 || ((quint32)fHasMacros) == 1)) {
         return;
    }
    _position += _msize;
    version = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)version) == 0 || ((quint32)version) == 1 || ((quint32)version) == 2)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::MasterListWithTextContainer::MasterListWithTextContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x1)) {
         return;
    }
    if (!(rh.recType == 0x0FF0)) {
         return;
    }
    if (!(rh.recLen%28==0)) {
         return;
    }
    _position += _msize;
    rgMasterPersistAtom = MSOArray<MasterPersistAtom>(_d + _position, 28 * rh.recLen/28, rh.recLen/28);
    if (rgMasterPersistAtom._count != rh.recLen/28) return;
        _msize = rgMasterPersistAtom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::MasterPersistAtom::_size = 28;
MSO::MasterPersistAtom::MasterPersistAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3F3)) {
         return;
    }
    if (!(rh.recLen == 0x14)) {
         return;
    }
    _position += _msize;
    persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved1 = readuint2(_d + _position);
    _msize = 0;
    if (!(((quint8)reserved1) == 0)) {
         return;
    }
    _position += _msize;
    fNonOutLineData = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2 = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2) == 0)) {
         return;
    }
    _position += _msize;
    reserved3 = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved3) == 0)) {
         return;
    }
    _position += _msize;
    reserved4 = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)reserved4) == 0)) {
         return;
    }
    _position += _msize;
    reserved5 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved5) == 0)) {
         return;
    }
    _position += _msize;
    masterId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved6 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved6) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::SlideListWithTextContainer::SlideListWithTextContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FF0)) {
         return;
    }
    _position += _msize;
    rgChildRec = MSOArray<SlideListWithTextSubContainerOrAtom>(_d + _position, _maxsize - _position);
    if (rgChildRec._data == 0) return;
        _msize = rgChildRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::NotesListWithTextContainer::NotesListWithTextContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 2)) {
         return;
    }
    if (!(rh.recType == 0x0FF0)) {
         return;
    }
    _position += _msize;
    rgNotesPersistAtom = MSOArray<NotesPersistAtom>(_d + _position, _maxsize - _position);
    if (rgNotesPersistAtom._data == 0) return;
        _msize = rgNotesPersistAtom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::NotesPersistAtom::_size = 28;
MSO::NotesPersistAtom::NotesPersistAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x03F3)) {
         return;
    }
    if (!(rh.recLen == 0x14)) {
         return;
    }
    _position += _msize;
    persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved1 = readuint2(_d + _position);
    _msize = 0;
    if (!(((quint8)reserved1) == 0)) {
         return;
    }
    _position += _msize;
    fNonOutlineData = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2a = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2a) == 0)) {
         return;
    }
    _position += _msize;
    reserved2b = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2b) == 0)) {
         return;
    }
    _position += _msize;
    reserved2c = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)reserved2c) == 0)) {
         return;
    }
    _position += _msize;
    reserved3 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved3) == 0)) {
         return;
    }
    _position += _msize;
    notesId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved4 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved4) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::TextHeaderAtom::_size = 12;
MSO::TextHeaderAtom::TextHeaderAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1 || rh.recInstance == 2 || rh.recInstance == 3 || rh.recInstance == 4 || rh.recInstance == 5)) {
         return;
    }
    if (!(rh.recType == 0xF9F)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    textType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::TextCharsAtom::TextCharsAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFA0)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    textChars = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextBytesAtom::TextBytesAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFA8)) {
         return;
    }
    _position += _msize;
    textChars = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::MasterTextPropAtom::MasterTextPropAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFA2)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgMasterTextPropRun = MSOArray<MasterTextPropRun>(_d + _position, rh.recLen);
    if (rgMasterTextPropRun._size != rh.recLen) return;
        _msize = rgMasterTextPropRun._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::MasterTextPropRun::_size = 6;
MSO::MasterTextPropRun::MasterTextPropRun(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    count = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    indentLevel = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)indentLevel)<=4)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::StyleTextPropAtom::StyleTextPropAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFA1)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::SlideNumberMCAtom::_size = 12;
MSO::SlideNumberMCAtom::SlideNumberMCAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFD8)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DateTimeMCAtom::_size = 16;
MSO::DateTimeMCAtom::DateTimeMCAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFF7)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    index = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = MSOCastArray<char>((const char*)(_d + _position), 3);
    _msize = (3)*1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GenericDateMCAtom::_size = 12;
MSO::GenericDateMCAtom::GenericDateMCAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFF8)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::HeaderMCAtom::_size = 12;
MSO::HeaderMCAtom::HeaderMCAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFF9)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FooterMCAtom::_size = 12;
MSO::FooterMCAtom::FooterMCAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFFA)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::RTFDateTimeMCAtom::_size = 140;
MSO::RTFDateTimeMCAtom::RTFDateTimeMCAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1015)) {
         return;
    }
    if (!(rh.recLen == 0x84)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    format = MSOCastArray<char>((const char*)(_d + _position), 128);
    _msize = (128)*1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::TextBookmarkAtom::_size = 20;
MSO::TextBookmarkAtom::TextBookmarkAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFA7)) {
         return;
    }
    if (!(rh.recLen == 0xC)) {
         return;
    }
    _position += _msize;
    begin = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    end = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    bookmarkID = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::TextRange::_size = 8;
MSO::TextRange::TextRange(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    begin = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    end = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::MouseClickTextInteractiveInfoAtom::_size = 16;
MSO::MouseClickTextInteractiveInfoAtom::MouseClickTextInteractiveInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFDF)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    range = TextRange(_d + _position);
    if (range._data == 0) return;
    _msize = range._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::MouseOverTextInteractiveInfoAtom::_size = 16;
MSO::MouseOverTextInteractiveInfoAtom::MouseOverTextInteractiveInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0xFDF)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    range = TextRange(_d + _position);
    if (range._data == 0) return;
    _msize = range._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::SlideId::_size = 4;
MSO::SlideId::SlideId(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    slideId = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)slideId)>=100)) {
         return;
    }
    if (!(((quint32)slideId)<2147483647)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::TabStops::TabStops(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    count = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    rgTabStop = MSOArray<TabStop>(_d + _position, 4 * count, count);
    if (rgTabStop._count != count) return;
        _msize = rgTabStop._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::TabStop::_size = 4;
MSO::TabStop::TabStop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    position = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    type = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PFWrapFlags::_size = 2;
MSO::PFWrapFlags::PFWrapFlags(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    charWrap = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    wordWrap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    overflow = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readuint5_3(_d + _position);
    _msize = 1;
    _position += _msize;
    reserved2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ColorIndexStruct::_size = 4;
MSO::ColorIndexStruct::ColorIndexStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    index = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::BulletFlags::_size = 2;
MSO::BulletFlags::BulletFlags(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fHasBullet = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fBulletHasFont = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fBulletHasColor = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fBulletHasSize = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PFMasks::_size = 4;
MSO::PFMasks::PFMasks(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    hasBullet = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletHasFont = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletHasColor = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletHasSize = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletFont = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletColor = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletSize = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletChar = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    leftMargin = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    unused = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    indent = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    align = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    lineSpacing = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    spaceBefore = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    spaceAfter = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    defaultTabSize = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fontAlign = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    charWrap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    wordWrap = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    overflow = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    tabStops = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    textDirection = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletBlip = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    bulletScheme = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    bulletHasScheme = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CFMasks::_size = 4;
MSO::CFMasks::CFMasks(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    bold = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    italic = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    underline = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    shadow = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fehint = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    kumi = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused3 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    emboss = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasStyle = readuint4_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused4 = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    typeface = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    size = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    color = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    position = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    pp10ext = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    oldEATypeface = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    ansiTypeface = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    symbolTypeface = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    newEATypeface = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    csTypeface = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    pp11ext = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint5_3(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CFStyle::_size = 2;
MSO::CFStyle::CFStyle(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    bold = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    italic = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    underline = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    shadow = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fehint = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    kumi = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused3 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    emboss = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    pp9rt = readuint4_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused4 = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::FontCollectionContainer::FontCollectionContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x07D5)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgFontCollectionEntry = MSOArray<FontCollectionEntry>(_d + _position, rh.recLen);
    if (rgFontCollectionEntry._size != rh.recLen) return;
        _msize = rgFontCollectionEntry._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::FontEntityAtom::_size = 76;
MSO::FontEntityAtom::FontEntityAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance<=128)) {
         return;
    }
    if (!(rh.recType == 0xFB7)) {
         return;
    }
    if (!(rh.recLen == 0x44)) {
         return;
    }
    _position += _msize;
    lfFaceName = MSOCastArray<quint16>((const quint16*)(_d + _position), 32);
    _msize = (32)*2;
    _position += _msize;
    lfCharSet = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fEmbedSubsetted = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    unused = readuint7_1(_d + _position);
    _msize = 1;
    _position += _msize;
    rasterFontType = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    deviceFontType = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    truetypeFontType = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fNoFontSubstitution = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint4_4(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved) == 0)) {
         return;
    }
    _position += _msize;
    lfPitchAndFamily = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::FontEmbedDataBlob::FontEmbedDataBlob(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance<=3)) {
         return;
    }
    if (!(rh.recType == 0xFB8)) {
         return;
    }
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::KinsokuAtom::_size = 12;
MSO::KinsokuAtom::KinsokuAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x3)) {
         return;
    }
    if (!(rh.recType == 0x0FD2)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    level = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)level) == 0 || ((quint32)level) == 1 || ((quint32)level) == 2 || ((quint32)level) == 128)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::KinsokuLeadingAtom::KinsokuLeadingAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    kinsokuLeading = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::KinsokuFollowingAtom::KinsokuFollowingAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 1 )) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    kinsokuFollowing = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextSpecialInfoAtom::TextSpecialInfoAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0xFAA)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgSIRun = MSOArray<TextSIRun>(_d + _position, rh.recLen);
    if (rgSIRun._size != rh.recLen) return;
        _msize = rgSIRun._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SmartTags::SmartTags(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    count = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    rgSmartTagIndex = MSOCastArray<quint32>((const quint32*)(_d + _position), count);
    _msize = (count)*4;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::ExOleEmbedAtom::_size = 16;
MSO::ExOleEmbedAtom::ExOleEmbedAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FCD)) {
         return;
    }
    if (!(rh.recLen == 0x8)) {
         return;
    }
    _position += _msize;
    exColorFollow = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)exColorFollow) == 0 || ((quint32)exColorFollow) == 1 || ((quint32)exColorFollow) == 2)) {
         return;
    }
    _position += _msize;
    fCantLockServer = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fNoSizeToServer = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fIsTable = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PointStruct::_size = 8;
MSO::PointStruct::PointStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    x = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    y = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::RatioStruct::_size = 8;
MSO::RatioStruct::RatioStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    numer = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    denom = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)denom)!= 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::PersistDirectoryAtom::PersistDirectoryAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1772)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgPersistDirEntry = MSOArray<PersistDirectoryEntry>(_d + _position, rh.recLen);
    if (rgPersistDirEntry._size != rh.recLen) return;
        _msize = rgPersistDirEntry._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UnknownDocumentContainerChild::UnknownDocumentContainerChild(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recType == 0x416 || rh.recType == 0x41A || rh.recType == 0x101A || rh.recType == 0x1773 || rh.recType == 0x1788 || rh.recType == 0x178c || rh.recType == 0x178d)) {
         return;
    }
    _position += _msize;
    unknown = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UnknownOfficeArtClientDataChild::UnknownOfficeArtClientDataChild(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFE8 || rh.recType == 0x1019)) {
         return;
    }
    _position += _msize;
    unknown = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UnknownSlideContainerChild::UnknownSlideContainerChild(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x101D)) {
         return;
    }
    _position += _msize;
    unknown = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UnknownTextContainerChild::UnknownTextContainerChild(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 3)) {
         return;
    }
    if (!(rh.recInstance == 9)) {
         return;
    }
    if (!(rh.recType == 0)) {
         return;
    }
    _position += _msize;
    unknown = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PersistDirectoryEntry::PersistDirectoryEntry(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    persistId = readuint20(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    cPersist = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    rgPersistOffset = MSOCastArray<quint32>((const quint32*)(_d + _position), cPersist);
    _msize = (cPersist)*4;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::PersistIdRef::_size = 4;
MSO::PersistIdRef::PersistIdRef(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    anon = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::SchemeListElementColorSchemeAtom::SchemeListElementColorSchemeAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 6)) {
         return;
    }
    if (!(rh.recType == 0x7F0)) {
         return;
    }
    if (!(rh.recLen == 0x20)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    rgSchemeColor = MSOArray<ColorStruct>(_d + _position, 4 * 8, 8);
    if (rgSchemeColor._count != 8) return;
        _msize = rgSchemeColor._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::RoundTripOArtTextStyles12Atom::RoundTripOArtTextStyles12Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x423)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SlideNameAtom::SlideNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 3)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    slideName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SlideProgTagsContainer::SlideProgTagsContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1388)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgTypeRec = MSOArray<SlideProgTagsSubContainerOrAtom>(_d + _position, rh.recLen);
    if (rgTypeRec._size != rh.recLen) return;
        _msize = rgTypeRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP9SlideBinaryTagExtension::PP9SlideBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen == 0xE)) {
         return;
    }
    _position += _msize;
    if (_position + 14 > _maxsize) return;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 7);
    _msize = (7)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    rgTextMasterStyleAtom = MSOArray<TextMasterStyle9Atom>(_d + _position, _maxsize - _position);
    if (rgTextMasterStyleAtom._data == 0) return;
        _msize = rgTextMasterStyleAtom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::Comment10Container::Comment10Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EE0)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::Comment10Atom::Comment10Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EE1)) {
         return;
    }
    if (!(rh.recLen == 0x1C)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::LinkedSlide10Atom::_size = 16;
MSO::LinkedSlide10Atom::LinkedSlide10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EE7)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    linkedSlideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    clinkedShapes = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LinkedShape10Atom::_size = 16;
MSO::LinkedShape10Atom::LinkedShape10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EE6)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    shapeIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    linkedShapeIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::SlideFlags10Atom::_size = 12;
MSO::SlideFlags10Atom::SlideFlags10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EEA)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    fPreserveMaster = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fOverrideMasterAnimatino = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unuseda = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    unusedb = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::HashCode10Atom::_size = 12;
MSO::HashCode10Atom::HashCode10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2B00)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    hash = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::ExtTimeNodeContainer::ExtTimeNodeContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0xF144)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::BuildListContainer::BuildListContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2B02)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::RoundTripHeaderFooterDefaults12Atom::_size = 9;
MSO::RoundTripHeaderFooterDefaults12Atom::RoundTripHeaderFooterDefaults12Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0424)) {
         return;
    }
    if (!(rh.recLen == 1)) {
         return;
    }
    _position += _msize;
    fIncludeDate = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fIncludeFooter = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fIncludeHeader = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fIncludeSlideNumber = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::TagNameAtom::TagNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2 == 0 )) {
         return;
    }
    _position += _msize;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TagValueAtom::TagValueAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    _position += _msize;
    tagValue = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::RoundTripMainMasterRecord::RoundTripMainMasterRecord(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recType == 0x41C || rh.recType == 0x40E || rh.recType == 0x040F || rh.recType == 0x41E || rh.recType == 0x0423 || rh.recType == 0x2B0D || rh.recType == 0x2B0B || rh.recType == 0x041D || rh.recType == 0x2B0C || rh.recType == 0x101D)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TemplateNameAtom::TemplateNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 2)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    templateName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::RoundTripSlideSyncInfo12Container::RoundTripSlideSyncInfo12Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3714)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::SlideFlags::_size = 2;
MSO::SlideFlags::SlideFlags(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fMasterObjects = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fMasterScheme = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fMasterBackground = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readuint5_3(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::NotesRoundTripAtom::NotesRoundTripAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x40E || rh.recType == 0x40F || rh.recType == 0x427)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::HandoutContainer::HandoutContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FC9)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExControlStg::ExControlStg(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x1011)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExOleObjStg::ExOleObjStg(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1011)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UserEditAtom::UserEditAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FF5)) {
         return;
    }
    if (!(rh.recLen == 0x1C || rh.recLen == 0x20)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    lastSlideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    version = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    minorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)minorVersion) == 0)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    majorVersion = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)majorVersion) == 3)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    offsetLastEdit = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    offsetPersistDirectory = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    docPersistIdRef = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)docPersistIdRef) == 1)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    persistIdSeed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    lastView = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)lastView)<=18)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _has_encryptSessionPersistIdRef = rh.recLen==32;
    if (_has_encryptSessionPersistIdRef) {
        if (_position + 4 > _maxsize) return;
        encryptSessionPersistIdRef = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    zeroPadding = MSOArray<ZeroByte>(_d + _position, _maxsize - _position);
    if (zeroPadding._data == 0) return;
        _msize = zeroPadding._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::VbaProjectStg::VbaProjectStg(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x1011)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::SlideAtom::_size = 32;
MSO::SlideAtom::SlideAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x2)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x03EF)) {
         return;
    }
    if (!(rh.recLen == 0x18)) {
         return;
    }
    _position += _msize;
    geom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    rgPlaceholderTypes = MSOCastArray<char>((const char*)(_d + _position), 8);
    _msize = (8)*1;
    _position += _msize;
    masterIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    notesIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    slideFlags = SlideFlags(_d + _position);
    if (slideFlags._data == 0) return;
    _msize = slideFlags._size;
    _position += _msize;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::SlideShowSlideInfoAtom::_size = 24;
MSO::SlideShowSlideInfoAtom::SlideShowSlideInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x03F9)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    slidetime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    effectDirection = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    effectType = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fManualAdvance = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fHidden = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fSound = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved3 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fLoopSound = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved4 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fStopSound = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    freserved5 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fAutoAdvance = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved6 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fCursorVisible = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved7 = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    speed = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = MSOCastArray<char>((const char*)(_d + _position), 3);
    _msize = (3)*1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::SlideShowDocInfoAtom::_size = 88;
MSO::SlideShowDocInfoAtom::SlideShowDocInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 1)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0401)) {
         return;
    }
    if (!(rh.recLen == 0x50)) {
         return;
    }
    _position += _msize;
    penColor = ColorIndexStruct(_d + _position);
    if (penColor._data == 0) return;
    _msize = penColor._size;
    _position += _msize;
    restartTime = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    startSlide = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)startSlide)>=0)) {
         return;
    }
    _position += _msize;
    endSlide = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)endSlide)>=0)) {
         return;
    }
    _position += _msize;
    namedShow = MSOCastArray<char>((const char*)(_d + _position), 64);
    _msize = (64)*1;
    _position += _msize;
    fAutoAdvance = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fWillSkipBuilds = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseSlideRange = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fDocUseNamedShow = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fShowBrowseMode = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fKioskMode = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fWillSkipNarration = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fLoopContinuously = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fHideScrollBar = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint7_1(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::SlideSchemeColorSchemeAtom::SlideSchemeColorSchemeAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x07F0)) {
         return;
    }
    if (!(rh.recLen == 0x20)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    rgSchemeColor = MSOArray<ColorStruct>(_d + _position, 4 * 8, 8);
    if (rgSchemeColor._count != 8) return;
        _msize = rgSchemeColor._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::RoundTripSlideRecord::RoundTripSlideRecord(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recType == 0x40E || rh.recType == 0x40F || rh.recType == 0x41D || rh.recType == 0x3714 || rh.recType == 0x2B0D || rh.recType == 0x2B0B || rh.recType == 0x2B0C || rh.recType == 0x422)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::NamedShowsContainer::NamedShowsContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x410)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SummaryContainer::SummaryContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x402)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::DocRoutingSlipAtom::DocRoutingSlipAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x406)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PrintOptionsAtom::PrintOptionsAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1770)) {
         return;
    }
    if (!(rh.recLen == 5)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::RoundTripCustomTableStyles12Atom::RoundTripCustomTableStyles12Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0 || rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x428)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::RoundTripCompositeMasterId12Atom::_size = 12;
MSO::RoundTripCompositeMasterId12Atom::RoundTripCompositeMasterId12Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x41D)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    compositeMasterId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ColorStruct::_size = 4;
MSO::ColorStruct::ColorStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ExObjListAtom::_size = 12;
MSO::ExObjListAtom::ExObjListAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x040A)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    exObjIdSeed = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)exObjIdSeed)>=1)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::ExAviMovieContainer::ExAviMovieContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1006)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExCDAudioContainer::ExCDAudioContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x100E)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::ExControlAtom::_size = 12;
MSO::ExControlAtom::ExControlAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFFB)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ExHyperlinkAtom::_size = 12;
MSO::ExHyperlinkAtom::ExHyperlinkAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFD3)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    exHyperLinkId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::FriendlyNameAtom::FriendlyNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    friendlyName = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TargetAtom::TargetAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    target = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::LocationAtom::LocationAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 3)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    location = MSOCastArray<quint16>((const quint16*)(_d + _position), rh.recLen/2);
    _msize = (rh.recLen/2)*2;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExMCIMovieContainer::ExMCIMovieContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1007)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExMIDIAudioContainer::ExMIDIAudioContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x100D)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExWAVAudioEmbeddedContainer::ExWAVAudioEmbeddedContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x100F)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExWAVAudioLinkContainer::ExWAVAudioLinkContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1010)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UnknownExObjListSubContainerChild::UnknownExObjListSubContainerChild(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFEA)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::ExOleLinkAtom::_size = 20;
MSO::ExOleLinkAtom::ExOleLinkAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FD1)) {
         return;
    }
    if (!(rh.recLen == 0xC)) {
         return;
    }
    _position += _msize;
    slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    oleUpdateMode = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    unused = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ExOleObjAtom::_size = 32;
MSO::ExOleObjAtom::ExOleObjAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x1)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FC3)) {
         return;
    }
    if (!(rh.recLen == 0x18)) {
         return;
    }
    _position += _msize;
    drawAspect = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    type = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    exObjId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    subType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    unused = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::MenuNameAtom::MenuNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x1)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen%2 == 0 )) {
         return;
    }
    _position += _msize;
    menuName = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ProgIDAtom::ProgIDAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x2)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen%2 == 0 )) {
         return;
    }
    _position += _msize;
    progId = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ClipboardNameAtom::ClipboardNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x3)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen%2 == 0 )) {
         return;
    }
    _position += _msize;
    clipboardName = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::MetafileBlob::MetafileBlob(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FC1)) {
         return;
    }
    if (!(rh.recLen>16)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    mm = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    xExt = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    yExt = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-6);
    _msize = (rh.recLen-6)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtFDGG::_size = 16;
MSO::OfficeArtFDGG::OfficeArtFDGG(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    spidMax = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)spidMax)<67098623)) {
         return;
    }
    _position += _msize;
    cidcl = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)cidcl)<268435455)) {
         return;
    }
    _position += _msize;
    cspSaved = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    cdgSaved = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtFDG::_size = 16;
MSO::OfficeArtFDG::OfficeArtFDG(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance<=4094)) {
         return;
    }
    if (!(rh.recType == 0x0F008)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    csp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    spidCur = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::OfficeArtFRITContainer::OfficeArtFRITContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recType == 0xF118)) {
         return;
    }
    if (!(rh.recLen==4*rh.recInstance)) {
         return;
    }
    _position += _msize;
    rgfrit = MSOArray<OfficeArtFRIT>(_d + _position, 4 * rh.recInstance, rh.recInstance);
    if (rgfrit._count != rh.recInstance) return;
        _msize = rgfrit._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtFRIT::_size = 4;
MSO::OfficeArtFRIT::OfficeArtFRIT(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fridNew = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    fridOld = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::OfficeArtBStoreContainer::OfficeArtBStoreContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recType == 0x0F001)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgfb = MSOArray<OfficeArtBStoreContainerFileBlock>(_d + _position, rh.recLen);
    if (rgfb._size != rh.recLen) return;
        _msize = rgfb._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtSpgrContainer::OfficeArtSpgrContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0F003)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgfb = MSOArray<OfficeArtSpgrContainerFileBlock>(_d + _position, rh.recLen);
    if (rgfb._size != rh.recLen) return;
        _msize = rgfb._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtSolverContainer::OfficeArtSolverContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recType == 0xF005)) {
         return;
    }
    _position += _msize;
    rgfb = MSOArray<OfficeArtSolverContainerFileBlock>(_d + _position, _maxsize - _position);
    if (rgfb._data == 0) return;
        _msize = rgfb._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtFConnectorRule::_size = 32;
MSO::OfficeArtFConnectorRule::OfficeArtFConnectorRule(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 1)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF012)) {
         return;
    }
    if (!(rh.recLen == 0x18)) {
         return;
    }
    _position += _msize;
    ruid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    spidA = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    spidB = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    spidC = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    cptiA = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    cptiB = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtFArcRule::_size = 16;
MSO::OfficeArtFArcRule::OfficeArtFArcRule(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF014)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    ruid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    spid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtFCalloutRule::_size = 16;
MSO::OfficeArtFCalloutRule::OfficeArtFCalloutRule(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF017)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    ruid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    spid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtFSPGR::_size = 24;
MSO::OfficeArtFSPGR::OfficeArtFSPGR(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x1)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0F009)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    xLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    yTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    xRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    yBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtFSP::_size = 16;
MSO::OfficeArtFSP::OfficeArtFSP(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x2)) {
         return;
    }
    if (!(rh.recInstance<= 202)) {
         return;
    }
    if (!(rh.recType == 0x0F00A)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    spid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fGroup = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fChild = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fPatriarch = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fDeleted = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fOleShape = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fHaveMaster = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fFlipH = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fFlipV = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fConnector = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fHaveAnchor = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fBackground = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fHaveSpt = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readuint20_4(_d + _position);
    _msize = 3;
    _position += _msize;
    _data = _d;
}
MSO::OfficeArtFOPT::OfficeArtFOPT(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x3)) {
         return;
    }
    if (!(rh.recType == 0x0F00B)) {
         return;
    }
    _position += _msize;
    fopt = MSOArray<OfficeArtFOPTEChoice>(_d + _position, 6 * rh.recInstance, rh.recInstance);
    if (fopt._count != rh.recInstance) return;
        _msize = fopt._size;
    _position += _msize;
    complexData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-6*rh.recInstance);
    _msize = (rh.recLen-6*rh.recInstance)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtSecondaryFOPT::OfficeArtSecondaryFOPT(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 3)) {
         return;
    }
    if (!(rh.recType == 0xF121)) {
         return;
    }
    _position += _msize;
    fopt = MSOArray<OfficeArtFOPTEChoice>(_d + _position, 6 * rh.recInstance, rh.recInstance);
    if (fopt._count != rh.recInstance) return;
        _msize = fopt._size;
    _position += _msize;
    complexData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-6*rh.recInstance);
    _msize = (rh.recLen-6*rh.recInstance)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtTertiaryFOPT::OfficeArtTertiaryFOPT(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 3)) {
         return;
    }
    if (!(rh.recType == 0xF122)) {
         return;
    }
    _position += _msize;
    fopt = MSOArray<OfficeArtFOPTEChoice>(_d + _position, 6 * rh.recInstance, rh.recInstance);
    if (fopt._count != rh.recInstance) return;
        _msize = fopt._size;
    _position += _msize;
    complexData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-6*rh.recInstance);
    _msize = (rh.recLen-6*rh.recInstance)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::MSOPATHINFO::_size = 2;
MSO::MSOPATHINFO::MSOPATHINFO(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    type = readuint3(_d + _position);
    _msize = 0;
    _position += _msize;
    segments = readuint13_3(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FixedPoint::_size = 4;
MSO::FixedPoint::FixedPoint(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fractional = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    integral = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::PVertices_complex::PVertices_complex(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), (cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems));
    _msize = ((cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PSegmentInfo_complex::PSegmentInfo_complex(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), (cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems));
    _msize = ((cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::FillShadeColors_complex::FillShadeColors_complex(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), (cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems));
    _msize = ((cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PWrapPolygonVertices_complex::PWrapPolygonVertices_complex(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    nElems = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    nElemsAlloc = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cbElem = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), (cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems));
    _msize = ((cbElem==0xFFF0)?(4 * nElems):(cbElem * nElems))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtCOLORREF::_size = 4;
MSO::OfficeArtCOLORREF::OfficeArtCOLORREF(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fPaletteIndex = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fPaletteRGB = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fSystemRGB = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fSchemeIndex = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fSysIndex = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused3 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtChildAnchor::_size = 24;
MSO::OfficeArtChildAnchor::OfficeArtChildAnchor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF00F)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    xLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    yTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    xRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    yBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DocOfficeArtClientAnchor::_size = 12;
MSO::DocOfficeArtClientAnchor::DocOfficeArtClientAnchor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF010)) {
         return;
    }
    if (!(rh.recLen == 0x4)) {
         return;
    }
    _position += _msize;
    clientAnchor = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::XlsOfficeArtClientAnchor::XlsOfficeArtClientAnchor(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF010)) {
         return;
    }
    if (!(rh.recLen == 0x8 || rh.recLen == 0x12)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fMove = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fSize = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    unused = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    _has_width = rh.recLen==0x8;
    if (_has_width) {
        if (_position + 4 > _maxsize) return;
        width = readint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    _has_height = rh.recLen==0x8;
    if (_has_height) {
        if (_position + 4 > _maxsize) return;
        height = readint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    _has_colL = rh.recLen==0x12;
    if (_has_colL) {
        if (_position + 2 > _maxsize) return;
        colL = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_dxL = rh.recLen==0x12;
    if (_has_dxL) {
        if (_position + 2 > _maxsize) return;
        dxL = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_rwT = rh.recLen==0x12;
    if (_has_rwT) {
        if (_position + 2 > _maxsize) return;
        rwT = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_dyT = rh.recLen==0x12;
    if (_has_dyT) {
        if (_position + 2 > _maxsize) return;
        dyT = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_colR = rh.recLen==0x12;
    if (_has_colR) {
        if (_position + 2 > _maxsize) return;
        colR = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_dxR = rh.recLen==0x12;
    if (_has_dxR) {
        if (_position + 2 > _maxsize) return;
        dxR = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_rwB = rh.recLen==0x12;
    if (_has_rwB) {
        if (_position + 2 > _maxsize) return;
        rwB = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_dyB = rh.recLen==0x12;
    if (_has_dyB) {
        if (_position + 2 > _maxsize) return;
        dyB = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtFPSPL::_size = 12;
MSO::OfficeArtFPSPL::OfficeArtFPSPL(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF11D)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    spid = readuint30(_d + _position);
    _msize = 3;
    _position += _msize;
    reserved1 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fLast = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::RectStruct::_size = 16;
MSO::RectStruct::RectStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    top = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    left = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    right = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    bottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::SmallRectStruct::_size = 8;
MSO::SmallRectStruct::SmallRectStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    top = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    left = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    right = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    bottom = readint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DocOfficeArtClientData::_size = 12;
MSO::DocOfficeArtClientData::DocOfficeArtClientData(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF011)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    clientData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::XlsOfficeArtClientData::_size = 8;
MSO::XlsOfficeArtClientData::XlsOfficeArtClientData(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF011)) {
         return;
    }
    if (!(rh.recLen == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::ShapeFlagsAtom::ShapeFlagsAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xBDB)) {
         return;
    }
    if (!(rh.recLen == 1)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ShapeFlags10Atom::ShapeFlags10Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xBDC)) {
         return;
    }
    if (!(rh.recLen == 1)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::ExObjRefAtom::_size = 12;
MSO::ExObjRefAtom::ExObjRefAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xBC1)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    exObjIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::AnimationInfoAtom::_size = 36;
MSO::AnimationInfoAtom::AnimationInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x1)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFF1)) {
         return;
    }
    if (!(rh.recLen == 0x1C)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), 0x1C);
    _msize = (0x1C)*1;
    _position += _msize;
    _data = _d;
}
MSO::SoundContainer::SoundContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x7E6)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::InteractiveInfoAtom::_size = 24;
MSO::InteractiveInfoAtom::InteractiveInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFF2 || rh.recType == 0xFF3)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    soundIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    exHyperlinkIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    action = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)action)<8)) {
         return;
    }
    _position += _msize;
    oleVerb = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)oleVerb)<3)) {
         return;
    }
    _position += _msize;
    jump = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)jump)<7)) {
         return;
    }
    _position += _msize;
    fAnimated = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fStopSound = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fCustomSoundReturn = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fVisited = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    hyperlinkType = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = MSOCastArray<char>((const char*)(_d + _position), 3);
    _msize = (3)*1;
    _position += _msize;
    _data = _d;
}
MSO::MacroNameAtom::MacroNameAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 2)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen%2==0)) {
         return;
    }
    _position += _msize;
    macroName = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::PlaceholderAtom::_size = 16;
MSO::PlaceholderAtom::PlaceholderAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xBC3)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    position = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    placementId = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    size = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::RecolorInfoAtom::RecolorInfoAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFE7)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OutlineTextRefAtom::_size = 12;
MSO::OutlineTextRefAtom::OutlineTextRefAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF9E)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    index = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)index)>=0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::ShapeProgsTagContainer::ShapeProgsTagContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1 || rh.recInstance == 2)) {
         return;
    }
    if (!(rh.recType == 0x1388)) {
         return;
    }
    _position += _msize;
    rgChildRec = MSOArray<ShapeProgTagsSubContainerOrAtom>(_d + _position, _maxsize - _position);
    if (rgChildRec._data == 0) return;
        _msize = rgChildRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP9ShapeBinaryTagExtension::PP9ShapeBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen == 0xE)) {
         return;
    }
    _position += _msize;
    if (_position + 14 > _maxsize) return;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 7);
    _msize = (7)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    styleTextProp9Atom = StyleTextProp9Atom(_d + _position, _maxsize - _position);
    if (styleTextProp9Atom._data == 0) return;
    _msize = styleTextProp9Atom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP10ShapeBinaryTagExtension::PP10ShapeBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rhData.recLen);
    _msize = (rhData.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP11ShapeBinaryTagExtension::PP11ShapeBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), rhData.recLen);
    _msize = (rhData.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::RoundTripNewPlaceHolderId12Atom::_size = 9;
MSO::RoundTripNewPlaceHolderId12Atom::RoundTripNewPlaceHolderId12Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xBDD)) {
         return;
    }
    if (!(rh.recLen == 1)) {
         return;
    }
    _position += _msize;
    newPlaceHolderId = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::RoundTripShapeId12Atom::_size = 12;
MSO::RoundTripShapeId12Atom::RoundTripShapeId12Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x41F)) {
         return;
    }
    if (!(rh.recLen == 4)) {
         return;
    }
    _position += _msize;
    shapeId = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::RoundTripHFPlaceholder12Atom::_size = 9;
MSO::RoundTripHFPlaceholder12Atom::RoundTripHFPlaceholder12Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x420)) {
         return;
    }
    if (!(rh.recLen == 1)) {
         return;
    }
    _position += _msize;
    placeHolderId = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::RoundTripShapeCheckSumForCustomLayouts12Atom::RoundTripShapeCheckSumForCustomLayouts12Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x426)) {
         return;
    }
    if (!(rh.recLen == 8 || rh.recLen == 40)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    shapeCheckSum = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    textCheckSum = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    unknown = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-8);
    _msize = (rh.recLen-8)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::XlsOfficeArtClientTextBox::_size = 8;
MSO::XlsOfficeArtClientTextBox::XlsOfficeArtClientTextBox(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF00D)) {
         return;
    }
    if (!(rh.recLen == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DocOfficeArtClientTextBox::_size = 12;
MSO::DocOfficeArtClientTextBox::DocOfficeArtClientTextBox(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0 || rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF00D)) {
         return;
    }
    if (!(rh.recLen == 0x4)) {
         return;
    }
    _position += _msize;
    clientTextBox = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::PptOfficeArtClientTextBox::PptOfficeArtClientTextBox(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0 || rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF00D)) {
         return;
    }
    if (!(rh.recLen!=4)) {
         return;
    }
    _position += _msize;
    if (_maxsize - _position < rh.recLen) return;
    rgChildRec = MSOArray<TextClientDataSubContainerOrAtom>(_d + _position, rh.recLen);
    if (rgChildRec._size != rh.recLen) return;
        _msize = rgChildRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtIDCL::_size = 8;
MSO::OfficeArtIDCL::OfficeArtIDCL(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    dgid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    cspidCur = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtFOPTEOPID::_size = 2;
MSO::OfficeArtFOPTEOPID::OfficeArtFOPTEOPID(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = readuint14(_d + _position);
    _msize = 1;
    _position += _msize;
    fBid = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fComplex = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::OfficeArtColorMRUContainer::OfficeArtColorMRUContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recType == 0xF11A)) {
         return;
    }
    if (!(rh.recLen==4*rh.recInstance)) {
         return;
    }
    _position += _msize;
    rgmsocr = MSOArray<MSOCR>(_d + _position, 4 * rh.recInstance, rh.recInstance);
    if (rgmsocr._count != rh.recInstance) return;
        _msize = rgmsocr._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::MSOCR::_size = 4;
MSO::MSOCR::MSOCR(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    red = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    green = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    blue = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused1 = readuint3(_d + _position);
    _msize = 0;
    _position += _msize;
    fSchemeIndex = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OfficeArtSplitMenuColorContainer::_size = 24;
MSO::OfficeArtSplitMenuColorContainer::OfficeArtSplitMenuColorContainer(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x4)) {
         return;
    }
    if (!(rh.recType == 0xF11E)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    smca = MSOArray<MSOCR>(_d + _position, 4 * 4, 4);
    if (smca._count != 4) return;
        _msize = smca._size;
    _position += _msize;
    _data = _d;
}
MSO::todo::todo(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    _position += _msize;
    anon = MSOCastArray<char>((const char*)(_d + _position), rh.recLen);
    _msize = (rh.recLen)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::FibBase::_size = 32;
MSO::FibBase::FibBase(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    wIdent = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    nFib = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)nFib) == 0x65 || ((quint16)nFib) == 0x67 || ((quint16)nFib) == 0x68 || ((quint16)nFib) == 0xC0 || ((quint16)nFib) == 0xC1 || ((quint16)nFib) == 0xC2 || ((quint16)nFib) == 0x101 || ((quint16)nFib) == 0x10B || ((quint16)nFib) == 0x10C || ((quint16)nFib) == 0x112)) {
         return;
    }
    _position += _msize;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    lid = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    pnNext = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    fDot = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fGlsy = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fComplex = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fHasPic = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    cQuickSaves = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    fEncrypted = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fWhichTblStm = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fReadOnlyRecommended = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fWriteReservation = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fExtChar = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fLoadOverride = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fFarEast = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fObfuscated = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    nFibBack = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    IKey = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    envr = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fMac = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fEmptySpecial = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fLoadOverridePage = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fSpare0 = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    reserved3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved4 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved5 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved6 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FibRgW97::_size = 28;
MSO::FibRgW97::FibRgW97(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    reserved1 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved2 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved4 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved5 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved6 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved7 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved8 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved9 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved10 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved11 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved12 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    reserved13 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    lidFE = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FibRgLw97::_size = 88;
MSO::FibRgLw97::FibRgLw97(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    cbMac = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    ccpText = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpText)>=0)) {
         return;
    }
    _position += _msize;
    ccpFtn = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpFtn)>=0)) {
         return;
    }
    _position += _msize;
    ccpHdd = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpHdd)>=0)) {
         return;
    }
    _position += _msize;
    reserved3 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved3) == 0)) {
         return;
    }
    _position += _msize;
    ccpAtn = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpAtn)>=0)) {
         return;
    }
    _position += _msize;
    ccpEdn = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpEdn)>=0)) {
         return;
    }
    _position += _msize;
    ccpTxbx = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpTxbx)>=0)) {
         return;
    }
    _position += _msize;
    ccpHdrTxbx = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)ccpHdrTxbx)>=0)) {
         return;
    }
    _position += _msize;
    reserved4 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved5 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved6 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved7 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved8 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved9 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved10 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved11 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved12 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved13 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved13) == 0)) {
         return;
    }
    _position += _msize;
    reserved14 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved14) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FibRgFcLcb97::_size = 744;
MSO::FibRgFcLcb97::FibRgFcLcb97(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fcStshfOrig = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbStshfOrig = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcStshf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbStshf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcffndRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcffndRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcffndTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcffndTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfandRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfandRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfandTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfandTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfSed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfSed = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcPad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcPad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfPhe = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfPhe = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfGlsy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfHdd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfHdd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBteChpx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBteChpx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBtePapx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBtePapx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfSea = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfSea = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfFfn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfFfn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldAtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldAtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcCmds = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbCmds = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfMcr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPrDrvr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPrDrvr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPrEnvPort = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPrEnvPort = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPrEnvLand = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPrEnvLand = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcWss = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbWss = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcDop = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbDop = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfAssoc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfAssoc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcClx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbClx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfPgdFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfPgdFtn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcAutosaveSource = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbAutosaveSource = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcGrpXstAtnOwners = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbGrpXstAtnOwners = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfAtnBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfAtnBkmk = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUnused3 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUnused3 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcSpaMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcSpaMom = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcSpaHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcSpaHdr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfAtnBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfAtnBkf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfAtnBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfAtnBkl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPms = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPms = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcFormFldSttbs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbFormFldSttbs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfendRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfendRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfendTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfendTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldEdn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldEdn = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUnused4 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUnused4 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcDggInfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbDggInfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfRMark = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfRMark = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfAutoCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfAutoCaption = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfWkb = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfWkb = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfSpl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfSpl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcftxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcftxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfFldTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfFldTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfHdrtxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfHdrtxbxTxt = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcffldHdrTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcffldHdrTxbx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcStwUser = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbStwUser = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbTtmbd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbTtmbd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcCookieData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbCookieData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPgdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPgdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcBkdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbBkdMotherOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPgdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPgdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcBkdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbBkdFtnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPgdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPgdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcBkdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbBkdEdnOldOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfIntlFld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfIntlFld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcRouteSlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbRouteSlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbSavedBy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbSavedBy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbFnm = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbFnm = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlfLst = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlfLst = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlfLfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlfLfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfTxbxBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfTxbxBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfTxbxHdrBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfTxbxHdrBkd = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcDocUndoWord9 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbDocUndoWord9 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUskf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUskf = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcupcRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcupcRgbUse = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcupcUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcupcUsp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbGlsyStyle = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbGlsyStyle = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlgosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlgosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcocx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcocx = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBteLvc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBteLvc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    dwLowDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    dwHighDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfLvcPre10 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfLvcPre10 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfAsumy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfAsumy = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfGram = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfGram = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbListNames = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbListNames = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfUssr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfUssr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FibRgFcLcb2000::_size = 120;
MSO::FibRgFcLcb2000::FibRgFcLcb2000(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fcPlcfTch = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfTch = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcRmdThreading = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbRmdThreading = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcMid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbMid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbRgtplc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbRgtplc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcMsoEnvelope = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbMsoEnvelope = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfLad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfLad = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcRgDofr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbRgDofr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcosl = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfCookieOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfCookieOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPgdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPgdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcBkdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbBkdMotherOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPgdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPgdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcBkdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbBkdFtnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPgdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPgdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcBkdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbBkdEdnOld = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FibRgFcLcb2002::_size = 200;
MSO::FibRgFcLcb2002::FibRgFcLcb2002(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fcUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUnused1 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfPgp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfPgp = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfuim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfuim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlfguidUim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlfguidUim = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcAtrdExtra = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbAtrdExtra = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlrsid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlrsid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfBkmkFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfBkmkFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBkfFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBkfFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfcookie = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfcookie = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBklFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBklFactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcFactoidData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbFactoidData = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcDocUndo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbDocUndo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfBkmkFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfBkmkFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBkfFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBkfFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfBklFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfBklFcc = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcSttbfbkmkBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbSttbfbkmkBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfbkfBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfbkfBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfbklBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfbklBPRepairs = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPmsNew = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPmsNew = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcODSO = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbODSO = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfpmiOldXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfpmiOldXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfpmiNewXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfpmiNewXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcfpmiMixedXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcfpmiMixedXP = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbUnused2 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fcPlcffactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    lcbPlcffactoid = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::LPStshi::LPStshi(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    cbSthi = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    stshi = MSOCastArray<char>((const char*)(_d + _position), cbSthi);
    _msize = (cbSthi)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::LPStd::LPStd(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    cbStd = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    std = MSOCastArray<char>((const char*)(_d + _position), cbStd);
    _msize = (cbStd)*1;
    _position += _msize;
    _has_padding = cbStd%2==1;
    if (_has_padding) {
        if (_position + 1 > _maxsize) return;
        padding = readuint8(_d + _position);
        _msize = 1;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::PlcfSed::PlcfSed(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 2);
    _msize = (2)*4;
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    aSed = MSOArray<Sed>(_d + _position, 12 * 1, 1);
    if (aSed._count != 1) return;
        _msize = aSed._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::Sed::_size = 12;
MSO::Sed::Sed(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fn = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    fcSepx = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    fnMpr = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    fcMpr = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Plcfhdd::_size = 52;
MSO::Plcfhdd::Plcfhdd(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 13);
    _msize = (13)*4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PlcBteChpx::_size = 12;
MSO::PlcBteChpx::PlcBteChpx(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 2);
    _msize = (2)*4;
    _position += _msize;
    aPnBteChpx = MSOCastArray<quint32>((const quint32*)(_d + _position), 1);
    _msize = (1)*4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PlcfBtePapx::_size = 12;
MSO::PlcfBtePapx::PlcfBtePapx(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    aCP = MSOCastArray<quint32>((const quint32*)(_d + _position), 2);
    _msize = (2)*4;
    _position += _msize;
    aPnBteChpx = MSOCastArray<quint32>((const quint32*)(_d + _position), 1);
    _msize = (1)*4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Tcg::_size = 12;
MSO::Tcg::Tcg(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    nTcgVer = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)nTcgVer) == 0)) {
         return;
    }
    _position += _msize;
    todo = MSOCastArray<char>((const char*)(_d + _position), 11);
    _msize = (11)*1;
    _position += _msize;
    _data = _d;
}
MSO::PrcData::PrcData(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    cbGrpprl = readint16(_d + _position);
    _msize = 2;
    if (!(((qint16)cbGrpprl)>=0)) {
         return;
    }
    if (!(((qint16)cbGrpprl)<=16290)) {
         return;
    }
    if (!(((qint16)cbGrpprl)%2==0)) {
         return;
    }
    _position += _msize;
    GrpPrl = MSOArray<Sprm>(_d + _position, 2 * cbGrpprl/2, cbGrpprl/2);
    if (GrpPrl._count != cbGrpprl/2) return;
        _msize = GrpPrl._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::Sprm::_size = 2;
MSO::Sprm::Sprm(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    ispmd = readuint9(_d + _position);
    _msize = 1;
    _position += _msize;
    fSpec = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    sgc = readuint3_2(_d + _position);
    _msize = 0;
    _position += _msize;
    spra = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::Pcdt::Pcdt(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 1 > _maxsize) return;
    clxt = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)clxt) == 2)) {
         return;
    }
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    lcb = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    PlcPcd = MSOArray<Pcd>(_d + _position, 8 * lcb/8, lcb/8);
    if (PlcPcd._count != lcb/8) return;
        _msize = PlcPcd._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::FCompressed::_size = 4;
MSO::FCompressed::FCompressed(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fc = readuint30(_d + _position);
    _msize = 3;
    _position += _msize;
    fCompressed = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    r1 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Prm0::_size = 2;
MSO::Prm0::Prm0(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fComplex = readbit(_d + _position);
    _msize = 0;
    if (!(((bool)fComplex) == false)) {
         return;
    }
    _position += _msize;
    isprm = readuint7_1(_d + _position);
    _msize = 1;
    _position += _msize;
    val = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Prm1::_size = 2;
MSO::Prm1::Prm1(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fComplex = readbit(_d + _position);
    _msize = 0;
    if (!(((bool)fComplex) == true)) {
         return;
    }
    _position += _msize;
    igrpprl = readuint15_1(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::SttbfFfn::SttbfFfn(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    cData = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cbExtra = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cbExtra) == 0)) {
         return;
    }
    _position += _msize;
    data = MSOArray<SttbfFfnEntry>(_d + _position, _maxsize - _position, cData);
    if (data._count != cData) return;
        _msize = data._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SttbfFfnEntry::SttbfFfnEntry(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 1 > _maxsize) return;
    cchData = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    Data = MSOCastArray<char>((const char*)(_d + _position), cchData);
    _msize = (cchData)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::CodePageString::CodePageString(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    characters = MSOCastArray<char>((const char*)(_d + _position), 4*(size/4)+((size%4!=0)?4:0));
    _msize = (4*(size/4)+((size%4!=0)?4:0))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::FILETIME::_size = 8;
MSO::FILETIME::FILETIME(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    dwLowDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    dwHighDateTime = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::ClipboardData::ClipboardData(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    format = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    data = MSOCastArray<char>((const char*)(_d + _position), 4*(size/4)+((size%4!=0)?4:0)-4);
    _msize = (4*(size/4)+((size%4!=0)?4:0)-4)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::PropertyIdentifierAndOffset::_size = 8;
MSO::PropertyIdentifierAndOffset::PropertyIdentifierAndOffset(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    propertyIdentifier = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    offset = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::TypedPropertyValue::TypedPropertyValue(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    type = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    padding = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _has_vt_I2 = type==2;
    if (_has_vt_I2) {
        if (_position + 2 > _maxsize) return;
        vt_I2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_paddingI2 = type==2;
    if (_has_paddingI2) {
        if (_position + 2 > _maxsize) return;
        paddingI2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_vg_ERROR = type==10;
    if (_has_vg_ERROR) {
        if (_position + 4 > _maxsize) return;
        vg_ERROR = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    if (type==30) {
        if (_position + 0 > _maxsize) return;
        vt_lpstr = CodePageString(_d + _position, _maxsize - _position);
        if (vt_lpstr._data == 0) return;
        _msize = vt_lpstr._size;
        _position += _msize;
    }
    if (type==64) {
        if (_position + 8 > _maxsize) return;
        vg_FILETIME = FILETIME(_d + _position);
        if (vg_FILETIME._data == 0) return;
        _msize = vg_FILETIME._size;
        _position += _msize;
    }
    if (type==71) {
        if (_position + 0 > _maxsize) return;
        vg_CF = ClipboardData(_d + _position, _maxsize - _position);
        if (vg_CF._data == 0) return;
        _msize = vg_CF._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::PropertySet::PropertySet(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    numProperties = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    propertyIdentifierAndOffset = MSOArray<PropertyIdentifierAndOffset>(_d + _position, 8 * numProperties, numProperties);
    if (propertyIdentifierAndOffset._count != numProperties) return;
        _msize = propertyIdentifierAndOffset._size;
    _position += _msize;
    property = MSOArray<TypedPropertyValue>(_d + _position, _maxsize - _position, numProperties);
    if (property._count != numProperties) return;
        _msize = property._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PropertySetStream::PropertySetStream(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 2 > _maxsize) return;
    byteOrder = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)byteOrder) == 0xFFFE)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    version = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    systemIdentifier = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    clsID = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    numPropertySets = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)numPropertySets) == 1 || ((quint32)numPropertySets) == 2)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    fmtID0 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    offset0 = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _has_fmtID1 = numPropertySets==2;
    if (_has_fmtID1) {
        if (_position + 16 > _maxsize) return;
        fmtID1 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    _has_offset1 = numPropertySets==2;
    if (_has_offset1) {
        if (_position + 4 > _maxsize) return;
        offset1 = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    propertySet1 = PropertySet(_d + _position, _maxsize - _position);
    if (propertySet1._data == 0) return;
    _msize = propertySet1._size;
    _position += _msize;
    if (numPropertySets==2) {
        if (_position + 0 > _maxsize) return;
        propertySet2 = PropertySet(_d + _position, _maxsize - _position);
        if (propertySet2._data == 0) return;
        _msize = propertySet2._size;
        _position += _msize;
    }
    padding = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (padding._data == 0) return;
        _msize = padding._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SummaryInformationPropertySetStream::SummaryInformationPropertySetStream(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    propertySet = PropertySetStream(_d + _position, _maxsize - _position);
    if (propertySet._data == 0) return;
    _msize = propertySet._size;
    if (!(propertySet.version == 0)) {
         return;
    }
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::DocumentSummaryInformationPropertySetStream::DocumentSummaryInformationPropertySetStream(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    propertySet = PropertySetStream(_d + _position, _maxsize - _position);
    if (propertySet._data == 0) return;
    _msize = propertySet._size;
    if (!(propertySet.version == 0)) {
         return;
    }
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PicturesStream::PicturesStream(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon1 = OfficeArtBStoreDelay(_d + _position, _maxsize - _position);
    if (anon1._data == 0) return;
    _msize = anon1._size;
    _position += _msize;
    trailing = MSOArray<Byte>(_d + _position, _maxsize - _position);
    if (trailing._data == 0) return;
        _msize = trailing._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtMetafileHeader::_size = 34;
MSO::OfficeArtMetafileHeader::OfficeArtMetafileHeader(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    cbSize = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    rcBounds = RECT(_d + _position);
    if (rcBounds._data == 0) return;
    _msize = rcBounds._size;
    _position += _msize;
    ptSize = POINT(_d + _position);
    if (ptSize._data == 0) return;
    _msize = ptSize._size;
    _position += _msize;
    cbsave = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    compression = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    filter = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::SoundCollectionContainer::SoundCollectionContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 5)) {
         return;
    }
    if (!(rh.recType == 0x7E4)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    soundCollectionAtom = SoundCollectionAtom(_d + _position);
    if (soundCollectionAtom._data == 0) return;
    _msize = soundCollectionAtom._size;
    _position += _msize;
    if (_maxsize - _position < rh.recLen-12) return;
    rgSoundContainer = MSOArray<SoundContainer>(_d + _position, rh.recLen-12);
    if (rgSoundContainer._size != rh.recLen-12) return;
        _msize = rgSoundContainer._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SlideHeadersFootersContainer::SlideHeadersFootersContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 3)) {
         return;
    }
    if (!(rh.recType == 0xFD9)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    hfAtom = HeadersFootersAtom(_d + _position);
    if (hfAtom._data == 0) return;
    _msize = hfAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        userDateAtom = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (userDateAtom._data) ?userDateAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        footerAtom = FooterAtom(_d + _position, _maxsize - _position);
        _msize = (footerAtom._data) ?footerAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::NotesHeadersFootersContainer::NotesHeadersFootersContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 4)) {
         return;
    }
    if (!(rh.recType == 0xFD9)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    hfAtom = HeadersFootersAtom(_d + _position);
    if (hfAtom._data == 0) return;
    _msize = hfAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        userDateAtom = UserDateAtom(_d + _position, _maxsize - _position);
        _msize = (userDateAtom._data) ?userDateAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        headerAtom = HeaderAtom(_d + _position, _maxsize - _position);
        _msize = (headerAtom._data) ?headerAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        footerAtom = FooterAtom(_d + _position, _maxsize - _position);
        _msize = (footerAtom._data) ?footerAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
const quint32 MSO::ScalingStruct::_size = 16;
MSO::ScalingStruct::ScalingStruct(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    x = RatioStruct(_d + _position);
    if (x._data == 0) return;
    _msize = x._size;
    _position += _msize;
    y = RatioStruct(_d + _position);
    if (y._data == 0) return;
    _msize = y._size;
    _position += _msize;
    _data = _d;
}
MSO::TextPFException9::TextPFException9(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    masks = PFMasks(_d + _position);
    if (masks._data == 0) return;
    _msize = masks._size;
    if (!(masks.hasBullet == false)) {
         return;
    }
    if (!(masks.bulletHasFont == false)) {
         return;
    }
    if (!(masks.bulletHasColor == false)) {
         return;
    }
    if (!(masks.bulletHasSize == false)) {
         return;
    }
    if (!(masks.bulletFont == false)) {
         return;
    }
    if (!(masks.bulletColor == false)) {
         return;
    }
    if (!(masks.bulletSize == false)) {
         return;
    }
    if (!(masks.bulletChar == false)) {
         return;
    }
    if (!(masks.leftMargin == false)) {
         return;
    }
    if (!(masks.indent == false)) {
         return;
    }
    if (!(masks.align == false)) {
         return;
    }
    if (!(masks.lineSpacing == false)) {
         return;
    }
    if (!(masks.spaceBefore == false)) {
         return;
    }
    if (!(masks.spaceAfter == false)) {
         return;
    }
    if (!(masks.defaultTabSize == false)) {
         return;
    }
    if (!(masks.fontAlign == false)) {
         return;
    }
    if (!(masks.charWrap == false)) {
         return;
    }
    if (!(masks.wordWrap == false)) {
         return;
    }
    if (!(masks.overflow == false)) {
         return;
    }
    if (!(masks.tabStops == false)) {
         return;
    }
    if (!(masks.textDirection == false)) {
         return;
    }
    _position += _msize;
    _has_bulletBlipRef = masks.bulletBlip;
    if (_has_bulletBlipRef) {
        if (_position + 2 > _maxsize) return;
        bulletBlipRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_fBulletHasAutoNumber = masks.bulletHasScheme;
    if (_has_fBulletHasAutoNumber) {
        if (_position + 2 > _maxsize) return;
        fBulletHasAutoNumber = readuint16(_d + _position);
        _msize = 2;
        if (!(((quint16)fBulletHasAutoNumber) == 0 || ((quint16)fBulletHasAutoNumber) == 1)) {
             return;
        }
        _position += _msize;
    }
    if (masks.bulletScheme) {
        if (_position + 4 > _maxsize) return;
        bulletAutoNumberScheme = TextAutoNumberScheme(_d + _position);
        if (bulletAutoNumberScheme._data == 0) return;
        _msize = bulletAutoNumberScheme._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextCFException9::TextCFException9(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    masks = CFMasks(_d + _position);
    if (masks._data == 0) return;
    _msize = masks._size;
    if (!(masks.bold == false)) {
         return;
    }
    if (!(masks.italic == false)) {
         return;
    }
    if (!(masks.underline == false)) {
         return;
    }
    if (!(masks.shadow == false)) {
         return;
    }
    if (!(masks.fehint == false)) {
         return;
    }
    if (!(masks.kumi == false)) {
         return;
    }
    if (!(masks.emboss == false)) {
         return;
    }
    if (!(masks.reserved == 0)) {
         return;
    }
    if (!(masks.typeface == false)) {
         return;
    }
    if (!(masks.size == false)) {
         return;
    }
    if (!(masks.color == false)) {
         return;
    }
    if (!(masks.position == false)) {
         return;
    }
    if (!(masks.oldEATypeface == false)) {
         return;
    }
    if (!(masks.ansiTypeface == false)) {
         return;
    }
    if (!(masks.symbolTypeface == false)) {
         return;
    }
    if (!(masks.newEATypeface == false)) {
         return;
    }
    if (!(masks.csTypeface == false)) {
         return;
    }
    if (!(masks.pp11ext == false)) {
         return;
    }
    _position += _msize;
    _has_pp10runid = masks.pp10ext;
    if (_has_pp10runid) {
        if (_position + 0 > _maxsize) return;
        pp10runid = readuint4(_d + _position);
        _msize = 0;
        _position += _msize;
    }
    _has_unuseda = masks.pp10ext;
    if (_has_unuseda) {
        if (_position + 2 > _maxsize) return;
        unuseda = readuint20_4(_d + _position);
        _msize = 3;
        _position += _msize;
    }
    _has_unusedb = masks.pp10ext;
    if (_has_unusedb) {
        if (_position + 1 > _maxsize) return;
        unusedb = readuint8(_d + _position);
        _msize = 1;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextDefaults9Atom::TextDefaults9Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x00)) {
         return;
    }
    if (!(rh.recType == 0x0FB0)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf9 = TextCFException9(_d + _position, _maxsize - _position);
    if (cf9._data == 0) return;
    _msize = cf9._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    pf9 = TextPFException9(_d + _position, _maxsize - _position);
    if (pf9._data == 0) return;
    _msize = pf9._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::Kinsoku9Container::Kinsoku9Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x2)) {
         return;
    }
    if (!(rh.recType == 0x0FC8)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    kinsoku9Atom = Kinsoku9Atom(_d + _position);
    if (kinsoku9Atom._data == 0) return;
    _msize = kinsoku9Atom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        kinsokuLeadingAtom = KinsokuLeadingAtom(_d + _position, _maxsize - _position);
        _msize = (kinsokuLeadingAtom._data) ?kinsokuLeadingAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        kinsokuFollowingAtom = KinsokuFollowingAtom(_d + _position, _maxsize - _position);
        _msize = (kinsokuFollowingAtom._data) ?kinsokuFollowingAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::OutlineTextProps9Entry::OutlineTextProps9Entry(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 16 > _maxsize) return;
    outlineTextHeaderAtom = OutlineTextPropsHeaderExAtom(_d + _position);
    if (outlineTextHeaderAtom._data == 0) return;
    _msize = outlineTextHeaderAtom._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    styleTextProp9Atom = StyleTextProp9Atom(_d + _position, _maxsize - _position);
    if (styleTextProp9Atom._data == 0) return;
    _msize = styleTextProp9Atom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextCFException10::TextCFException10(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    masks = CFMasks(_d + _position);
    if (masks._data == 0) return;
    _msize = masks._size;
    if (!(masks.bold == false)) {
         return;
    }
    if (!(masks.italic == false)) {
         return;
    }
    if (!(masks.underline == false)) {
         return;
    }
    if (!(masks.shadow == false)) {
         return;
    }
    if (!(masks.fehint == false)) {
         return;
    }
    if (!(masks.kumi == false)) {
         return;
    }
    if (!(masks.emboss == false)) {
         return;
    }
    if (!(masks.reserved == 0)) {
         return;
    }
    if (!(masks.typeface == false)) {
         return;
    }
    if (!(masks.size == false)) {
         return;
    }
    if (!(masks.color == false)) {
         return;
    }
    if (!(masks.position == false)) {
         return;
    }
    if (!(masks.pp10ext == false)) {
         return;
    }
    if (!(masks.oldEATypeface == false)) {
         return;
    }
    if (!(masks.ansiTypeface == false)) {
         return;
    }
    if (!(masks.symbolTypeface == false)) {
         return;
    }
    _position += _msize;
    _has_newEAFontRef = masks.newEATypeface;
    if (_has_newEAFontRef) {
        if (_position + 2 > _maxsize) return;
        newEAFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_csFontRef = masks.csTypeface;
    if (_has_csFontRef) {
        if (_position + 2 > _maxsize) return;
        csFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_pp11ext = masks.pp11ext;
    if (_has_pp11ext) {
        if (_position + 4 > _maxsize) return;
        pp11ext = readuint32(_d + _position);
        _msize = 4;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextDefaults10Atom::TextDefaults10Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FB4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf10 = TextCFException10(_d + _position, _maxsize - _position);
    if (cf10._data == 0) return;
    _msize = cf10._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::CommentIndex10Container::CommentIndex10Container(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x2EE4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        authorNameAtom = AuthorNameAtom(_d + _position, _maxsize - _position);
        _msize = (authorNameAtom._data) ?authorNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 16 <= _maxsize) {
        authorIndexAtom = CommentIndex10Atom(_d + _position);
        _msize = (authorIndexAtom._data) ?authorIndexAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::OutlineTextProps10Entry::OutlineTextProps10Entry(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 16 > _maxsize) return;
    outlineTextHeaderAtom = OutlineTextPropsHeaderExAtom(_d + _position);
    if (outlineTextHeaderAtom._data == 0) return;
    _msize = outlineTextHeaderAtom._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    styleTextProp10Atom = StyleTextProp10Atom(_d + _position, _maxsize - _position);
    if (styleTextProp10Atom._data == 0) return;
    _msize = styleTextProp10Atom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP11DocBinaryTagExtension::PP11DocBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0x0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    smartTagStore11 = SmartTagStore11Container(_d + _position, _maxsize - _position);
    if (smartTagStore11._data == 0) return;
    _msize = smartTagStore11._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    outlineTextProps = OutlineTextProps11Container(_d + _position, _maxsize - _position);
    if (outlineTextProps._data == 0) return;
    _msize = outlineTextProps._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::UnknownBinaryTag::UnknownBinaryTag(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    tagNameAtom = TagNameAtom(_d + _position, _maxsize - _position);
    if (tagNameAtom._data == 0) return;
    _msize = tagNameAtom._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    tagData = BinaryTagDataBlob(_d + _position, _maxsize - _position);
    if (tagData._data == 0) return;
    _msize = tagData._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::NoZoomViewInfoAtom::_size = 60;
MSO::NoZoomViewInfoAtom::NoZoomViewInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3FD)) {
         return;
    }
    if (!(rh.recLen == 0x34)) {
         return;
    }
    _position += _msize;
    curScale = ScalingStruct(_d + _position);
    if (curScale._data == 0) return;
    _msize = curScale._size;
    _position += _msize;
    unused1 = MSOCastArray<char>((const char*)(_d + _position), 24);
    _msize = (24)*1;
    _position += _msize;
    origin = PointStruct(_d + _position);
    if (origin._data == 0) return;
    _msize = origin._size;
    _position += _msize;
    unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fDraftMode = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused3 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::VBAInfoContainer::_size = 28;
MSO::VBAInfoContainer::VBAInfoContainer(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x3FF)) {
         return;
    }
    if (!(rh.recLen == 0x14)) {
         return;
    }
    _position += _msize;
    vbaInfoAtom = VBAInfoAtom(_d + _position);
    if (vbaInfoAtom._data == 0) return;
    _msize = vbaInfoAtom._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::NormalViewSetInfoAtom::_size = 28;
MSO::NormalViewSetInfoAtom::NormalViewSetInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x415)) {
         return;
    }
    if (!(rh.recLen == 0x14)) {
         return;
    }
    _position += _msize;
    leftPortion = RatioStruct(_d + _position);
    if (leftPortion._data == 0) return;
    _msize = leftPortion._size;
    _position += _msize;
    topPortion = RatioStruct(_d + _position);
    if (topPortion._data == 0) return;
    _msize = topPortion._size;
    _position += _msize;
    vertBarState = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    horizBarState = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fPreferSingleSet = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)fPreferSingleSet) == 0 || ((quint8)fPreferSingleSet) == 1)) {
         return;
    }
    _position += _msize;
    fHideThumbnails = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fBarSnapped = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved = readuint6_2(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::TextContainer::TextContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 12 > _maxsize) return;
    textHeaderAtom = TextHeaderAtom(_d + _position);
    if (textHeaderAtom._data == 0) return;
    _msize = textHeaderAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        text._TextCharsAtom = TextCharsAtom(_d + _position, _maxsize - _position);
        _msize = text._TextCharsAtom._size;
        if (_msize == 0) {
            text._TextBytesAtom = TextBytesAtom(_d + _position, _maxsize - _position);
            _msize = text._TextBytesAtom._size;
        }
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        style = StyleTextPropAtom(_d + _position, _maxsize - _position);
        _msize = (style._data) ?style._size :0;
        _position += _msize;
    }
    meta = MSOArray<TextContainerMeta>(_d + _position, _maxsize - _position);
    if (meta._data == 0) return;
        _msize = meta._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        master = MasterTextPropAtom(_d + _position, _maxsize - _position);
        _msize = (master._data) ?master._size :0;
        _position += _msize;
    }
    bookmark = MSOArray<TextBookmarkAtom>(_d + _position, _maxsize - _position);
    if (bookmark._data == 0) return;
        _msize = bookmark._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        unknown = UnknownTextContainerChild(_d + _position, _maxsize - _position);
        _msize = (unknown._data) ?unknown._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        specialinfo = TextSpecialInfoAtom(_d + _position, _maxsize - _position);
        _msize = (specialinfo._data) ?specialinfo._size :0;
        _position += _msize;
    }
    interactive = MSOArray<TextContainerInteractiveInfo>(_d + _position, _maxsize - _position);
    if (interactive._data == 0) return;
        _msize = interactive._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        specialinfo2 = TextSpecialInfoAtom(_d + _position, _maxsize - _position);
        _msize = (specialinfo2._data) ?specialinfo2._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const TextCharsAtom* TextContainer::C_text::get<TextCharsAtom>() const {
        return &_TextCharsAtom;
    }
    template <> bool TextContainer::C_text::is<TextCharsAtom>() const {
        return _TextCharsAtom._data;
    }
    template <> const TextBytesAtom* TextContainer::C_text::get<TextBytesAtom>() const {
        return &_TextBytesAtom;
    }
    template <> bool TextContainer::C_text::is<TextBytesAtom>() const {
        return _TextBytesAtom._data;
    }
}
MSO::TextContainerMeta::TextContainerMeta(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    meta._SlideNumberMCAtom = SlideNumberMCAtom(_d + _position);
    _msize = (meta._SlideNumberMCAtom._data) ?SlideNumberMCAtom::_size : 0;
    if (_msize == 0) {
        meta._DateTimeMCAtom = DateTimeMCAtom(_d + _position);
        _msize = (meta._DateTimeMCAtom._data) ?DateTimeMCAtom::_size : 0;
    }
    if (_msize == 0) {
        meta._GenericDateMCAtom = GenericDateMCAtom(_d + _position);
        _msize = (meta._GenericDateMCAtom._data) ?GenericDateMCAtom::_size : 0;
    }
    if (_msize == 0) {
        meta._HeaderMCAtom = HeaderMCAtom(_d + _position);
        _msize = (meta._HeaderMCAtom._data) ?HeaderMCAtom::_size : 0;
    }
    if (_msize == 0) {
        meta._FooterMCAtom = FooterMCAtom(_d + _position);
        _msize = (meta._FooterMCAtom._data) ?FooterMCAtom::_size : 0;
    }
    if (_msize == 0) {
        meta._RTFDateTimeMCAtom = RTFDateTimeMCAtom(_d + _position);
        _msize = (meta._RTFDateTimeMCAtom._data) ?RTFDateTimeMCAtom::_size : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const SlideNumberMCAtom* TextContainerMeta::C_meta::get<SlideNumberMCAtom>() const {
        return &_SlideNumberMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<SlideNumberMCAtom>() const {
        return _SlideNumberMCAtom._data;
    }
    template <> const DateTimeMCAtom* TextContainerMeta::C_meta::get<DateTimeMCAtom>() const {
        return &_DateTimeMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<DateTimeMCAtom>() const {
        return _DateTimeMCAtom._data;
    }
    template <> const GenericDateMCAtom* TextContainerMeta::C_meta::get<GenericDateMCAtom>() const {
        return &_GenericDateMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<GenericDateMCAtom>() const {
        return _GenericDateMCAtom._data;
    }
    template <> const HeaderMCAtom* TextContainerMeta::C_meta::get<HeaderMCAtom>() const {
        return &_HeaderMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<HeaderMCAtom>() const {
        return _HeaderMCAtom._data;
    }
    template <> const FooterMCAtom* TextContainerMeta::C_meta::get<FooterMCAtom>() const {
        return &_FooterMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<FooterMCAtom>() const {
        return _FooterMCAtom._data;
    }
    template <> const RTFDateTimeMCAtom* TextContainerMeta::C_meta::get<RTFDateTimeMCAtom>() const {
        return &_RTFDateTimeMCAtom;
    }
    template <> bool TextContainerMeta::C_meta::is<RTFDateTimeMCAtom>() const {
        return _RTFDateTimeMCAtom._data;
    }
}
const quint32 MSO::SlidePersistAtom::_size = 28;
MSO::SlidePersistAtom::SlidePersistAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3F3)) {
         return;
    }
    if (!(rh.recLen == 0x14)) {
         return;
    }
    _position += _msize;
    persistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    reserved1 = readbit(_d + _position);
    _msize = 0;
    if (!(((bool)reserved1) == false)) {
         return;
    }
    _position += _msize;
    fShouldCollapse = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fNonOutlineData = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved2 = readuint5_3(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved2) == 0)) {
         return;
    }
    _position += _msize;
    reserved3 = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)reserved3) == 0)) {
         return;
    }
    _position += _msize;
    reserved4 = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)reserved4) == 0)) {
         return;
    }
    _position += _msize;
    cTexts = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)cTexts)>=0)) {
         return;
    }
    if (!(((qint32)cTexts)<=8)) {
         return;
    }
    _position += _msize;
    slideId = SlideId(_d + _position);
    if (slideId._data == 0) return;
    _msize = slideId._size;
    _position += _msize;
    reserved5 = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)reserved5) == 0)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
MSO::TextRuler::TextRuler(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    fDefaultTabSize = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fCLevels = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fTabStops = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fLeftMargin1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fLeftMargin2 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fLeftMargin3 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fLeftMargin4 = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fLeftMargin5 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fIndent1 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fIndent2 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fIndent3 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fIndent4 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fIndent5 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    reserved1 = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    reserved2 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _has_cLevels = fCLevels;
    if (_has_cLevels) {
        if (_position + 2 > _maxsize) return;
        cLevels = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_defaultTabSize = fDefaultTabSize;
    if (_has_defaultTabSize) {
        if (_position + 2 > _maxsize) return;
        defaultTabSize = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (fTabStops) {
        if (_position + 0 > _maxsize) return;
        tabs = TabStops(_d + _position, _maxsize - _position);
        if (tabs._data == 0) return;
        _msize = tabs._size;
        _position += _msize;
    }
    _has_leftMargin1 = fLeftMargin1;
    if (_has_leftMargin1) {
        if (_position + 2 > _maxsize) return;
        leftMargin1 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_indent1 = fIndent1;
    if (_has_indent1) {
        if (_position + 2 > _maxsize) return;
        indent1 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_leftMargin2 = fLeftMargin2;
    if (_has_leftMargin2) {
        if (_position + 2 > _maxsize) return;
        leftMargin2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_indent2 = fIndent2;
    if (_has_indent2) {
        if (_position + 2 > _maxsize) return;
        indent2 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_leftMargin3 = fLeftMargin3;
    if (_has_leftMargin3) {
        if (_position + 2 > _maxsize) return;
        leftMargin3 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_indent3 = fIndent3;
    if (_has_indent3) {
        if (_position + 2 > _maxsize) return;
        indent3 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_leftMargin4 = fLeftMargin4;
    if (_has_leftMargin4) {
        if (_position + 2 > _maxsize) return;
        leftMargin4 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_indent4 = fIndent4;
    if (_has_indent4) {
        if (_position + 2 > _maxsize) return;
        indent4 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_leftMargin5 = fLeftMargin5;
    if (_has_leftMargin5) {
        if (_position + 2 > _maxsize) return;
        leftMargin5 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_indent5 = fIndent5;
    if (_has_indent5) {
        if (_position + 2 > _maxsize) return;
        indent5 = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextPFException::TextPFException(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    masks = PFMasks(_d + _position);
    if (masks._data == 0) return;
    _msize = masks._size;
    if (!(masks.bulletBlip == false)) {
         return;
    }
    if (!(masks.bulletHasScheme == false)) {
         return;
    }
    if (!(masks.bulletScheme == false)) {
         return;
    }
    _position += _msize;
    if (masks.hasBullet||masks.bulletHasFont||masks.bulletHasColor||masks.bulletHasSize) {
        if (_position + 2 > _maxsize) return;
        bulletFlags = BulletFlags(_d + _position);
        if (bulletFlags._data == 0) return;
        _msize = bulletFlags._size;
        _position += _msize;
    }
    _has_bulletChar = masks.bulletChar;
    if (_has_bulletChar) {
        if (_position + 2 > _maxsize) return;
        bulletChar = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_bulletFontRef = masks.bulletFont;
    if (_has_bulletFontRef) {
        if (_position + 2 > _maxsize) return;
        bulletFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_bulletSize = masks.bulletSize;
    if (_has_bulletSize) {
        if (_position + 2 > _maxsize) return;
        bulletSize = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (masks.bulletColor) {
        if (_position + 4 > _maxsize) return;
        bulletColor = ColorIndexStruct(_d + _position);
        if (bulletColor._data == 0) return;
        _msize = bulletColor._size;
        _position += _msize;
    }
    _has_textAlignment = masks.align;
    if (_has_textAlignment) {
        if (_position + 2 > _maxsize) return;
        textAlignment = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_lineSpacing = masks.lineSpacing;
    if (_has_lineSpacing) {
        if (_position + 2 > _maxsize) return;
        lineSpacing = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_spaceBefore = masks.spaceBefore;
    if (_has_spaceBefore) {
        if (_position + 2 > _maxsize) return;
        spaceBefore = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_spaceAfter = masks.spaceAfter;
    if (_has_spaceAfter) {
        if (_position + 2 > _maxsize) return;
        spaceAfter = readint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_leftMargin = masks.leftMargin;
    if (_has_leftMargin) {
        if (_position + 2 > _maxsize) return;
        leftMargin = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_indent = masks.indent;
    if (_has_indent) {
        if (_position + 2 > _maxsize) return;
        indent = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_defaultTabSize = masks.defaultTabSize;
    if (_has_defaultTabSize) {
        if (_position + 2 > _maxsize) return;
        defaultTabSize = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (masks.tabStops) {
        if (_position + 0 > _maxsize) return;
        tabStops = TabStops(_d + _position, _maxsize - _position);
        if (tabStops._data == 0) return;
        _msize = tabStops._size;
        _position += _msize;
    }
    _has_fontAlign = masks.fontAlign;
    if (_has_fontAlign) {
        if (_position + 2 > _maxsize) return;
        fontAlign = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (masks.charWrap||masks.wordWrap||masks.overflow) {
        if (_position + 2 > _maxsize) return;
        wrapFlags = PFWrapFlags(_d + _position);
        if (wrapFlags._data == 0) return;
        _msize = wrapFlags._size;
        _position += _msize;
    }
    _has_textDirection = masks.textDirection;
    if (_has_textDirection) {
        if (_position + 2 > _maxsize) return;
        textDirection = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextCFException::TextCFException(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    masks = CFMasks(_d + _position);
    if (masks._data == 0) return;
    _msize = masks._size;
    if (!(masks.pp10ext == false)) {
         return;
    }
    if (!(masks.newEATypeface == false)) {
         return;
    }
    if (!(masks.csTypeface == false)) {
         return;
    }
    if (!(masks.pp11ext == false)) {
         return;
    }
    _position += _msize;
    if (masks.bold || masks.italic || masks.underline || masks.shadow || masks.fehint || masks.kumi || masks.emboss || masks.fHasStyle != 0) {
        if (_position + 2 > _maxsize) return;
        fontStyle = CFStyle(_d + _position);
        if (fontStyle._data == 0) return;
        _msize = fontStyle._size;
        _position += _msize;
    }
    _has_fontRef = masks.typeface;
    if (_has_fontRef) {
        if (_position + 2 > _maxsize) return;
        fontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_oldEAFontRef = masks.oldEATypeface;
    if (_has_oldEAFontRef) {
        if (_position + 2 > _maxsize) return;
        oldEAFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_ansiFontRef = masks.ansiTypeface;
    if (_has_ansiFontRef) {
        if (_position + 2 > _maxsize) return;
        ansiFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_symbolFontRef = masks.symbolTypeface;
    if (_has_symbolFontRef) {
        if (_position + 2 > _maxsize) return;
        symbolFontRef = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_fontSize = masks.size;
    if (_has_fontSize) {
        if (_position + 2 > _maxsize) return;
        fontSize = readuint16(_d + _position);
        _msize = 2;
        if (!(((quint16)fontSize)>=1)) {
             return;
        }
        if (!(((quint16)fontSize)<=4000)) {
             return;
        }
        _position += _msize;
    }
    if (masks.color) {
        if (_position + 4 > _maxsize) return;
        color = ColorIndexStruct(_d + _position);
        if (color._data == 0) return;
        _msize = color._size;
        _position += _msize;
    }
    _has_position = masks.position;
    if (_has_position) {
        if (_position + 2 > _maxsize) return;
        position = readint16(_d + _position);
        _msize = 2;
        if (!(((qint16)position)>=-100)) {
             return;
        }
        if (!(((qint16)position)<=100)) {
             return;
        }
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::FontCollectionEntry::FontCollectionEntry(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 76 > _maxsize) return;
    fontEntityAtom = FontEntityAtom(_d + _position);
    if (fontEntityAtom._data == 0) return;
    _msize = fontEntityAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        fontEmbedData1 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (fontEmbedData1._data) ?fontEmbedData1._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        fontEmbedData2 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (fontEmbedData2._data) ?fontEmbedData2._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        fontEmbedData3 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (fontEmbedData3._data) ?fontEmbedData3._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        fontEmbedData4 = FontEmbedDataBlob(_d + _position, _maxsize - _position);
        _msize = (fontEmbedData4._data) ?fontEmbedData4._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::KinsokuContainer::KinsokuContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x2)) {
         return;
    }
    if (!(rh.recType == 0x0FC8)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    kinsokuAtom = KinsokuAtom(_d + _position);
    if (kinsokuAtom._data == 0) return;
    _msize = kinsokuAtom._size;
    _position += _msize;
    if (kinsokuAtom.level==2) {
        if (_position + 0 > _maxsize) return;
        kinsokuLeadingAtom = KinsokuLeadingAtom(_d + _position, _maxsize - _position);
        if (kinsokuLeadingAtom._data == 0) return;
        _msize = kinsokuLeadingAtom._size;
        _position += _msize;
    }
    if (kinsokuAtom.level==2) {
        if (_position + 0 > _maxsize) return;
        kinsokuFollowingAtom = KinsokuFollowingAtom(_d + _position, _maxsize - _position);
        if (kinsokuFollowingAtom._data == 0) return;
        _msize = kinsokuFollowingAtom._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextSIException::TextSIException(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    spell = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    lang = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    altLang = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    unused1 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    unused2 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fPp10ext = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    fBidi = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    unused3 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    reserved1 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    smartTag = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    reserved2a = readuint2_2(_d + _position);
    _msize = 0;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    reserved2b = readuint20_4(_d + _position);
    _msize = 3;
    _position += _msize;
    _has_spellInfo = spell;
    if (_has_spellInfo) {
        if (_position + 2 > _maxsize) return;
        spellInfo = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_lid = lang;
    if (_has_lid) {
        if (_position + 2 > _maxsize) return;
        lid = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_altLid = altLang;
    if (_has_altLid) {
        if (_position + 2 > _maxsize) return;
        altLid = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_bidi = fBidi;
    if (_has_bidi) {
        if (_position + 2 > _maxsize) return;
        bidi = readint16(_d + _position);
        _msize = 2;
        if (!(((qint16)bidi) == 0 || ((qint16)bidi) == 1)) {
             return;
        }
        _position += _msize;
    }
    _has_pp10runid = fPp10ext;
    if (_has_pp10runid) {
        if (_position + 0 > _maxsize) return;
        pp10runid = readuint4(_d + _position);
        _msize = 0;
        _position += _msize;
    }
    _has_reserved3a = fPp10ext;
    if (_has_reserved3a) {
        if (_position + 0 > _maxsize) return;
        reserved3a = readuint4_4(_d + _position);
        _msize = 1;
        _position += _msize;
    }
    _has_reserved3b = fPp10ext;
    if (_has_reserved3b) {
        if (_position + 2 > _maxsize) return;
        reserved3b = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    _has_reserved3bc = fPp10ext;
    if (_has_reserved3bc) {
        if (_position + 0 > _maxsize) return;
        reserved3bc = readuint7(_d + _position);
        _msize = 0;
        _position += _msize;
    }
    _has_grammarError = fPp10ext;
    if (_has_grammarError) {
        if (_position + 0 > _maxsize) return;
        grammarError = readbit_7(_d + _position);
        _msize = 1;
        _position += _msize;
    }
    if (smartTag) {
        if (_position + 0 > _maxsize) return;
        smartTags = SmartTags(_d + _position, _maxsize - _position);
        if (smartTags._data == 0) return;
        _msize = smartTags._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextMasterStyleLevel::TextMasterStyleLevel(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    pf = TextPFException(_d + _position, _maxsize - _position);
    if (pf._data == 0) return;
    _msize = pf._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf = TextCFException(_d + _position, _maxsize - _position);
    if (cf._data == 0) return;
    _msize = cf._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::DocumentAtom::_size = 48;
MSO::DocumentAtom::DocumentAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 1)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x03E9)) {
         return;
    }
    if (!(rh.recLen == 0x28)) {
         return;
    }
    _position += _msize;
    slideSize = PointStruct(_d + _position);
    if (slideSize._data == 0) return;
    _msize = slideSize._size;
    _position += _msize;
    notesSize = PointStruct(_d + _position);
    if (notesSize._data == 0) return;
    _msize = notesSize._size;
    _position += _msize;
    serverZoom = RatioStruct(_d + _position);
    if (serverZoom._data == 0) return;
    _msize = serverZoom._size;
    if (!(serverZoom.numer*serverZoom.denom > 0)) {
         return;
    }
    _position += _msize;
    notesMasterPersistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    handoutMasterPersistIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    firstSlideNumber = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)firstSlideNumber)<10000)) {
         return;
    }
    _position += _msize;
    slideSizeType = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)slideSizeType) == 0 || ((quint16)slideSizeType) == 1 || ((quint16)slideSizeType) == 2 || ((quint16)slideSizeType) == 3 || ((quint16)slideSizeType) == 4 || ((quint16)slideSizeType) == 5 || ((quint16)slideSizeType) == 6)) {
         return;
    }
    _position += _msize;
    fSaveWithFonts = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fOmitTitlePlace = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fRightToLeft = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fShowComments = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::SlideTime10Atom::_size = 16;
MSO::SlideTime10Atom::SlideTime10Atom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x2EEB)) {
         return;
    }
    if (!(rh.recLen == 8)) {
         return;
    }
    _position += _msize;
    fileTime = FILETIME(_d + _position);
    if (fileTime._data == 0) return;
    _msize = fileTime._size;
    _position += _msize;
    _data = _d;
}
MSO::PP12SlideBinaryTagExtension::PP12SlideBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    if (rhData.recLen > 8) {
        if (_position + 9 > _maxsize) return;
        roundTripHeaderFooterDefaultsAtom = RoundTripHeaderFooterDefaults12Atom(_d + _position);
        if (roundTripHeaderFooterDefaultsAtom._data == 0) return;
        _msize = roundTripHeaderFooterDefaultsAtom._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ProgStringTagContainer::ProgStringTagContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1389)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    tagNameAtom = TagNameAtom(_d + _position, _maxsize - _position);
    if (tagNameAtom._data == 0) return;
    _msize = tagNameAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        tagValueAtom = TagValueAtom(_d + _position, _maxsize - _position);
        _msize = (tagValueAtom._data) ?tagValueAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
const quint32 MSO::NotesAtom::_size = 16;
MSO::NotesAtom::NotesAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 1)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3F1)) {
         return;
    }
    if (!(rh.recLen == 0x8)) {
         return;
    }
    _position += _msize;
    slideIdRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    slideFlags = SlideFlags(_d + _position);
    if (slideFlags._data == 0) return;
    _msize = slideFlags._size;
    _position += _msize;
    unused = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::ExObjListContainer::ExObjListContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0409)) {
         return;
    }
    if (!(rh.recLen>=12)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    exObjListAtom = ExObjListAtom(_d + _position);
    if (exObjListAtom._data == 0) return;
    _msize = exObjListAtom._size;
    _position += _msize;
    if (_maxsize - _position < rh.recLen-12) return;
    rgChildRec = MSOArray<ExObjListSubContainer>(_d + _position, rh.recLen-12);
    if (rgChildRec._size != rh.recLen-12) return;
        _msize = rgChildRec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::ExControlContainer::ExControlContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFEE)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    exControlAtom = ExControlAtom(_d + _position);
    if (exControlAtom._data == 0) return;
    _msize = exControlAtom._size;
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    exOleObjAtom = ExOleObjAtom(_d + _position);
    if (exOleObjAtom._data == 0) return;
    _msize = exOleObjAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        menuNameAtom = MenuNameAtom(_d + _position, _maxsize - _position);
        _msize = (menuNameAtom._data) ?menuNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        progIdAtom = ProgIDAtom(_d + _position, _maxsize - _position);
        _msize = (progIdAtom._data) ?progIdAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        clipboardNameAtom = ClipboardNameAtom(_d + _position, _maxsize - _position);
        _msize = (clipboardNameAtom._data) ?clipboardNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        metafile = MetafileBlob(_d + _position, _maxsize - _position);
        _msize = (metafile._data) ?metafile._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ExHyperlinkContainer::ExHyperlinkContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFD7)) {
         return;
    }
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    exHyperlinkAtom = ExHyperlinkAtom(_d + _position);
    if (exHyperlinkAtom._data == 0) return;
    _msize = exHyperlinkAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        friendlyNameAtom = FriendlyNameAtom(_d + _position, _maxsize - _position);
        _msize = (friendlyNameAtom._data) ?friendlyNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        targetAtom = TargetAtom(_d + _position, _maxsize - _position);
        _msize = (targetAtom._data) ?targetAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        locationAtom = LocationAtom(_d + _position, _maxsize - _position);
        _msize = (locationAtom._data) ?locationAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ExOleLinkContainer::ExOleLinkContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FCE)) {
         return;
    }
    _position += _msize;
    if (_position + 20 > _maxsize) return;
    exOleLinkAtom = ExOleLinkAtom(_d + _position);
    if (exOleLinkAtom._data == 0) return;
    _msize = exOleLinkAtom._size;
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    exOleObjAtom = ExOleObjAtom(_d + _position);
    if (exOleObjAtom._data == 0) return;
    _msize = exOleObjAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        menuNameAtom = MenuNameAtom(_d + _position, _maxsize - _position);
        _msize = (menuNameAtom._data) ?menuNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        progIdAtom = ProgIDAtom(_d + _position, _maxsize - _position);
        _msize = (progIdAtom._data) ?progIdAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        clipboardNameAtom = ClipboardNameAtom(_d + _position, _maxsize - _position);
        _msize = (clipboardNameAtom._data) ?clipboardNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        metafile = MetafileBlob(_d + _position, _maxsize - _position);
        _msize = (metafile._data) ?metafile._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ExOleEmbedContainer::ExOleEmbedContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FCC)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    exOleEmbedAtom = ExOleEmbedAtom(_d + _position);
    if (exOleEmbedAtom._data == 0) return;
    _msize = exOleEmbedAtom._size;
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    exOleObjAtom = ExOleObjAtom(_d + _position);
    if (exOleObjAtom._data == 0) return;
    _msize = exOleObjAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        menuNameAtom = MenuNameAtom(_d + _position, _maxsize - _position);
        _msize = (menuNameAtom._data) ?menuNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        progIdAtom = ProgIDAtom(_d + _position, _maxsize - _position);
        _msize = (progIdAtom._data) ?progIdAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        clipboardNameAtom = ClipboardNameAtom(_d + _position, _maxsize - _position);
        _msize = (clipboardNameAtom._data) ?clipboardNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        metafile = MetafileBlob(_d + _position, _maxsize - _position);
        _msize = (metafile._data) ?metafile._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::OfficeArtFDGGBlock::OfficeArtFDGGBlock(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0F006)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    head = OfficeArtFDGG(_d + _position);
    if (head._data == 0) return;
    _msize = head._size;
    _position += _msize;
    Rgidcl = MSOArray<OfficeArtIDCL>(_d + _position, 8 * head.cidcl-1, head.cidcl-1);
    if (Rgidcl._count != head.cidcl-1) return;
        _msize = Rgidcl._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtSolverContainerFileBlock::OfficeArtSolverContainerFileBlock(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._OfficeArtFConnectorRule = OfficeArtFConnectorRule(_d + _position);
    _msize = (anon._OfficeArtFConnectorRule._data) ?OfficeArtFConnectorRule::_size : 0;
    if (_msize == 0) {
        anon._OfficeArtFArcRule = OfficeArtFArcRule(_d + _position);
        _msize = (anon._OfficeArtFArcRule._data) ?OfficeArtFArcRule::_size : 0;
    }
    if (_msize == 0) {
        anon._OfficeArtFCalloutRule = OfficeArtFCalloutRule(_d + _position);
        _msize = (anon._OfficeArtFCalloutRule._data) ?OfficeArtFCalloutRule::_size : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const OfficeArtFConnectorRule* OfficeArtSolverContainerFileBlock::C_anon::get<OfficeArtFConnectorRule>() const {
        return &_OfficeArtFConnectorRule;
    }
    template <> bool OfficeArtSolverContainerFileBlock::C_anon::is<OfficeArtFConnectorRule>() const {
        return _OfficeArtFConnectorRule._data;
    }
    template <> const OfficeArtFArcRule* OfficeArtSolverContainerFileBlock::C_anon::get<OfficeArtFArcRule>() const {
        return &_OfficeArtFArcRule;
    }
    template <> bool OfficeArtSolverContainerFileBlock::C_anon::is<OfficeArtFArcRule>() const {
        return _OfficeArtFArcRule._data;
    }
    template <> const OfficeArtFCalloutRule* OfficeArtSolverContainerFileBlock::C_anon::get<OfficeArtFCalloutRule>() const {
        return &_OfficeArtFCalloutRule;
    }
    template <> bool OfficeArtSolverContainerFileBlock::C_anon::is<OfficeArtFCalloutRule>() const {
        return _OfficeArtFCalloutRule._data;
    }
}
const quint32 MSO::Rotation::_size = 6;
MSO::Rotation::Rotation(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0004)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    rotation = FixedPoint(_d + _position);
    if (rotation._data == 0) return;
    _msize = rotation._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ProtectionBooleanProperties::_size = 6;
MSO::ProtectionBooleanProperties::ProtectionBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x007F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fLockAgainstGrouping = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockAdjustHandles = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockText = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockVertices = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockCropping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockAgainstSelect = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockPosition = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockAspectRatio = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fLockRotation = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockAgainstUngrouping = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused6 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefLockAgainstGrouping = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseLockAdjustHandles = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseLockText = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockVertices = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockCropping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockAgainstSelect = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockPosition = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockAspectRatio = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefLockRotation = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockAgainstUngrouping = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ITxid::_size = 6;
MSO::ITxid::ITxid(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0080)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    iTxid = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxTextLeft::_size = 6;
MSO::DxTextLeft::DxTextLeft(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0081)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxTextLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DyTextTop::_size = 6;
MSO::DyTextTop::DyTextTop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0082)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dyTextTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxTextRight::_size = 6;
MSO::DxTextRight::DxTextRight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0083)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxTextRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DyTextBottom::_size = 6;
MSO::DyTextBottom::DyTextBottom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0084)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dyTextBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::WrapText::_size = 6;
MSO::WrapText::WrapText(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0085)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    wrapText = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)wrapText)<5)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::AnchorText::_size = 6;
MSO::AnchorText::AnchorText(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0087)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    anchorText = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)anchorText)<=9)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::TxflTextFlow::_size = 6;
MSO::TxflTextFlow::TxflTextFlow(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0088)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    txflTextFlow = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)txflTextFlow)<=5)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CdirFont::_size = 6;
MSO::CdirFont::CdirFont(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0089)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    cdirFont = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)cdirFont)<=3)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::HspNext::_size = 6;
MSO::HspNext::HspNext(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x008A)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    hspNext = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Txdir::_size = 6;
MSO::Txdir::Txdir(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x008B)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    txdir = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)txdir)<=2)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::TextBooleanProperties::_size = 6;
MSO::TextBooleanProperties::TextBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x00BF)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    unused1 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fFitShapeToText = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fAutoTextMargin = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fSelectText = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    unused3a = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    unused3b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused4 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefFitShapeToText = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused5 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefAutoTextMargin = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefSelectText = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    unused6a = readuint3_5(_d + _position);
    _msize = 1;
    _position += _msize;
    unused6b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CropFromTop::_size = 6;
MSO::CropFromTop::CropFromTop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0100)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    cropFromTop = FixedPoint(_d + _position);
    if (cropFromTop._data == 0) return;
    _msize = cropFromTop._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CropFromBottom::_size = 6;
MSO::CropFromBottom::CropFromBottom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0101)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    cropFromBottom = FixedPoint(_d + _position);
    if (cropFromBottom._data == 0) return;
    _msize = cropFromBottom._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CropFromLeft::_size = 6;
MSO::CropFromLeft::CropFromLeft(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0102)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    cropFromLeft = FixedPoint(_d + _position);
    if (cropFromLeft._data == 0) return;
    _msize = cropFromLeft._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CropFromRight::_size = 6;
MSO::CropFromRight::CropFromRight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0103)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    cropFromRight = FixedPoint(_d + _position);
    if (cropFromRight._data == 0) return;
    _msize = cropFromRight._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Pib::_size = 6;
MSO::Pib::Pib(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0104)) {
         return;
    }
    _position += _msize;
    pib = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PibName::_size = 6;
MSO::PibName::PibName(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0105)) {
         return;
    }
    _position += _msize;
    pibName = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PibFlags::_size = 6;
MSO::PibFlags::PibFlags(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0106)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    pibFlags = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PictureTransparent::_size = 6;
MSO::PictureTransparent::PictureTransparent(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0107)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    pictureTransparent = OfficeArtCOLORREF(_d + _position);
    if (pictureTransparent._data == 0) return;
    _msize = pictureTransparent._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PictureContrast::_size = 6;
MSO::PictureContrast::PictureContrast(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0108)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    pictureContrast = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PictureBrightness::_size = 6;
MSO::PictureBrightness::PictureBrightness(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0109)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    pictureBrightness = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::BlipBooleanProperties::_size = 6;
MSO::BlipBooleanProperties::BlipBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x013F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fPictureActive = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fPictureBiLevel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fPictureGray = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fNoHitTestPicture = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fLooping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fRewind = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fPicturePreserveGrays = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused1b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefPictureActive = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefPictureBiLevel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefPictureGray = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefNoHitTestPicture = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLooping = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefRewind = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefPicturePreserveGrays = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GeoLeft::_size = 6;
MSO::GeoLeft::GeoLeft(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0140)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    geoLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GeoTop::_size = 6;
MSO::GeoTop::GeoTop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0141)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    geoTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GeoRight::_size = 6;
MSO::GeoRight::GeoRight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0142)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    geoRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GeoBottom::_size = 6;
MSO::GeoBottom::GeoBottom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0143)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    geoBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShapePath::_size = 6;
MSO::ShapePath::ShapePath(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0144)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    shapePath = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)shapePath)<=4)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PVertices::_size = 6;
MSO::PVertices::PVertices(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0145)) {
         return;
    }
    _position += _msize;
    pVertices = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PSegmentInfo::_size = 6;
MSO::PSegmentInfo::PSegmentInfo(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0146)) {
         return;
    }
    _position += _msize;
    pSegmentInfo = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::AdjustValue::_size = 6;
MSO::AdjustValue::AdjustValue(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0147)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjustvalue = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust2Value::_size = 6;
MSO::Adjust2Value::Adjust2Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0148)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust2value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust3Value::_size = 6;
MSO::Adjust3Value::Adjust3Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0149)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust3value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust4Value::_size = 6;
MSO::Adjust4Value::Adjust4Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x014A)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust4value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust5Value::_size = 6;
MSO::Adjust5Value::Adjust5Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x014B)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust5value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust6Value::_size = 6;
MSO::Adjust6Value::Adjust6Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x014C)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust6value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust7Value::_size = 6;
MSO::Adjust7Value::Adjust7Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x014D)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust7value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Adjust8Value::_size = 6;
MSO::Adjust8Value::Adjust8Value(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x014E)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    adjust8value = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GeometryBooleanProperties::_size = 6;
MSO::GeometryBooleanProperties::GeometryBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x017F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fFillOk = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fFillShadeShapeOK = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fGtextOK = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fLineOK = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    f3DOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fShadowOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unuseda = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unusedb = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefFillOK = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefFillShadeShapeOK = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefGtextOK = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLineOK = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsef3DOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefShadowOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unused3a = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused3b = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused4 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillType::_size = 6;
MSO::FillType::FillType(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0180)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillType = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)fillType)<=9)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillColor::_size = 6;
MSO::FillColor::FillColor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0181)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillColor = OfficeArtCOLORREF(_d + _position);
    if (fillColor._data == 0) return;
    _msize = fillColor._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillOpacity::_size = 6;
MSO::FillOpacity::FillOpacity(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0182)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillOpacity = FixedPoint(_d + _position);
    if (fillOpacity._data == 0) return;
    _msize = fillOpacity._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillBackColor::_size = 6;
MSO::FillBackColor::FillBackColor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0183)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillBackColor = OfficeArtCOLORREF(_d + _position);
    if (fillBackColor._data == 0) return;
    _msize = fillBackColor._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillBackOpacity::_size = 6;
MSO::FillBackOpacity::FillBackOpacity(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0184)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillBackOpacity = FixedPoint(_d + _position);
    if (fillBackOpacity._data == 0) return;
    _msize = fillBackOpacity._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillCrMod::_size = 6;
MSO::FillCrMod::FillCrMod(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0185)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillCrMod = OfficeArtCOLORREF(_d + _position);
    if (fillCrMod._data == 0) return;
    _msize = fillCrMod._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillBlip::_size = 6;
MSO::FillBlip::FillBlip(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0186)) {
         return;
    }
    _position += _msize;
    fillBlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillBlipName::_size = 6;
MSO::FillBlipName::FillBlipName(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0187)) {
         return;
    }
    _position += _msize;
    fillBlipName = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillBlipFlags::_size = 6;
MSO::FillBlipFlags::FillBlipFlags(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0188)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillBlipFlags = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillWidth::_size = 6;
MSO::FillWidth::FillWidth(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0189)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillWidth = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillHeight::_size = 6;
MSO::FillHeight::FillHeight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x018A)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillHeight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillAngle::_size = 6;
MSO::FillAngle::FillAngle(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x018B)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillAngle = FixedPoint(_d + _position);
    if (fillAngle._data == 0) return;
    _msize = fillAngle._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillFocus::_size = 6;
MSO::FillFocus::FillFocus(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x018C)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillFocus = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillToLeft::_size = 6;
MSO::FillToLeft::FillToLeft(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x018D)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillToLeft = FixedPoint(_d + _position);
    if (fillToLeft._data == 0) return;
    _msize = fillToLeft._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillToTop::_size = 6;
MSO::FillToTop::FillToTop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x018E)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillToTop = FixedPoint(_d + _position);
    if (fillToTop._data == 0) return;
    _msize = fillToTop._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillToRight::_size = 6;
MSO::FillToRight::FillToRight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x018F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillToRight = FixedPoint(_d + _position);
    if (fillToRight._data == 0) return;
    _msize = fillToRight._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillToBottom::_size = 6;
MSO::FillToBottom::FillToBottom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0190)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillToBottom = FixedPoint(_d + _position);
    if (fillToBottom._data == 0) return;
    _msize = fillToBottom._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillRectLeft::_size = 6;
MSO::FillRectLeft::FillRectLeft(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0191)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillRectLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillRectTop::_size = 6;
MSO::FillRectTop::FillRectTop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0192)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillRectTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillRectRight::_size = 6;
MSO::FillRectRight::FillRectRight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0193)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillRectRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillRectBottom::_size = 6;
MSO::FillRectBottom::FillRectBottom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0194)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillRectBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillDztype::_size = 6;
MSO::FillDztype::FillDztype(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0195)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillDztype = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillShadePreset::_size = 6;
MSO::FillShadePreset::FillShadePreset(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0196)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillShadePreset = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillShadeColors::_size = 6;
MSO::FillShadeColors::FillShadeColors(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0197)) {
         return;
    }
    _position += _msize;
    fillShadeColors = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillOriginX::_size = 6;
MSO::FillOriginX::FillOriginX(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0198)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillOriginX = FixedPoint(_d + _position);
    if (fillOriginX._data == 0) return;
    _msize = fillOriginX._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillOriginY::_size = 6;
MSO::FillOriginY::FillOriginY(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0199)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillOriginY = FixedPoint(_d + _position);
    if (fillOriginY._data == 0) return;
    _msize = fillOriginY._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillShapeOriginX::_size = 6;
MSO::FillShapeOriginX::FillShapeOriginX(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x019A)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillShapeOriginX = FixedPoint(_d + _position);
    if (fillShapeOriginX._data == 0) return;
    _msize = fillShapeOriginX._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillShapeOriginY::_size = 6;
MSO::FillShapeOriginY::FillShapeOriginY(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x019B)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillShapeOriginY = FixedPoint(_d + _position);
    if (fillShapeOriginY._data == 0) return;
    _msize = fillShapeOriginY._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillColorExt::_size = 6;
MSO::FillColorExt::FillColorExt(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x019E)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillColorExt = OfficeArtCOLORREF(_d + _position);
    if (fillColorExt._data == 0) return;
    _msize = fillColorExt._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillBackColorExt::_size = 6;
MSO::FillBackColorExt::FillBackColorExt(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01A2)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fillBackColorExt = OfficeArtCOLORREF(_d + _position);
    if (fillBackColorExt._data == 0) return;
    _msize = fillBackColorExt._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::FillStyleBooleanProperties::_size = 6;
MSO::FillStyleBooleanProperties::FillStyleBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01BF)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fNoFillHitTest = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fillUseRect = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fillShape = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fHitTestFill = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fFilled = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseShapeAnchor = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fRecolorFillAsPicture = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused1b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fUseNoFillHitTest = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseFillUseRect = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseFillShape = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseHitTestFill = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseFilled = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseUseShapeAnchor = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefRecolorFillAsPicture = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineColor::_size = 6;
MSO::LineColor::LineColor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01C0)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineColor = OfficeArtCOLORREF(_d + _position);
    if (lineColor._data == 0) return;
    _msize = lineColor._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineOpacity::_size = 6;
MSO::LineOpacity::LineOpacity(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01C1)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineOpacity = readint32(_d + _position);
    _msize = 4;
    if (!(((qint32)lineOpacity)>=0)) {
         return;
    }
    if (!(((qint32)lineOpacity)<=65536)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineBackColor::_size = 6;
MSO::LineBackColor::LineBackColor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01C2)) {
         return;
    }
    _position += _msize;
    lineBackColor = OfficeArtCOLORREF(_d + _position);
    if (lineBackColor._data == 0) return;
    _msize = lineBackColor._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineFillBlip::_size = 6;
MSO::LineFillBlip::LineFillBlip(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01C5)) {
         return;
    }
    _position += _msize;
    lineFillBlip = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineWidth::_size = 6;
MSO::LineWidth::LineWidth(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01CB)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineWidth = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineStyle::_size = 6;
MSO::LineStyle::LineStyle(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01CD)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineStyle = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineDashing::_size = 6;
MSO::LineDashing::LineDashing(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01CE)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineDashing = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineStartArrowhead::_size = 6;
MSO::LineStartArrowhead::LineStartArrowhead(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D0)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineStartArrowhead = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)lineStartArrowhead)<=8)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineEndArrowhead::_size = 6;
MSO::LineEndArrowhead::LineEndArrowhead(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D1)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineEndArrowhead = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)lineEndArrowhead)<=8)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineStartArrowWidth::_size = 6;
MSO::LineStartArrowWidth::LineStartArrowWidth(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D2)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineStartArrowWidth = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineStartArrowLength::_size = 6;
MSO::LineStartArrowLength::LineStartArrowLength(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D3)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineStartArrowLength = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineEndArrowWidth::_size = 6;
MSO::LineEndArrowWidth::LineEndArrowWidth(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D4)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineEndArrowWidth = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineEndArrowLength::_size = 6;
MSO::LineEndArrowLength::LineEndArrowLength(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D5)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineEndArrowLength = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineJoinStyle::_size = 6;
MSO::LineJoinStyle::LineJoinStyle(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01D6)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lineJoinStyle = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)lineJoinStyle)<=2)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LineStyleBooleanProperties::_size = 6;
MSO::LineStyleBooleanProperties::LineStyleBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x01FF)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fNoLineDrawDash = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fLineFillShape = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fHitTestLine = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fLine = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fArrowHeadsOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fInsetPenOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fInsetPen = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    reserved2 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fLineOpaqueBackColor = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    fUseNoLineDrawDash = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseLineFillShape = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseHitTestLine = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLine = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefArrowHeadsOK = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseInsetPenOK = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUseInsetPen = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused3 = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLineOpaqueBackColor = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused4 = readuint6_2(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShadowType::_size = 6;
MSO::ShadowType::ShadowType(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0200)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    shadowType = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShadowColor::_size = 6;
MSO::ShadowColor::ShadowColor(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0201)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    shadowColor = OfficeArtCOLORREF(_d + _position);
    if (shadowColor._data == 0) return;
    _msize = shadowColor._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShadowOpacity::_size = 6;
MSO::ShadowOpacity::ShadowOpacity(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0204)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    shadowOpacity = FixedPoint(_d + _position);
    if (shadowOpacity._data == 0) return;
    _msize = shadowOpacity._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShadowOffsetX::_size = 6;
MSO::ShadowOffsetX::ShadowOffsetX(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0205)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    shadowOffsetX = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShadowOffsetY::_size = 6;
MSO::ShadowOffsetY::ShadowOffsetY(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0206)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    shadowOffsetY = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShadowStyleBooleanProperties::_size = 6;
MSO::ShadowStyleBooleanProperties::ShadowStyleBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x023F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fShadowObscured = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fShadow = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    fUsefShadowObscured = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefShadow = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readuint14_2(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::HspMaster::_size = 6;
MSO::HspMaster::HspMaster(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0301)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    hspMaster = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Cxstyle::_size = 6;
MSO::Cxstyle::Cxstyle(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0303)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    cxstyle = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)cxstyle)<=4)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::BWMode::_size = 6;
MSO::BWMode::BWMode(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0304)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    bWMode = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)bWMode)<=10)) {
         return;
    }
    _position += _msize;
    _data = _d;
}
const quint32 MSO::ShapeBooleanProperties::_size = 6;
MSO::ShapeBooleanProperties::ShapeBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x033F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fBackground = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    reserved1 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fInitiator = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fLockShapeType = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fPreferRelativeResize = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fOleIcon = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fFlipVOverride = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fFlipHOverride = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fPolicyBarcode = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fPolicyLabel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    unused3 = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefBackground = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    unused4 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefInitiator = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLockShapeType = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fusePreferrelativeResize = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefOleIcon = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefFlipVOverride = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefFlipHOverride = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefPolicyBarcode = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefPolicyLabel = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    unused5 = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    unused6 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    unused7 = readuint4_4(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxyCalloutGap::_size = 6;
MSO::DxyCalloutGap::DxyCalloutGap(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0341)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxyCalloutGap = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Spcoa::_size = 6;
MSO::Spcoa::Spcoa(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0342)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    spcoa = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::Spcod::_size = 6;
MSO::Spcod::Spcod(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0343)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    spcod = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxyCalloutDropSpecified::_size = 6;
MSO::DxyCalloutDropSpecified::DxyCalloutDropSpecified(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0344)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxyCalloutDropSpecified = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxyCalloutLengthSpecified::_size = 6;
MSO::DxyCalloutLengthSpecified::DxyCalloutLengthSpecified(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0345)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxyCalloutLengthSpecified = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::CalloutBooleanProperties::_size = 6;
MSO::CalloutBooleanProperties::CalloutBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x037F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fCalloutLengthSpecified = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fCalloutDropAuto = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fCalloutMinusY = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fCalloutMinusX = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fCalloutTextBorder = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fCalloutAccentBar = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fCallout = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused1b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefCalloutLengthSpecified = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefCalloutDropAuto = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefCalloutMinusY = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefCalloutMinusX = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefCalloutTextBorder = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefCalloutAccentBar = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefCallout = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2a = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PWrapPolygonVertices::_size = 6;
MSO::PWrapPolygonVertices::PWrapPolygonVertices(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0383)) {
         return;
    }
    _position += _msize;
    pWrapPolygonVertices = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxWrapDistLeft::_size = 6;
MSO::DxWrapDistLeft::DxWrapDistLeft(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0384)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxWrapDistLeft = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DyWrapDistTop::_size = 6;
MSO::DyWrapDistTop::DyWrapDistTop(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0385)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dyWrapDistTop = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxWrapDistRight::_size = 6;
MSO::DxWrapDistRight::DxWrapDistRight(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0386)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxWrapDistRight = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DyWrapDistBottom::_size = 6;
MSO::DyWrapDistBottom::DyWrapDistBottom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0387)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dyWrapDistBottom = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::LidRegroup::_size = 6;
MSO::LidRegroup::LidRegroup(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0388)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    lidRegroup = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PosH::_size = 6;
MSO::PosH::PosH(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x038F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    posH = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PosRelH::_size = 6;
MSO::PosRelH::PosRelH(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0390)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    posRelH = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PosV::_size = 6;
MSO::PosV::PosV(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0391)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    posV = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PosRelV::_size = 6;
MSO::PosRelV::PosRelV(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0392)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    posRelV = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::PctHR::_size = 6;
MSO::PctHR::PctHR(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0393)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    pctHR = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::AlignHR::_size = 6;
MSO::AlignHR::AlignHR(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0394)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    alignHR = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxHeightHR::_size = 6;
MSO::DxHeightHR::DxHeightHR(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0395)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxHeightHR = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DxWidthHR::_size = 6;
MSO::DxWidthHR::DxWidthHR(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0396)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    dxWidthHR = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::GroupShapeBooleanProperties::_size = 6;
MSO::GroupShapeBooleanProperties::GroupShapeBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x03bf)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fPrint = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fHidden = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fOneD = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fIsButton = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fOnDblClickNotify = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fBehindDocument = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fEditedWrap = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fScriptAnchor = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fReallyHidden = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fAllowOverlap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUserDrawn = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fHorizRule = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fNoshadeHR = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fStandardHR = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fIsBullet = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fLayoutInCell = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefPrint = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefHidden = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefOneD = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefIsButton = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefOnDblClickNotify = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefBehindDocument = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefEditedWrap = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefScriptAnchor = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefReallyHidden = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefAllowOverlap = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefUserDrawn = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefHorizRule = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefNoshadeHR = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefStandardHR = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefIsBullet = readbit_6(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefLayoutInCell = readbit_7(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::WzFillId::_size = 6;
MSO::WzFillId::WzFillId(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x0403)) {
         return;
    }
    _position += _msize;
    wzFillId = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::DiagramBooleanProperties::_size = 6;
MSO::DiagramBooleanProperties::DiagramBooleanProperties(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    if (!(opid.opid == 0x053F)) {
         return;
    }
    if (!(opid.fBid == false)) {
         return;
    }
    if (!(opid.fComplex == false)) {
         return;
    }
    _position += _msize;
    fPseudoInline = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fDoLayout = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fReverse = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fDoFormat = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    unused1 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    unused2 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unused3a = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    unused3b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    fUsefPseudoInline = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefDoLayout = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefReverse = readbit_2(_d + _position);
    _msize = 0;
    _position += _msize;
    fUsefDoFormat = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    unused4 = readbit_4(_d + _position);
    _msize = 0;
    _position += _msize;
    unused5 = readbit_5(_d + _position);
    _msize = 0;
    _position += _msize;
    unused6a = readuint2_6(_d + _position);
    _msize = 1;
    _position += _msize;
    unused6b = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _data = _d;
}
MSO::PptOfficeArtClientAnchor::PptOfficeArtClientAnchor(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF010)) {
         return;
    }
    if (!(rh.recLen == 0x8 || rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (rh.recLen==0x8) {
        if (_position + 8 > _maxsize) return;
        rect1 = SmallRectStruct(_d + _position);
        if (rect1._data == 0) return;
        _msize = rect1._size;
        _position += _msize;
    }
    if (rh.recLen==0x10) {
        if (_position + 16 > _maxsize) return;
        rect2 = RectStruct(_d + _position);
        if (rect2._data == 0) return;
        _msize = rect2._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::AnimationInfoContainer::AnimationInfoContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x1014)) {
         return;
    }
    _position += _msize;
    if (_position + 36 > _maxsize) return;
    animationAtom = AnimationInfoAtom(_d + _position);
    if (animationAtom._data == 0) return;
    _msize = animationAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        animationSound = SoundContainer(_d + _position, _maxsize - _position);
        _msize = (animationSound._data) ?animationSound._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::MouseClickInteractiveInfoContainer::MouseClickInteractiveInfoContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFF2)) {
         return;
    }
    _position += _msize;
    if (_position + 24 > _maxsize) return;
    interactiveInfoAtom = InteractiveInfoAtom(_d + _position);
    if (interactiveInfoAtom._data == 0) return;
    _msize = interactiveInfoAtom._size;
    _position += _msize;
    if (rh.recLen>24) {
        if (_position + 0 > _maxsize) return;
        macroNameAtom = MacroNameAtom(_d + _position, _maxsize - _position);
        if (macroNameAtom._data == 0) return;
        _msize = macroNameAtom._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::MouseOverInteractiveInfoContainer::MouseOverInteractiveInfoContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0xFF2)) {
         return;
    }
    _position += _msize;
    if (_position + 24 > _maxsize) return;
    interactiveInfoAtom = InteractiveInfoAtom(_d + _position);
    if (interactiveInfoAtom._data == 0) return;
    _msize = interactiveInfoAtom._size;
    _position += _msize;
    if (rh.recLen>24) {
        if (_position + 0 > _maxsize) return;
        macroNameAtom = MacroNameAtom(_d + _position, _maxsize - _position);
        if (macroNameAtom._data == 0) return;
        _msize = macroNameAtom._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ShapeClientRoundtripDataSubcontainerOrAtom::ShapeClientRoundtripDataSubcontainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._ShapeProgsTagContainer = ShapeProgsTagContainer(_d + _position, _maxsize - _position);
    _msize = anon._ShapeProgsTagContainer._size;
    if (_msize == 0) {
        anon._RoundTripNewPlaceHolderId12Atom = RoundTripNewPlaceHolderId12Atom(_d + _position);
        _msize = (anon._RoundTripNewPlaceHolderId12Atom._data) ?RoundTripNewPlaceHolderId12Atom::_size : 0;
    }
    if (_msize == 0) {
        anon._RoundTripShapeId12Atom = RoundTripShapeId12Atom(_d + _position);
        _msize = (anon._RoundTripShapeId12Atom._data) ?RoundTripShapeId12Atom::_size : 0;
    }
    if (_msize == 0) {
        anon._RoundTripHFPlaceholder12Atom = RoundTripHFPlaceholder12Atom(_d + _position);
        _msize = (anon._RoundTripHFPlaceholder12Atom._data) ?RoundTripHFPlaceholder12Atom::_size : 0;
    }
    if (_msize == 0) {
        anon._RoundTripShapeCheckSumForCustomLayouts12Atom = RoundTripShapeCheckSumForCustomLayouts12Atom(_d + _position, _maxsize - _position);
        _msize = anon._RoundTripShapeCheckSumForCustomLayouts12Atom._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const ShapeProgsTagContainer* ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<ShapeProgsTagContainer>() const {
        return &_ShapeProgsTagContainer;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<ShapeProgsTagContainer>() const {
        return _ShapeProgsTagContainer._data;
    }
    template <> const RoundTripNewPlaceHolderId12Atom* ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripNewPlaceHolderId12Atom>() const {
        return &_RoundTripNewPlaceHolderId12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripNewPlaceHolderId12Atom>() const {
        return _RoundTripNewPlaceHolderId12Atom._data;
    }
    template <> const RoundTripShapeId12Atom* ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripShapeId12Atom>() const {
        return &_RoundTripShapeId12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripShapeId12Atom>() const {
        return _RoundTripShapeId12Atom._data;
    }
    template <> const RoundTripHFPlaceholder12Atom* ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripHFPlaceholder12Atom>() const {
        return &_RoundTripHFPlaceholder12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripHFPlaceholder12Atom>() const {
        return _RoundTripHFPlaceholder12Atom._data;
    }
    template <> const RoundTripShapeCheckSumForCustomLayouts12Atom* ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::get<RoundTripShapeCheckSumForCustomLayouts12Atom>() const {
        return &_RoundTripShapeCheckSumForCustomLayouts12Atom;
    }
    template <> bool ShapeClientRoundtripDataSubcontainerOrAtom::C_anon::is<RoundTripShapeCheckSumForCustomLayouts12Atom>() const {
        return _RoundTripShapeCheckSumForCustomLayouts12Atom._data;
    }
}
MSO::ShapeProgBinaryTagSubContainerOrAtom::ShapeProgBinaryTagSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._PP9ShapeBinaryTagExtension = PP9ShapeBinaryTagExtension(_d + _position, _maxsize - _position);
    _msize = anon._PP9ShapeBinaryTagExtension._size;
    if (_msize == 0) {
        anon._PP10ShapeBinaryTagExtension = PP10ShapeBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP10ShapeBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._PP11ShapeBinaryTagExtension = PP11ShapeBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP11ShapeBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._UnknownBinaryTag = UnknownBinaryTag(_d + _position, _maxsize - _position);
        _msize = anon._UnknownBinaryTag._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const PP9ShapeBinaryTagExtension* ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<PP9ShapeBinaryTagExtension>() const {
        return &_PP9ShapeBinaryTagExtension;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<PP9ShapeBinaryTagExtension>() const {
        return _PP9ShapeBinaryTagExtension._data;
    }
    template <> const PP10ShapeBinaryTagExtension* ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<PP10ShapeBinaryTagExtension>() const {
        return &_PP10ShapeBinaryTagExtension;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<PP10ShapeBinaryTagExtension>() const {
        return _PP10ShapeBinaryTagExtension._data;
    }
    template <> const PP11ShapeBinaryTagExtension* ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<PP11ShapeBinaryTagExtension>() const {
        return &_PP11ShapeBinaryTagExtension;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<PP11ShapeBinaryTagExtension>() const {
        return _PP11ShapeBinaryTagExtension._data;
    }
    template <> const UnknownBinaryTag* ShapeProgBinaryTagSubContainerOrAtom::C_anon::get<UnknownBinaryTag>() const {
        return &_UnknownBinaryTag;
    }
    template <> bool ShapeProgBinaryTagSubContainerOrAtom::C_anon::is<UnknownBinaryTag>() const {
        return _UnknownBinaryTag._data;
    }
}
MSO::OfficeArtClientTextBox::OfficeArtClientTextBox(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._XlsOfficeArtClientTextBox = XlsOfficeArtClientTextBox(_d + _position);
    _msize = (anon._XlsOfficeArtClientTextBox._data) ?XlsOfficeArtClientTextBox::_size : 0;
    if (_msize == 0) {
        anon._DocOfficeArtClientTextBox = DocOfficeArtClientTextBox(_d + _position);
        _msize = (anon._DocOfficeArtClientTextBox._data) ?DocOfficeArtClientTextBox::_size : 0;
    }
    if (_msize == 0) {
        anon._PptOfficeArtClientTextBox = PptOfficeArtClientTextBox(_d + _position, _maxsize - _position);
        _msize = anon._PptOfficeArtClientTextBox._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const XlsOfficeArtClientTextBox* OfficeArtClientTextBox::C_anon::get<XlsOfficeArtClientTextBox>() const {
        return &_XlsOfficeArtClientTextBox;
    }
    template <> bool OfficeArtClientTextBox::C_anon::is<XlsOfficeArtClientTextBox>() const {
        return _XlsOfficeArtClientTextBox._data;
    }
    template <> const DocOfficeArtClientTextBox* OfficeArtClientTextBox::C_anon::get<DocOfficeArtClientTextBox>() const {
        return &_DocOfficeArtClientTextBox;
    }
    template <> bool OfficeArtClientTextBox::C_anon::is<DocOfficeArtClientTextBox>() const {
        return _DocOfficeArtClientTextBox._data;
    }
    template <> const PptOfficeArtClientTextBox* OfficeArtClientTextBox::C_anon::get<PptOfficeArtClientTextBox>() const {
        return &_PptOfficeArtClientTextBox;
    }
    template <> bool OfficeArtClientTextBox::C_anon::is<PptOfficeArtClientTextBox>() const {
        return _PptOfficeArtClientTextBox._data;
    }
}
MSO::TextRulerAtom::TextRulerAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFA6)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    textRuler = TextRuler(_d + _position, _maxsize - _position);
    if (textRuler._data == 0) return;
    _msize = textRuler._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtFOPTE::_size = 6;
MSO::OfficeArtFOPTE::OfficeArtFOPTE(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    opid = OfficeArtFOPTEOPID(_d + _position);
    if (opid._data == 0) return;
    _msize = opid._size;
    _position += _msize;
    op = readint32(_d + _position);
    _msize = 4;
    _position += _msize;
    _data = _d;
}
MSO::Fib::Fib(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 32 > _maxsize) return;
    base = FibBase(_d + _position);
    if (base._data == 0) return;
    _msize = base._size;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    csw = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)csw) == 14)) {
         return;
    }
    _position += _msize;
    if (_position + 28 > _maxsize) return;
    fibRgW = FibRgW97(_d + _position);
    if (fibRgW._data == 0) return;
    _msize = fibRgW._size;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cslw = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cslw) == 22)) {
         return;
    }
    _position += _msize;
    if (_position + 88 > _maxsize) return;
    fibRgLw = FibRgLw97(_d + _position);
    if (fibRgLw._data == 0) return;
    _msize = fibRgLw._size;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cbRgFcLcb = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cbRgFcLcb) == 0x5D || ((quint16)cbRgFcLcb) == 0x6C || ((quint16)cbRgFcLcb) == 0x88 || ((quint16)cbRgFcLcb) == 0xA4 || ((quint16)cbRgFcLcb) == 0xB7)) {
         return;
    }
    _position += _msize;
    if (_position + 744 > _maxsize) return;
    fibRgFcLcbBlob = FibRgFcLcb97(_d + _position);
    if (fibRgFcLcbBlob._data == 0) return;
    _msize = fibRgFcLcbBlob._size;
    _position += _msize;
    if (cbRgFcLcb>=0x6C) {
        if (_position + 120 > _maxsize) return;
        fibRgFcLcbBlob2 = FibRgFcLcb2000(_d + _position);
        if (fibRgFcLcbBlob2._data == 0) return;
        _msize = fibRgFcLcbBlob2._size;
        _position += _msize;
    }
    if (cbRgFcLcb>=0x88) {
        if (_position + 200 > _maxsize) return;
        fibRgFcLcbBlob3 = FibRgFcLcb2002(_d + _position);
        if (fibRgFcLcbBlob3._data == 0) return;
        _msize = fibRgFcLcbBlob3._size;
        _position += _msize;
    }
    if (_position + 2 > _maxsize) return;
    cswNew = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cswNew) == 0 || ((quint16)cswNew) == 2 || ((quint16)cswNew) == 5)) {
         return;
    }
    _position += _msize;
    fibRgCswNew = MSOCastArray<char>((const char*)(_d + _position), 2*cswNew);
    _msize = (2*cswNew)*1;
    _position += _msize;
    trail = MSOCastArray<char>((const char*)(_d + _position), fibRgLw.cbMac-156-8*cbRgFcLcb-2*cswNew);
    _msize = (fibRgLw.cbMac-156-8*cbRgFcLcb-2*cswNew)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::STSH::STSH(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    lpstshi = LPStshi(_d + _position, _maxsize - _position);
    if (lpstshi._data == 0) return;
    _msize = lpstshi._size;
    _position += _msize;
    rglpstd = MSOArray<LPStd>(_d + _position, _maxsize - _position, 20);
    if (rglpstd._count != 20) return;
        _msize = rglpstd._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::Clx::Clx(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    RgPrc = MSOArray<Pcr>(_d + _position, _maxsize - _position);
    if (RgPrc._data == 0) return;
        _msize = RgPrc._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    pcdt = Pcdt(_d + _position, _maxsize - _position);
    if (pcdt._data == 0) return;
    _msize = pcdt._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::Pcr::Pcr(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 1 > _maxsize) return;
    clxt = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)clxt) == 1)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    prcData = PrcData(_d + _position, _maxsize - _position);
    if (prcData._data == 0) return;
    _msize = prcData._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::Prm::_size = 2;
MSO::Prm::Prm(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    prm._Prm0 = Prm0(_d + _position);
    _msize = (prm._Prm0._data) ?Prm0::_size : 0;
    if (_msize == 0) {
        prm._Prm1 = Prm1(_d + _position);
        _msize = (prm._Prm1._data) ?Prm1::_size : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
    _data = _d;
}
namespace MSO {
    template <> const Prm0* Prm::C_prm::get<Prm0>() const {
        return &_Prm0;
    }
    template <> bool Prm::C_prm::is<Prm0>() const {
        return _Prm0._data;
    }
    template <> const Prm1* Prm::C_prm::get<Prm1>() const {
        return &_Prm1;
    }
    template <> bool Prm::C_prm::is<Prm1>() const {
        return _Prm1._data;
    }
}
MSO::OfficeArtBlipEMF::OfficeArtBlipEMF(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x3D4 || rh.recInstance == 0x3D5)) {
         return;
    }
    if (!(rh.recType == 0xF01A)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x3D5;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 34 > _maxsize) return;
    metafileHeader = OfficeArtMetafileHeader(_d + _position);
    if (metafileHeader._data == 0) return;
    _msize = metafileHeader._size;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance==0x3D4)?50:66));
    _msize = (rh.recLen-((rh.recInstance==0x3D4)?50:66))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBlipWMF::OfficeArtBlipWMF(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x216 || rh.recInstance == 0x217)) {
         return;
    }
    if (!(rh.recType == 0xF01B)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x217;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 34 > _maxsize) return;
    metafileHeader = OfficeArtMetafileHeader(_d + _position);
    if (metafileHeader._data == 0) return;
    _msize = metafileHeader._size;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance==0x216)?50:66));
    _msize = (rh.recLen-((rh.recInstance==0x216)?50:66))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBlipPICT::OfficeArtBlipPICT(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0x542 || rh.recInstance == 0x543)) {
         return;
    }
    if (!(rh.recType == 0xF01C)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid1 = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    _has_rgbUid2 = rh.recInstance == 0x543;
    if (_has_rgbUid2) {
        if (_position + 16 > _maxsize) return;
        rgbUid2 = MSOCastArray<char>((const char*)(_d + _position), 16);
        _msize = (16)*1;
        _position += _msize;
    }
    if (_position + 34 > _maxsize) return;
    metafileHeader = OfficeArtMetafileHeader(_d + _position);
    if (metafileHeader._data == 0) return;
    _msize = metafileHeader._size;
    _position += _msize;
    BLIPFileData = MSOCastArray<char>((const char*)(_d + _position), rh.recLen-((rh.recInstance==0x542)?50:66));
    _msize = (rh.recLen-((rh.recInstance==0x542)?50:66))*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBlip::OfficeArtBlip(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._OfficeArtBlipEMF = OfficeArtBlipEMF(_d + _position, _maxsize - _position);
    _msize = anon._OfficeArtBlipEMF._size;
    if (_msize == 0) {
        anon._OfficeArtBlipWMF = OfficeArtBlipWMF(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlipWMF._size;
    }
    if (_msize == 0) {
        anon._OfficeArtBlipPICT = OfficeArtBlipPICT(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlipPICT._size;
    }
    if (_msize == 0) {
        anon._OfficeArtBlipJPEG = OfficeArtBlipJPEG(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlipJPEG._size;
    }
    if (_msize == 0) {
        anon._OfficeArtBlipPNG = OfficeArtBlipPNG(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlipPNG._size;
    }
    if (_msize == 0) {
        anon._OfficeArtBlipDIB = OfficeArtBlipDIB(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlipDIB._size;
    }
    if (_msize == 0) {
        anon._OfficeArtBlipTIFF = OfficeArtBlipTIFF(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlipTIFF._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const OfficeArtBlipEMF* OfficeArtBlip::C_anon::get<OfficeArtBlipEMF>() const {
        return &_OfficeArtBlipEMF;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipEMF>() const {
        return _OfficeArtBlipEMF._data;
    }
    template <> const OfficeArtBlipWMF* OfficeArtBlip::C_anon::get<OfficeArtBlipWMF>() const {
        return &_OfficeArtBlipWMF;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipWMF>() const {
        return _OfficeArtBlipWMF._data;
    }
    template <> const OfficeArtBlipPICT* OfficeArtBlip::C_anon::get<OfficeArtBlipPICT>() const {
        return &_OfficeArtBlipPICT;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipPICT>() const {
        return _OfficeArtBlipPICT._data;
    }
    template <> const OfficeArtBlipJPEG* OfficeArtBlip::C_anon::get<OfficeArtBlipJPEG>() const {
        return &_OfficeArtBlipJPEG;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipJPEG>() const {
        return _OfficeArtBlipJPEG._data;
    }
    template <> const OfficeArtBlipPNG* OfficeArtBlip::C_anon::get<OfficeArtBlipPNG>() const {
        return &_OfficeArtBlipPNG;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipPNG>() const {
        return _OfficeArtBlipPNG._data;
    }
    template <> const OfficeArtBlipDIB* OfficeArtBlip::C_anon::get<OfficeArtBlipDIB>() const {
        return &_OfficeArtBlipDIB;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipDIB>() const {
        return _OfficeArtBlipDIB._data;
    }
    template <> const OfficeArtBlipTIFF* OfficeArtBlip::C_anon::get<OfficeArtBlipTIFF>() const {
        return &_OfficeArtBlipTIFF;
    }
    template <> bool OfficeArtBlip::C_anon::is<OfficeArtBlipTIFF>() const {
        return _OfficeArtBlipTIFF._data;
    }
}
const quint32 MSO::ZoomViewInfoAtom::_size = 60;
MSO::ZoomViewInfoAtom::ZoomViewInfoAtom(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x3FD)) {
         return;
    }
    if (!(rh.recLen == 0x34)) {
         return;
    }
    _position += _msize;
    curScale = ScalingStruct(_d + _position);
    if (curScale._data == 0) return;
    _msize = curScale._size;
    _position += _msize;
    unused1 = MSOCastArray<char>((const char*)(_d + _position), 24);
    _msize = (24)*1;
    _position += _msize;
    origin = PointStruct(_d + _position);
    if (origin._data == 0) return;
    _msize = origin._size;
    _position += _msize;
    fUseVarScale = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)fUseVarScale) == 0 || ((quint8)fUseVarScale) == 1)) {
         return;
    }
    _position += _msize;
    fDraftMode = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    unused2 = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    _data = _d;
}
MSO::PP9DocBinaryTagExtension::PP9DocBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen == 0x0E)) {
         return;
    }
    _position += _msize;
    if (_position + 14 > _maxsize) return;
    tagName = MSOCastArray<char>((const char*)(_d + _position), 14);
    _msize = (14)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0x0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    rgTextMasterStyle9 = MSOArray<TextMasterStyle9Atom>(_d + _position, _maxsize - _position);
    if (rgTextMasterStyle9._data == 0) return;
        _msize = rgTextMasterStyle9._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        blipCollectionContainer = BlipCollection9Container(_d + _position, _maxsize - _position);
        _msize = (blipCollectionContainer._data) ?blipCollectionContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        textDefaultsAtom = TextDefaults9Atom(_d + _position, _maxsize - _position);
        _msize = (textDefaultsAtom._data) ?textDefaultsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        kinsokuContainer = Kinsoku9Container(_d + _position, _maxsize - _position);
        _msize = (kinsokuContainer._data) ?kinsokuContainer._size :0;
        _position += _msize;
    }
    rgExternalHyperlink9 = MSOArray<ExHyperlink9Container>(_d + _position, _maxsize - _position);
    if (rgExternalHyperlink9._data == 0) return;
        _msize = rgExternalHyperlink9._size;
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        presAdvisorFlagsAtom = PresAdvisorFlags9Atom(_d + _position);
        _msize = (presAdvisorFlagsAtom._data) ?presAdvisorFlagsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        envelopeDataAtom = EnvelopeData9Atom(_d + _position, _maxsize - _position);
        _msize = (envelopeDataAtom._data) ?envelopeDataAtom._size :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        envelopeFlagsAtom = EnvelopeFlags9Atom(_d + _position);
        _msize = (envelopeFlagsAtom._data) ?envelopeFlagsAtom._size :0;
        _position += _msize;
    }
    if (_position + 24 <= _maxsize) {
        htmlDocInfoAtom = HTMLDocInfo9Atom(_d + _position);
        _msize = (htmlDocInfoAtom._data) ?htmlDocInfoAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        htmlPublishInfoAtom = HTMLPublishInfo9Container(_d + _position, _maxsize - _position);
        _msize = (htmlPublishInfoAtom._data) ?htmlPublishInfoAtom._size :0;
        _position += _msize;
    }
    rgBroadcastDocInfo9 = MSOArray<BroadcastDocInfo9Container>(_d + _position, _maxsize - _position);
    if (rgBroadcastDocInfo9._data == 0) return;
        _msize = rgBroadcastDocInfo9._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        outlineTextPropsContainer = OutlineTextProps9Container(_d + _position, _maxsize - _position);
        _msize = (outlineTextPropsContainer._data) ?outlineTextPropsContainer._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextMasterStyle9Level::TextMasterStyle9Level(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    pf9 = TextPFException9(_d + _position, _maxsize - _position);
    if (pf9._data == 0) return;
    _msize = pf9._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf9 = TextCFException9(_d + _position, _maxsize - _position);
    if (cf9._data == 0) return;
    _msize = cf9._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::StyleTextProp9::StyleTextProp9(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    pf9 = TextPFException9(_d + _position, _maxsize - _position);
    if (pf9._data == 0) return;
    _msize = pf9._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf9 = TextCFException9(_d + _position, _maxsize - _position);
    if (cf9._data == 0) return;
    _msize = cf9._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    si = TextSIException(_d + _position, _maxsize - _position);
    if (si._data == 0) return;
    _msize = si._size;
    if (!(si.spell == false)) {
         return;
    }
    if (!(si.lang == false)) {
         return;
    }
    if (!(si.altLang == false)) {
         return;
    }
    if (!(si.smartTag == false)) {
         return;
    }
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::PP10DocBinaryTagExtension::PP10DocBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0FBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0x0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        fontCollectionContainer = FontCollection10Container(_d + _position, _maxsize - _position);
        _msize = (fontCollectionContainer._data) ?fontCollectionContainer._size :0;
        _position += _msize;
    }
    rgTextMasterStyle10 = MSOArray<TextMasterStyle10Atom>(_d + _position, _maxsize - _position);
    if (rgTextMasterStyle10._data == 0) return;
        _msize = rgTextMasterStyle10._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        textDefaultsAtom = TextDefaults10Atom(_d + _position, _maxsize - _position);
        _msize = (textDefaultsAtom._data) ?textDefaultsAtom._size :0;
        _position += _msize;
    }
    if (_position + 16 > _maxsize) return;
    gridSpacingAtom = GridSpacing10Atom(_d + _position);
    if (gridSpacingAtom._data == 0) return;
    _msize = gridSpacingAtom._size;
    _position += _msize;
    rgCommentIndex10 = MSOArray<CommentIndex10Container>(_d + _position, _maxsize - _position);
    if (rgCommentIndex10._data == 0) return;
        _msize = rgCommentIndex10._size;
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        fontEmbedFlagsAtom = FontEmbedFlags10Atom(_d + _position);
        _msize = (fontEmbedFlagsAtom._data) ?fontEmbedFlagsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        copyrightAtom = CopyrightAtom(_d + _position, _maxsize - _position);
        _msize = (copyrightAtom._data) ?copyrightAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        keywordsAtom = KeywordsAtom(_d + _position, _maxsize - _position);
        _msize = (keywordsAtom._data) ?keywordsAtom._size :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        filterPrivacyFlagsAtom = FilterPrivacyFlags10Atom(_d + _position);
        _msize = (filterPrivacyFlagsAtom._data) ?filterPrivacyFlagsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        outlineTextPropsContainer = OutlineTextProps10Container(_d + _position, _maxsize - _position);
        _msize = (outlineTextPropsContainer._data) ?outlineTextPropsContainer._size :0;
        _position += _msize;
    }
    if (_position + 9 <= _maxsize) {
        docToolbarStatesAtom = DocToolbarStates10Atom(_d + _position);
        _msize = (docToolbarStatesAtom._data) ?docToolbarStatesAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideListTableContainer = SlideListTable10Container(_d + _position, _maxsize - _position);
        _msize = (slideListTableContainer._data) ?slideListTableContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        rgDiffTree10Container = DiffTree10Container(_d + _position, _maxsize - _position);
        _msize = (rgDiffTree10Container._data) ?rgDiffTree10Container._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        modifyPasswordAtom = ModifyPasswordAtom(_d + _position, _maxsize - _position);
        _msize = (modifyPasswordAtom._data) ?modifyPasswordAtom._size :0;
        _position += _msize;
    }
    if (_position + 14 <= _maxsize) {
        photoAlbumInfoAtom = PhotoAlbumInfo10Atom(_d + _position);
        _msize = (photoAlbumInfoAtom._data) ?photoAlbumInfoAtom._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextMasterStyle10Level::TextMasterStyle10Level(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    cf10 = TextCFException10(_d + _position, _maxsize - _position);
    if (cf10._data == 0) return;
    _msize = cf10._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::NotesTextViewInfoContainer::_size = 68;
MSO::NotesTextViewInfoContainer::NotesTextViewInfoContainer(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x413)) {
         return;
    }
    _position += _msize;
    zoomViewInfo = ZoomViewInfoAtom(_d + _position);
    if (zoomViewInfo._data == 0) return;
    _msize = zoomViewInfo._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::OutlineViewInfoContainer::_size = 68;
MSO::OutlineViewInfoContainer::OutlineViewInfoContainer(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x407)) {
         return;
    }
    _position += _msize;
    noZoomViewInfo = NoZoomViewInfoAtom(_d + _position);
    if (noZoomViewInfo._data == 0) return;
    _msize = noZoomViewInfo._size;
    _position += _msize;
    _data = _d;
}
const quint32 MSO::NormalViewSetInfoContainer::_size = 36;
MSO::NormalViewSetInfoContainer::NormalViewSetInfoContainer(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x414)) {
         return;
    }
    if (!(rh.recLen == 0x1C)) {
         return;
    }
    _position += _msize;
    normalViewSetInfoAtom = NormalViewSetInfoAtom(_d + _position);
    if (normalViewSetInfoAtom._data == 0) return;
    _msize = normalViewSetInfoAtom._size;
    _position += _msize;
    _data = _d;
}
MSO::SlideListWithTextSubContainerOrAtom::SlideListWithTextSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 28 > _maxsize) return;
    slidePersistAtom = SlidePersistAtom(_d + _position);
    if (slidePersistAtom._data == 0) return;
    _msize = slidePersistAtom._size;
    _position += _msize;
    atoms = MSOArray<TextContainer>(_d + _position, _maxsize - _position);
    if (atoms._data == 0) return;
        _msize = atoms._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::MouseClickTextInfo::MouseClickTextInfo(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    interactive = MouseClickInteractiveInfoContainer(_d + _position, _maxsize - _position);
    if (interactive._data == 0) return;
    _msize = interactive._size;
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    text = MouseClickTextInteractiveInfoAtom(_d + _position);
    if (text._data == 0) return;
    _msize = text._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::MouseOverTextInfo::MouseOverTextInfo(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    interactive = MouseOverInteractiveInfoContainer(_d + _position, _maxsize - _position);
    if (interactive._data == 0) return;
    _msize = interactive._size;
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    text = MouseOverTextInteractiveInfoAtom(_d + _position);
    if (text._data == 0) return;
    _msize = text._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextClientDataSubContainerOrAtom::TextClientDataSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._OutlineTextRefAtom = OutlineTextRefAtom(_d + _position);
    _msize = (anon._OutlineTextRefAtom._data) ?OutlineTextRefAtom::_size : 0;
    if (_msize == 0) {
        anon._TextContainer = TextContainer(_d + _position, _maxsize - _position);
        _msize = anon._TextContainer._size;
    }
    if (_msize == 0) {
        anon._TextRulerAtom = TextRulerAtom(_d + _position, _maxsize - _position);
        _msize = anon._TextRulerAtom._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const OutlineTextRefAtom* TextClientDataSubContainerOrAtom::C_anon::get<OutlineTextRefAtom>() const {
        return &_OutlineTextRefAtom;
    }
    template <> bool TextClientDataSubContainerOrAtom::C_anon::is<OutlineTextRefAtom>() const {
        return _OutlineTextRefAtom._data;
    }
    template <> const TextContainer* TextClientDataSubContainerOrAtom::C_anon::get<TextContainer>() const {
        return &_TextContainer;
    }
    template <> bool TextClientDataSubContainerOrAtom::C_anon::is<TextContainer>() const {
        return _TextContainer._data;
    }
    template <> const TextRulerAtom* TextClientDataSubContainerOrAtom::C_anon::get<TextRulerAtom>() const {
        return &_TextRulerAtom;
    }
    template <> bool TextClientDataSubContainerOrAtom::C_anon::is<TextRulerAtom>() const {
        return _TextRulerAtom._data;
    }
}
MSO::TextPFRun::TextPFRun(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    count = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)count)>0)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    indentLevel = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)indentLevel)<=4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    pf = TextPFException(_d + _position, _maxsize - _position);
    if (pf._data == 0) return;
    _msize = pf._size;
    if (!(pf.masks.leftMargin == false)) {
         return;
    }
    if (!(pf.masks.indent == false)) {
         return;
    }
    if (!(pf.masks.defaultTabSize == false)) {
         return;
    }
    if (!(pf.masks.tabStops == false)) {
         return;
    }
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextCFRun::TextCFRun(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    count = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)count)>0)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf = TextCFException(_d + _position, _maxsize - _position);
    if (cf._data == 0) return;
    _msize = cf._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextCFExceptionAtom::TextCFExceptionAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FA4)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    cf = TextCFException(_d + _position, _maxsize - _position);
    if (cf._data == 0) return;
    _msize = cf._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::DefaultRulerAtom::DefaultRulerAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FAB)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    defaultTextRuler = TextRuler(_d + _position, _maxsize - _position);
    if (defaultTextRuler._data == 0) return;
    _msize = defaultTextRuler._size;
    if (!(defaultTextRuler.fDefaultTabSize == true)) {
         return;
    }
    if (!(defaultTextRuler.fCLevels == true)) {
         return;
    }
    if (!(defaultTextRuler.fTabStops == true)) {
         return;
    }
    if (!(defaultTextRuler.fLeftMargin1 == true)) {
         return;
    }
    if (!(defaultTextRuler.fLeftMargin2 == true)) {
         return;
    }
    if (!(defaultTextRuler.fLeftMargin3 == true)) {
         return;
    }
    if (!(defaultTextRuler.fLeftMargin4 == true)) {
         return;
    }
    if (!(defaultTextRuler.fIndent1 == true)) {
         return;
    }
    if (!(defaultTextRuler.fIndent2 == true)) {
         return;
    }
    if (!(defaultTextRuler.fIndent3 == true)) {
         return;
    }
    if (!(defaultTextRuler.fIndent4 == true)) {
         return;
    }
    if (!(defaultTextRuler.fIndent5 == true)) {
         return;
    }
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextPFExceptionAtom::TextPFExceptionAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FA5)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    reserved = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    pf = TextPFException(_d + _position, _maxsize - _position);
    if (pf._data == 0) return;
    _msize = pf._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextSIRun::TextSIRun(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 4 > _maxsize) return;
    count = readuint32(_d + _position);
    _msize = 4;
    if (!(((quint32)count)>=1)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    si = TextSIException(_d + _position, _maxsize - _position);
    if (si._data == 0) return;
    _msize = si._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextSIExceptionAtom::TextSIExceptionAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0FA9)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    textSIException = TextSIException(_d + _position, _maxsize - _position);
    if (textSIException._data == 0) return;
    _msize = textSIException._size;
    if (!(textSIException.fPp10ext == false)) {
         return;
    }
    if (!(textSIException.fBidi == false)) {
         return;
    }
    if (!(textSIException.smartTag == false)) {
         return;
    }
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextMasterStyleAtom::TextMasterStyleAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1 || rh.recInstance == 2 || rh.recInstance == 3 || rh.recInstance == 4 || rh.recInstance == 5 || rh.recInstance == 6 || rh.recInstance == 7 || rh.recInstance == 8)) {
         return;
    }
    if (!(rh.recType == 0x0FA3)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cLevels = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cLevels)<=5)) {
         return;
    }
    _position += _msize;
    _has_lstLvl1level = cLevels>0 && rh.recInstance>=5;
    if (_has_lstLvl1level) {
        if (_position + 2 > _maxsize) return;
        lstLvl1level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>0) {
        if (_position + 0 > _maxsize) return;
        lstLvl1 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (lstLvl1._data == 0) return;
        _msize = lstLvl1._size;
        _position += _msize;
    }
    _has_lstLvl2level = cLevels>1 && rh.recInstance>=5;
    if (_has_lstLvl2level) {
        if (_position + 2 > _maxsize) return;
        lstLvl2level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>1) {
        if (_position + 0 > _maxsize) return;
        lstLvl2 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (lstLvl2._data == 0) return;
        _msize = lstLvl2._size;
        _position += _msize;
    }
    _has_lstLvl3level = cLevels>2 && rh.recInstance>=5;
    if (_has_lstLvl3level) {
        if (_position + 2 > _maxsize) return;
        lstLvl3level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>2) {
        if (_position + 0 > _maxsize) return;
        lstLvl3 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (lstLvl3._data == 0) return;
        _msize = lstLvl3._size;
        _position += _msize;
    }
    _has_lstLvl4level = cLevels>3 && rh.recInstance>=5;
    if (_has_lstLvl4level) {
        if (_position + 2 > _maxsize) return;
        lstLvl4level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>3) {
        if (_position + 0 > _maxsize) return;
        lstLvl4 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (lstLvl4._data == 0) return;
        _msize = lstLvl4._size;
        _position += _msize;
    }
    _has_lstLvl5level = cLevels>4 && rh.recInstance>=5;
    if (_has_lstLvl5level) {
        if (_position + 2 > _maxsize) return;
        lstLvl5level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>4) {
        if (_position + 0 > _maxsize) return;
        lstLvl5 = TextMasterStyleLevel(_d + _position, _maxsize - _position);
        if (lstLvl5._data == 0) return;
        _msize = lstLvl5._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::PP10SlideBinaryTagExtension::PP10SlideBinaryTagExtension(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xFBA)) {
         return;
    }
    if (!(rh.recLen == 0x10)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    tagName = MSOCastArray<quint16>((const quint16*)(_d + _position), 8);
    _msize = (8)*2;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    rhData = RecordHeader(_d + _position);
    if (rhData._data == 0) return;
    _msize = rhData._size;
    if (!(rhData.recVer == 0)) {
         return;
    }
    if (!(rhData.recInstance == 0)) {
         return;
    }
    if (!(rhData.recType == 0x138B)) {
         return;
    }
    _position += _msize;
    rgTextMasterStyleAtom = MSOArray<TextMasterStyle10Atom>(_d + _position, _maxsize - _position);
    if (rgTextMasterStyleAtom._data == 0) return;
        _msize = rgTextMasterStyleAtom._size;
    _position += _msize;
    rgComment10Container = MSOArray<Comment10Container>(_d + _position, _maxsize - _position);
    if (rgComment10Container._data == 0) return;
        _msize = rgComment10Container._size;
    _position += _msize;
    if (_position + 16 <= _maxsize) {
        linkedSlideAtom = LinkedSlide10Atom(_d + _position);
        _msize = (linkedSlideAtom._data) ?linkedSlideAtom._size :0;
        _position += _msize;
    }
    rgLinkedShape10Atom = MSOArray<LinkedShape10Atom>(_d + _position, _maxsize - _position);
    if (rgLinkedShape10Atom._data == 0) return;
        _msize = rgLinkedShape10Atom._size;
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        slideFlagsAtom = SlideFlags10Atom(_d + _position);
        _msize = (slideFlagsAtom._data) ?slideFlagsAtom._size :0;
        _position += _msize;
    }
    if (_position + 16 <= _maxsize) {
        slideTimeAtom = SlideTime10Atom(_d + _position);
        _msize = (slideTimeAtom._data) ?slideTimeAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        unknown = UnknownSlideContainerChild(_d + _position, _maxsize - _position);
        _msize = (unknown._data) ?unknown._size :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        hashCodeAtom = HashCode10Atom(_d + _position);
        _msize = (hashCodeAtom._data) ?hashCodeAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        extTimeNodeContainer = ExtTimeNodeContainer(_d + _position, _maxsize - _position);
        _msize = (extTimeNodeContainer._data) ?extTimeNodeContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        buildListContainer = BuildListContainer(_d + _position, _maxsize - _position);
        _msize = (buildListContainer._data) ?buildListContainer._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ExObjListSubContainer::ExObjListSubContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._ExAviMovieContainer = ExAviMovieContainer(_d + _position, _maxsize - _position);
    _msize = anon._ExAviMovieContainer._size;
    if (_msize == 0) {
        anon._ExCDAudioContainer = ExCDAudioContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExCDAudioContainer._size;
    }
    if (_msize == 0) {
        anon._ExControlContainer = ExControlContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExControlContainer._size;
    }
    if (_msize == 0) {
        anon._ExHyperlinkContainer = ExHyperlinkContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExHyperlinkContainer._size;
    }
    if (_msize == 0) {
        anon._ExMCIMovieContainer = ExMCIMovieContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExMCIMovieContainer._size;
    }
    if (_msize == 0) {
        anon._ExMIDIAudioContainer = ExMIDIAudioContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExMIDIAudioContainer._size;
    }
    if (_msize == 0) {
        anon._ExOleEmbedContainer = ExOleEmbedContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExOleEmbedContainer._size;
    }
    if (_msize == 0) {
        anon._ExOleLinkContainer = ExOleLinkContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExOleLinkContainer._size;
    }
    if (_msize == 0) {
        anon._ExWAVAudioEmbeddedContainer = ExWAVAudioEmbeddedContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExWAVAudioEmbeddedContainer._size;
    }
    if (_msize == 0) {
        anon._ExWAVAudioLinkContainer = ExWAVAudioLinkContainer(_d + _position, _maxsize - _position);
        _msize = anon._ExWAVAudioLinkContainer._size;
    }
    if (_msize == 0) {
        anon._UnknownExObjListSubContainerChild = UnknownExObjListSubContainerChild(_d + _position, _maxsize - _position);
        _msize = anon._UnknownExObjListSubContainerChild._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const ExAviMovieContainer* ExObjListSubContainer::C_anon::get<ExAviMovieContainer>() const {
        return &_ExAviMovieContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExAviMovieContainer>() const {
        return _ExAviMovieContainer._data;
    }
    template <> const ExCDAudioContainer* ExObjListSubContainer::C_anon::get<ExCDAudioContainer>() const {
        return &_ExCDAudioContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExCDAudioContainer>() const {
        return _ExCDAudioContainer._data;
    }
    template <> const ExControlContainer* ExObjListSubContainer::C_anon::get<ExControlContainer>() const {
        return &_ExControlContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExControlContainer>() const {
        return _ExControlContainer._data;
    }
    template <> const ExHyperlinkContainer* ExObjListSubContainer::C_anon::get<ExHyperlinkContainer>() const {
        return &_ExHyperlinkContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExHyperlinkContainer>() const {
        return _ExHyperlinkContainer._data;
    }
    template <> const ExMCIMovieContainer* ExObjListSubContainer::C_anon::get<ExMCIMovieContainer>() const {
        return &_ExMCIMovieContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExMCIMovieContainer>() const {
        return _ExMCIMovieContainer._data;
    }
    template <> const ExMIDIAudioContainer* ExObjListSubContainer::C_anon::get<ExMIDIAudioContainer>() const {
        return &_ExMIDIAudioContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExMIDIAudioContainer>() const {
        return _ExMIDIAudioContainer._data;
    }
    template <> const ExOleEmbedContainer* ExObjListSubContainer::C_anon::get<ExOleEmbedContainer>() const {
        return &_ExOleEmbedContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExOleEmbedContainer>() const {
        return _ExOleEmbedContainer._data;
    }
    template <> const ExOleLinkContainer* ExObjListSubContainer::C_anon::get<ExOleLinkContainer>() const {
        return &_ExOleLinkContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExOleLinkContainer>() const {
        return _ExOleLinkContainer._data;
    }
    template <> const ExWAVAudioEmbeddedContainer* ExObjListSubContainer::C_anon::get<ExWAVAudioEmbeddedContainer>() const {
        return &_ExWAVAudioEmbeddedContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExWAVAudioEmbeddedContainer>() const {
        return _ExWAVAudioEmbeddedContainer._data;
    }
    template <> const ExWAVAudioLinkContainer* ExObjListSubContainer::C_anon::get<ExWAVAudioLinkContainer>() const {
        return &_ExWAVAudioLinkContainer;
    }
    template <> bool ExObjListSubContainer::C_anon::is<ExWAVAudioLinkContainer>() const {
        return _ExWAVAudioLinkContainer._data;
    }
    template <> const UnknownExObjListSubContainerChild* ExObjListSubContainer::C_anon::get<UnknownExObjListSubContainerChild>() const {
        return &_UnknownExObjListSubContainerChild;
    }
    template <> bool ExObjListSubContainer::C_anon::is<UnknownExObjListSubContainerChild>() const {
        return _UnknownExObjListSubContainerChild._data;
    }
}
MSO::OfficeArtDggContainer::OfficeArtDggContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x0F000)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    drawingGroup = OfficeArtFDGGBlock(_d + _position, _maxsize - _position);
    if (drawingGroup._data == 0) return;
    _msize = drawingGroup._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        blipStore = OfficeArtBStoreContainer(_d + _position, _maxsize - _position);
        _msize = (blipStore._data) ?blipStore._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        drawingPrimaryOptions = OfficeArtFOPT(_d + _position, _maxsize - _position);
        _msize = (drawingPrimaryOptions._data) ?drawingPrimaryOptions._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        drawingTertiaryOptions = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (drawingTertiaryOptions._data) ?drawingTertiaryOptions._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        colorMRU = OfficeArtColorMRUContainer(_d + _position, _maxsize - _position);
        _msize = (colorMRU._data) ?colorMRU._size :0;
        _position += _msize;
    }
    if (_position + 24 > _maxsize) return;
    splitColors = OfficeArtSplitMenuColorContainer(_d + _position);
    if (splitColors._data == 0) return;
    _msize = splitColors._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        blipStore2 = OfficeArtBStoreContainer(_d + _position, _maxsize - _position);
        _msize = (blipStore2._data) ?blipStore2._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        unknown = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (unknown._data) ?unknown._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
const quint32 MSO::OfficeArtFOPTEChoice::_size = 6;
MSO::OfficeArtFOPTEChoice::OfficeArtFOPTEChoice(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    anon._Rotation = Rotation(_d + _position);
    _msize = (anon._Rotation._data) ?Rotation::_size : 0;
    if (_msize == 0) {
        anon._ProtectionBooleanProperties = ProtectionBooleanProperties(_d + _position);
        _msize = (anon._ProtectionBooleanProperties._data) ?ProtectionBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._ITxid = ITxid(_d + _position);
        _msize = (anon._ITxid._data) ?ITxid::_size : 0;
    }
    if (_msize == 0) {
        anon._DxTextLeft = DxTextLeft(_d + _position);
        _msize = (anon._DxTextLeft._data) ?DxTextLeft::_size : 0;
    }
    if (_msize == 0) {
        anon._DyTextTop = DyTextTop(_d + _position);
        _msize = (anon._DyTextTop._data) ?DyTextTop::_size : 0;
    }
    if (_msize == 0) {
        anon._DxTextRight = DxTextRight(_d + _position);
        _msize = (anon._DxTextRight._data) ?DxTextRight::_size : 0;
    }
    if (_msize == 0) {
        anon._DyTextBottom = DyTextBottom(_d + _position);
        _msize = (anon._DyTextBottom._data) ?DyTextBottom::_size : 0;
    }
    if (_msize == 0) {
        anon._WrapText = WrapText(_d + _position);
        _msize = (anon._WrapText._data) ?WrapText::_size : 0;
    }
    if (_msize == 0) {
        anon._AnchorText = AnchorText(_d + _position);
        _msize = (anon._AnchorText._data) ?AnchorText::_size : 0;
    }
    if (_msize == 0) {
        anon._TxflTextFlow = TxflTextFlow(_d + _position);
        _msize = (anon._TxflTextFlow._data) ?TxflTextFlow::_size : 0;
    }
    if (_msize == 0) {
        anon._CdirFont = CdirFont(_d + _position);
        _msize = (anon._CdirFont._data) ?CdirFont::_size : 0;
    }
    if (_msize == 0) {
        anon._HspNext = HspNext(_d + _position);
        _msize = (anon._HspNext._data) ?HspNext::_size : 0;
    }
    if (_msize == 0) {
        anon._Txdir = Txdir(_d + _position);
        _msize = (anon._Txdir._data) ?Txdir::_size : 0;
    }
    if (_msize == 0) {
        anon._TextBooleanProperties = TextBooleanProperties(_d + _position);
        _msize = (anon._TextBooleanProperties._data) ?TextBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._CropFromTop = CropFromTop(_d + _position);
        _msize = (anon._CropFromTop._data) ?CropFromTop::_size : 0;
    }
    if (_msize == 0) {
        anon._CropFromBottom = CropFromBottom(_d + _position);
        _msize = (anon._CropFromBottom._data) ?CropFromBottom::_size : 0;
    }
    if (_msize == 0) {
        anon._CropFromLeft = CropFromLeft(_d + _position);
        _msize = (anon._CropFromLeft._data) ?CropFromLeft::_size : 0;
    }
    if (_msize == 0) {
        anon._CropFromRight = CropFromRight(_d + _position);
        _msize = (anon._CropFromRight._data) ?CropFromRight::_size : 0;
    }
    if (_msize == 0) {
        anon._Pib = Pib(_d + _position);
        _msize = (anon._Pib._data) ?Pib::_size : 0;
    }
    if (_msize == 0) {
        anon._PibName = PibName(_d + _position);
        _msize = (anon._PibName._data) ?PibName::_size : 0;
    }
    if (_msize == 0) {
        anon._PibFlags = PibFlags(_d + _position);
        _msize = (anon._PibFlags._data) ?PibFlags::_size : 0;
    }
    if (_msize == 0) {
        anon._PictureTransparent = PictureTransparent(_d + _position);
        _msize = (anon._PictureTransparent._data) ?PictureTransparent::_size : 0;
    }
    if (_msize == 0) {
        anon._PictureContrast = PictureContrast(_d + _position);
        _msize = (anon._PictureContrast._data) ?PictureContrast::_size : 0;
    }
    if (_msize == 0) {
        anon._PictureBrightness = PictureBrightness(_d + _position);
        _msize = (anon._PictureBrightness._data) ?PictureBrightness::_size : 0;
    }
    if (_msize == 0) {
        anon._BlipBooleanProperties = BlipBooleanProperties(_d + _position);
        _msize = (anon._BlipBooleanProperties._data) ?BlipBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._GeoLeft = GeoLeft(_d + _position);
        _msize = (anon._GeoLeft._data) ?GeoLeft::_size : 0;
    }
    if (_msize == 0) {
        anon._GeoTop = GeoTop(_d + _position);
        _msize = (anon._GeoTop._data) ?GeoTop::_size : 0;
    }
    if (_msize == 0) {
        anon._GeoRight = GeoRight(_d + _position);
        _msize = (anon._GeoRight._data) ?GeoRight::_size : 0;
    }
    if (_msize == 0) {
        anon._GeoBottom = GeoBottom(_d + _position);
        _msize = (anon._GeoBottom._data) ?GeoBottom::_size : 0;
    }
    if (_msize == 0) {
        anon._ShapePath = ShapePath(_d + _position);
        _msize = (anon._ShapePath._data) ?ShapePath::_size : 0;
    }
    if (_msize == 0) {
        anon._PVertices = PVertices(_d + _position);
        _msize = (anon._PVertices._data) ?PVertices::_size : 0;
    }
    if (_msize == 0) {
        anon._PSegmentInfo = PSegmentInfo(_d + _position);
        _msize = (anon._PSegmentInfo._data) ?PSegmentInfo::_size : 0;
    }
    if (_msize == 0) {
        anon._AdjustValue = AdjustValue(_d + _position);
        _msize = (anon._AdjustValue._data) ?AdjustValue::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust2Value = Adjust2Value(_d + _position);
        _msize = (anon._Adjust2Value._data) ?Adjust2Value::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust3Value = Adjust3Value(_d + _position);
        _msize = (anon._Adjust3Value._data) ?Adjust3Value::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust4Value = Adjust4Value(_d + _position);
        _msize = (anon._Adjust4Value._data) ?Adjust4Value::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust5Value = Adjust5Value(_d + _position);
        _msize = (anon._Adjust5Value._data) ?Adjust5Value::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust6Value = Adjust6Value(_d + _position);
        _msize = (anon._Adjust6Value._data) ?Adjust6Value::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust7Value = Adjust7Value(_d + _position);
        _msize = (anon._Adjust7Value._data) ?Adjust7Value::_size : 0;
    }
    if (_msize == 0) {
        anon._Adjust8Value = Adjust8Value(_d + _position);
        _msize = (anon._Adjust8Value._data) ?Adjust8Value::_size : 0;
    }
    if (_msize == 0) {
        anon._GeometryBooleanProperties = GeometryBooleanProperties(_d + _position);
        _msize = (anon._GeometryBooleanProperties._data) ?GeometryBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._FillType = FillType(_d + _position);
        _msize = (anon._FillType._data) ?FillType::_size : 0;
    }
    if (_msize == 0) {
        anon._FillColor = FillColor(_d + _position);
        _msize = (anon._FillColor._data) ?FillColor::_size : 0;
    }
    if (_msize == 0) {
        anon._FillOpacity = FillOpacity(_d + _position);
        _msize = (anon._FillOpacity._data) ?FillOpacity::_size : 0;
    }
    if (_msize == 0) {
        anon._FillBackColor = FillBackColor(_d + _position);
        _msize = (anon._FillBackColor._data) ?FillBackColor::_size : 0;
    }
    if (_msize == 0) {
        anon._FillBackOpacity = FillBackOpacity(_d + _position);
        _msize = (anon._FillBackOpacity._data) ?FillBackOpacity::_size : 0;
    }
    if (_msize == 0) {
        anon._FillCrMod = FillCrMod(_d + _position);
        _msize = (anon._FillCrMod._data) ?FillCrMod::_size : 0;
    }
    if (_msize == 0) {
        anon._FillBlip = FillBlip(_d + _position);
        _msize = (anon._FillBlip._data) ?FillBlip::_size : 0;
    }
    if (_msize == 0) {
        anon._FillBlipName = FillBlipName(_d + _position);
        _msize = (anon._FillBlipName._data) ?FillBlipName::_size : 0;
    }
    if (_msize == 0) {
        anon._FillBlipFlags = FillBlipFlags(_d + _position);
        _msize = (anon._FillBlipFlags._data) ?FillBlipFlags::_size : 0;
    }
    if (_msize == 0) {
        anon._FillWidth = FillWidth(_d + _position);
        _msize = (anon._FillWidth._data) ?FillWidth::_size : 0;
    }
    if (_msize == 0) {
        anon._FillHeight = FillHeight(_d + _position);
        _msize = (anon._FillHeight._data) ?FillHeight::_size : 0;
    }
    if (_msize == 0) {
        anon._FillAngle = FillAngle(_d + _position);
        _msize = (anon._FillAngle._data) ?FillAngle::_size : 0;
    }
    if (_msize == 0) {
        anon._FillFocus = FillFocus(_d + _position);
        _msize = (anon._FillFocus._data) ?FillFocus::_size : 0;
    }
    if (_msize == 0) {
        anon._FillToLeft = FillToLeft(_d + _position);
        _msize = (anon._FillToLeft._data) ?FillToLeft::_size : 0;
    }
    if (_msize == 0) {
        anon._FillToTop = FillToTop(_d + _position);
        _msize = (anon._FillToTop._data) ?FillToTop::_size : 0;
    }
    if (_msize == 0) {
        anon._FillToRight = FillToRight(_d + _position);
        _msize = (anon._FillToRight._data) ?FillToRight::_size : 0;
    }
    if (_msize == 0) {
        anon._FillToBottom = FillToBottom(_d + _position);
        _msize = (anon._FillToBottom._data) ?FillToBottom::_size : 0;
    }
    if (_msize == 0) {
        anon._FillRectLeft = FillRectLeft(_d + _position);
        _msize = (anon._FillRectLeft._data) ?FillRectLeft::_size : 0;
    }
    if (_msize == 0) {
        anon._FillRectTop = FillRectTop(_d + _position);
        _msize = (anon._FillRectTop._data) ?FillRectTop::_size : 0;
    }
    if (_msize == 0) {
        anon._FillRectRight = FillRectRight(_d + _position);
        _msize = (anon._FillRectRight._data) ?FillRectRight::_size : 0;
    }
    if (_msize == 0) {
        anon._FillRectBottom = FillRectBottom(_d + _position);
        _msize = (anon._FillRectBottom._data) ?FillRectBottom::_size : 0;
    }
    if (_msize == 0) {
        anon._FillDztype = FillDztype(_d + _position);
        _msize = (anon._FillDztype._data) ?FillDztype::_size : 0;
    }
    if (_msize == 0) {
        anon._FillShadePreset = FillShadePreset(_d + _position);
        _msize = (anon._FillShadePreset._data) ?FillShadePreset::_size : 0;
    }
    if (_msize == 0) {
        anon._FillShadeColors = FillShadeColors(_d + _position);
        _msize = (anon._FillShadeColors._data) ?FillShadeColors::_size : 0;
    }
    if (_msize == 0) {
        anon._FillOriginX = FillOriginX(_d + _position);
        _msize = (anon._FillOriginX._data) ?FillOriginX::_size : 0;
    }
    if (_msize == 0) {
        anon._FillOriginY = FillOriginY(_d + _position);
        _msize = (anon._FillOriginY._data) ?FillOriginY::_size : 0;
    }
    if (_msize == 0) {
        anon._FillShapeOriginX = FillShapeOriginX(_d + _position);
        _msize = (anon._FillShapeOriginX._data) ?FillShapeOriginX::_size : 0;
    }
    if (_msize == 0) {
        anon._FillShapeOriginY = FillShapeOriginY(_d + _position);
        _msize = (anon._FillShapeOriginY._data) ?FillShapeOriginY::_size : 0;
    }
    if (_msize == 0) {
        anon._FillColorExt = FillColorExt(_d + _position);
        _msize = (anon._FillColorExt._data) ?FillColorExt::_size : 0;
    }
    if (_msize == 0) {
        anon._FillBackColorExt = FillBackColorExt(_d + _position);
        _msize = (anon._FillBackColorExt._data) ?FillBackColorExt::_size : 0;
    }
    if (_msize == 0) {
        anon._FillStyleBooleanProperties = FillStyleBooleanProperties(_d + _position);
        _msize = (anon._FillStyleBooleanProperties._data) ?FillStyleBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._LineColor = LineColor(_d + _position);
        _msize = (anon._LineColor._data) ?LineColor::_size : 0;
    }
    if (_msize == 0) {
        anon._LineOpacity = LineOpacity(_d + _position);
        _msize = (anon._LineOpacity._data) ?LineOpacity::_size : 0;
    }
    if (_msize == 0) {
        anon._LineBackColor = LineBackColor(_d + _position);
        _msize = (anon._LineBackColor._data) ?LineBackColor::_size : 0;
    }
    if (_msize == 0) {
        anon._LineFillBlip = LineFillBlip(_d + _position);
        _msize = (anon._LineFillBlip._data) ?LineFillBlip::_size : 0;
    }
    if (_msize == 0) {
        anon._LineWidth = LineWidth(_d + _position);
        _msize = (anon._LineWidth._data) ?LineWidth::_size : 0;
    }
    if (_msize == 0) {
        anon._LineStyle = LineStyle(_d + _position);
        _msize = (anon._LineStyle._data) ?LineStyle::_size : 0;
    }
    if (_msize == 0) {
        anon._LineDashing = LineDashing(_d + _position);
        _msize = (anon._LineDashing._data) ?LineDashing::_size : 0;
    }
    if (_msize == 0) {
        anon._LineStartArrowhead = LineStartArrowhead(_d + _position);
        _msize = (anon._LineStartArrowhead._data) ?LineStartArrowhead::_size : 0;
    }
    if (_msize == 0) {
        anon._LineEndArrowhead = LineEndArrowhead(_d + _position);
        _msize = (anon._LineEndArrowhead._data) ?LineEndArrowhead::_size : 0;
    }
    if (_msize == 0) {
        anon._LineStartArrowWidth = LineStartArrowWidth(_d + _position);
        _msize = (anon._LineStartArrowWidth._data) ?LineStartArrowWidth::_size : 0;
    }
    if (_msize == 0) {
        anon._LineStartArrowLength = LineStartArrowLength(_d + _position);
        _msize = (anon._LineStartArrowLength._data) ?LineStartArrowLength::_size : 0;
    }
    if (_msize == 0) {
        anon._LineEndArrowWidth = LineEndArrowWidth(_d + _position);
        _msize = (anon._LineEndArrowWidth._data) ?LineEndArrowWidth::_size : 0;
    }
    if (_msize == 0) {
        anon._LineEndArrowLength = LineEndArrowLength(_d + _position);
        _msize = (anon._LineEndArrowLength._data) ?LineEndArrowLength::_size : 0;
    }
    if (_msize == 0) {
        anon._LineJoinStyle = LineJoinStyle(_d + _position);
        _msize = (anon._LineJoinStyle._data) ?LineJoinStyle::_size : 0;
    }
    if (_msize == 0) {
        anon._LineStyleBooleanProperties = LineStyleBooleanProperties(_d + _position);
        _msize = (anon._LineStyleBooleanProperties._data) ?LineStyleBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._ShadowType = ShadowType(_d + _position);
        _msize = (anon._ShadowType._data) ?ShadowType::_size : 0;
    }
    if (_msize == 0) {
        anon._ShadowColor = ShadowColor(_d + _position);
        _msize = (anon._ShadowColor._data) ?ShadowColor::_size : 0;
    }
    if (_msize == 0) {
        anon._ShadowOpacity = ShadowOpacity(_d + _position);
        _msize = (anon._ShadowOpacity._data) ?ShadowOpacity::_size : 0;
    }
    if (_msize == 0) {
        anon._ShadowOffsetX = ShadowOffsetX(_d + _position);
        _msize = (anon._ShadowOffsetX._data) ?ShadowOffsetX::_size : 0;
    }
    if (_msize == 0) {
        anon._ShadowOffsetY = ShadowOffsetY(_d + _position);
        _msize = (anon._ShadowOffsetY._data) ?ShadowOffsetY::_size : 0;
    }
    if (_msize == 0) {
        anon._ShadowStyleBooleanProperties = ShadowStyleBooleanProperties(_d + _position);
        _msize = (anon._ShadowStyleBooleanProperties._data) ?ShadowStyleBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._HspMaster = HspMaster(_d + _position);
        _msize = (anon._HspMaster._data) ?HspMaster::_size : 0;
    }
    if (_msize == 0) {
        anon._Cxstyle = Cxstyle(_d + _position);
        _msize = (anon._Cxstyle._data) ?Cxstyle::_size : 0;
    }
    if (_msize == 0) {
        anon._BWMode = BWMode(_d + _position);
        _msize = (anon._BWMode._data) ?BWMode::_size : 0;
    }
    if (_msize == 0) {
        anon._ShapeBooleanProperties = ShapeBooleanProperties(_d + _position);
        _msize = (anon._ShapeBooleanProperties._data) ?ShapeBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._DxyCalloutGap = DxyCalloutGap(_d + _position);
        _msize = (anon._DxyCalloutGap._data) ?DxyCalloutGap::_size : 0;
    }
    if (_msize == 0) {
        anon._Spcoa = Spcoa(_d + _position);
        _msize = (anon._Spcoa._data) ?Spcoa::_size : 0;
    }
    if (_msize == 0) {
        anon._Spcod = Spcod(_d + _position);
        _msize = (anon._Spcod._data) ?Spcod::_size : 0;
    }
    if (_msize == 0) {
        anon._DxyCalloutDropSpecified = DxyCalloutDropSpecified(_d + _position);
        _msize = (anon._DxyCalloutDropSpecified._data) ?DxyCalloutDropSpecified::_size : 0;
    }
    if (_msize == 0) {
        anon._DxyCalloutLengthSpecified = DxyCalloutLengthSpecified(_d + _position);
        _msize = (anon._DxyCalloutLengthSpecified._data) ?DxyCalloutLengthSpecified::_size : 0;
    }
    if (_msize == 0) {
        anon._CalloutBooleanProperties = CalloutBooleanProperties(_d + _position);
        _msize = (anon._CalloutBooleanProperties._data) ?CalloutBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._PWrapPolygonVertices = PWrapPolygonVertices(_d + _position);
        _msize = (anon._PWrapPolygonVertices._data) ?PWrapPolygonVertices::_size : 0;
    }
    if (_msize == 0) {
        anon._DxWrapDistLeft = DxWrapDistLeft(_d + _position);
        _msize = (anon._DxWrapDistLeft._data) ?DxWrapDistLeft::_size : 0;
    }
    if (_msize == 0) {
        anon._DyWrapDistTop = DyWrapDistTop(_d + _position);
        _msize = (anon._DyWrapDistTop._data) ?DyWrapDistTop::_size : 0;
    }
    if (_msize == 0) {
        anon._DxWrapDistRight = DxWrapDistRight(_d + _position);
        _msize = (anon._DxWrapDistRight._data) ?DxWrapDistRight::_size : 0;
    }
    if (_msize == 0) {
        anon._DyWrapDistBottom = DyWrapDistBottom(_d + _position);
        _msize = (anon._DyWrapDistBottom._data) ?DyWrapDistBottom::_size : 0;
    }
    if (_msize == 0) {
        anon._LidRegroup = LidRegroup(_d + _position);
        _msize = (anon._LidRegroup._data) ?LidRegroup::_size : 0;
    }
    if (_msize == 0) {
        anon._PosH = PosH(_d + _position);
        _msize = (anon._PosH._data) ?PosH::_size : 0;
    }
    if (_msize == 0) {
        anon._PosRelH = PosRelH(_d + _position);
        _msize = (anon._PosRelH._data) ?PosRelH::_size : 0;
    }
    if (_msize == 0) {
        anon._PosV = PosV(_d + _position);
        _msize = (anon._PosV._data) ?PosV::_size : 0;
    }
    if (_msize == 0) {
        anon._PosRelV = PosRelV(_d + _position);
        _msize = (anon._PosRelV._data) ?PosRelV::_size : 0;
    }
    if (_msize == 0) {
        anon._PctHR = PctHR(_d + _position);
        _msize = (anon._PctHR._data) ?PctHR::_size : 0;
    }
    if (_msize == 0) {
        anon._AlignHR = AlignHR(_d + _position);
        _msize = (anon._AlignHR._data) ?AlignHR::_size : 0;
    }
    if (_msize == 0) {
        anon._DxHeightHR = DxHeightHR(_d + _position);
        _msize = (anon._DxHeightHR._data) ?DxHeightHR::_size : 0;
    }
    if (_msize == 0) {
        anon._DxWidthHR = DxWidthHR(_d + _position);
        _msize = (anon._DxWidthHR._data) ?DxWidthHR::_size : 0;
    }
    if (_msize == 0) {
        anon._GroupShapeBooleanProperties = GroupShapeBooleanProperties(_d + _position);
        _msize = (anon._GroupShapeBooleanProperties._data) ?GroupShapeBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._WzFillId = WzFillId(_d + _position);
        _msize = (anon._WzFillId._data) ?WzFillId::_size : 0;
    }
    if (_msize == 0) {
        anon._DiagramBooleanProperties = DiagramBooleanProperties(_d + _position);
        _msize = (anon._DiagramBooleanProperties._data) ?DiagramBooleanProperties::_size : 0;
    }
    if (_msize == 0) {
        anon._OfficeArtFOPTE = OfficeArtFOPTE(_d + _position);
        _msize = (anon._OfficeArtFOPTE._data) ?OfficeArtFOPTE::_size : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
    _data = _d;
}
namespace MSO {
    template <> const Rotation* OfficeArtFOPTEChoice::C_anon::get<Rotation>() const {
        return &_Rotation;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Rotation>() const {
        return _Rotation._data;
    }
    template <> const ProtectionBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<ProtectionBooleanProperties>() const {
        return &_ProtectionBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ProtectionBooleanProperties>() const {
        return _ProtectionBooleanProperties._data;
    }
    template <> const ITxid* OfficeArtFOPTEChoice::C_anon::get<ITxid>() const {
        return &_ITxid;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ITxid>() const {
        return _ITxid._data;
    }
    template <> const DxTextLeft* OfficeArtFOPTEChoice::C_anon::get<DxTextLeft>() const {
        return &_DxTextLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxTextLeft>() const {
        return _DxTextLeft._data;
    }
    template <> const DyTextTop* OfficeArtFOPTEChoice::C_anon::get<DyTextTop>() const {
        return &_DyTextTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyTextTop>() const {
        return _DyTextTop._data;
    }
    template <> const DxTextRight* OfficeArtFOPTEChoice::C_anon::get<DxTextRight>() const {
        return &_DxTextRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxTextRight>() const {
        return _DxTextRight._data;
    }
    template <> const DyTextBottom* OfficeArtFOPTEChoice::C_anon::get<DyTextBottom>() const {
        return &_DyTextBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyTextBottom>() const {
        return _DyTextBottom._data;
    }
    template <> const WrapText* OfficeArtFOPTEChoice::C_anon::get<WrapText>() const {
        return &_WrapText;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<WrapText>() const {
        return _WrapText._data;
    }
    template <> const AnchorText* OfficeArtFOPTEChoice::C_anon::get<AnchorText>() const {
        return &_AnchorText;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<AnchorText>() const {
        return _AnchorText._data;
    }
    template <> const TxflTextFlow* OfficeArtFOPTEChoice::C_anon::get<TxflTextFlow>() const {
        return &_TxflTextFlow;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<TxflTextFlow>() const {
        return _TxflTextFlow._data;
    }
    template <> const CdirFont* OfficeArtFOPTEChoice::C_anon::get<CdirFont>() const {
        return &_CdirFont;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CdirFont>() const {
        return _CdirFont._data;
    }
    template <> const HspNext* OfficeArtFOPTEChoice::C_anon::get<HspNext>() const {
        return &_HspNext;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<HspNext>() const {
        return _HspNext._data;
    }
    template <> const Txdir* OfficeArtFOPTEChoice::C_anon::get<Txdir>() const {
        return &_Txdir;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Txdir>() const {
        return _Txdir._data;
    }
    template <> const TextBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<TextBooleanProperties>() const {
        return &_TextBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<TextBooleanProperties>() const {
        return _TextBooleanProperties._data;
    }
    template <> const CropFromTop* OfficeArtFOPTEChoice::C_anon::get<CropFromTop>() const {
        return &_CropFromTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromTop>() const {
        return _CropFromTop._data;
    }
    template <> const CropFromBottom* OfficeArtFOPTEChoice::C_anon::get<CropFromBottom>() const {
        return &_CropFromBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromBottom>() const {
        return _CropFromBottom._data;
    }
    template <> const CropFromLeft* OfficeArtFOPTEChoice::C_anon::get<CropFromLeft>() const {
        return &_CropFromLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromLeft>() const {
        return _CropFromLeft._data;
    }
    template <> const CropFromRight* OfficeArtFOPTEChoice::C_anon::get<CropFromRight>() const {
        return &_CropFromRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CropFromRight>() const {
        return _CropFromRight._data;
    }
    template <> const Pib* OfficeArtFOPTEChoice::C_anon::get<Pib>() const {
        return &_Pib;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Pib>() const {
        return _Pib._data;
    }
    template <> const PibName* OfficeArtFOPTEChoice::C_anon::get<PibName>() const {
        return &_PibName;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PibName>() const {
        return _PibName._data;
    }
    template <> const PibFlags* OfficeArtFOPTEChoice::C_anon::get<PibFlags>() const {
        return &_PibFlags;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PibFlags>() const {
        return _PibFlags._data;
    }
    template <> const PictureTransparent* OfficeArtFOPTEChoice::C_anon::get<PictureTransparent>() const {
        return &_PictureTransparent;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PictureTransparent>() const {
        return _PictureTransparent._data;
    }
    template <> const PictureContrast* OfficeArtFOPTEChoice::C_anon::get<PictureContrast>() const {
        return &_PictureContrast;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PictureContrast>() const {
        return _PictureContrast._data;
    }
    template <> const PictureBrightness* OfficeArtFOPTEChoice::C_anon::get<PictureBrightness>() const {
        return &_PictureBrightness;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PictureBrightness>() const {
        return _PictureBrightness._data;
    }
    template <> const BlipBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<BlipBooleanProperties>() const {
        return &_BlipBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BlipBooleanProperties>() const {
        return _BlipBooleanProperties._data;
    }
    template <> const GeoLeft* OfficeArtFOPTEChoice::C_anon::get<GeoLeft>() const {
        return &_GeoLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoLeft>() const {
        return _GeoLeft._data;
    }
    template <> const GeoTop* OfficeArtFOPTEChoice::C_anon::get<GeoTop>() const {
        return &_GeoTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoTop>() const {
        return _GeoTop._data;
    }
    template <> const GeoRight* OfficeArtFOPTEChoice::C_anon::get<GeoRight>() const {
        return &_GeoRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoRight>() const {
        return _GeoRight._data;
    }
    template <> const GeoBottom* OfficeArtFOPTEChoice::C_anon::get<GeoBottom>() const {
        return &_GeoBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeoBottom>() const {
        return _GeoBottom._data;
    }
    template <> const ShapePath* OfficeArtFOPTEChoice::C_anon::get<ShapePath>() const {
        return &_ShapePath;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShapePath>() const {
        return _ShapePath._data;
    }
    template <> const PVertices* OfficeArtFOPTEChoice::C_anon::get<PVertices>() const {
        return &_PVertices;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PVertices>() const {
        return _PVertices._data;
    }
    template <> const PSegmentInfo* OfficeArtFOPTEChoice::C_anon::get<PSegmentInfo>() const {
        return &_PSegmentInfo;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PSegmentInfo>() const {
        return _PSegmentInfo._data;
    }
    template <> const AdjustValue* OfficeArtFOPTEChoice::C_anon::get<AdjustValue>() const {
        return &_AdjustValue;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<AdjustValue>() const {
        return _AdjustValue._data;
    }
    template <> const Adjust2Value* OfficeArtFOPTEChoice::C_anon::get<Adjust2Value>() const {
        return &_Adjust2Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust2Value>() const {
        return _Adjust2Value._data;
    }
    template <> const Adjust3Value* OfficeArtFOPTEChoice::C_anon::get<Adjust3Value>() const {
        return &_Adjust3Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust3Value>() const {
        return _Adjust3Value._data;
    }
    template <> const Adjust4Value* OfficeArtFOPTEChoice::C_anon::get<Adjust4Value>() const {
        return &_Adjust4Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust4Value>() const {
        return _Adjust4Value._data;
    }
    template <> const Adjust5Value* OfficeArtFOPTEChoice::C_anon::get<Adjust5Value>() const {
        return &_Adjust5Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust5Value>() const {
        return _Adjust5Value._data;
    }
    template <> const Adjust6Value* OfficeArtFOPTEChoice::C_anon::get<Adjust6Value>() const {
        return &_Adjust6Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust6Value>() const {
        return _Adjust6Value._data;
    }
    template <> const Adjust7Value* OfficeArtFOPTEChoice::C_anon::get<Adjust7Value>() const {
        return &_Adjust7Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust7Value>() const {
        return _Adjust7Value._data;
    }
    template <> const Adjust8Value* OfficeArtFOPTEChoice::C_anon::get<Adjust8Value>() const {
        return &_Adjust8Value;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Adjust8Value>() const {
        return _Adjust8Value._data;
    }
    template <> const GeometryBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<GeometryBooleanProperties>() const {
        return &_GeometryBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GeometryBooleanProperties>() const {
        return _GeometryBooleanProperties._data;
    }
    template <> const FillType* OfficeArtFOPTEChoice::C_anon::get<FillType>() const {
        return &_FillType;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillType>() const {
        return _FillType._data;
    }
    template <> const FillColor* OfficeArtFOPTEChoice::C_anon::get<FillColor>() const {
        return &_FillColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillColor>() const {
        return _FillColor._data;
    }
    template <> const FillOpacity* OfficeArtFOPTEChoice::C_anon::get<FillOpacity>() const {
        return &_FillOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillOpacity>() const {
        return _FillOpacity._data;
    }
    template <> const FillBackColor* OfficeArtFOPTEChoice::C_anon::get<FillBackColor>() const {
        return &_FillBackColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBackColor>() const {
        return _FillBackColor._data;
    }
    template <> const FillBackOpacity* OfficeArtFOPTEChoice::C_anon::get<FillBackOpacity>() const {
        return &_FillBackOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBackOpacity>() const {
        return _FillBackOpacity._data;
    }
    template <> const FillCrMod* OfficeArtFOPTEChoice::C_anon::get<FillCrMod>() const {
        return &_FillCrMod;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillCrMod>() const {
        return _FillCrMod._data;
    }
    template <> const FillBlip* OfficeArtFOPTEChoice::C_anon::get<FillBlip>() const {
        return &_FillBlip;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBlip>() const {
        return _FillBlip._data;
    }
    template <> const FillBlipName* OfficeArtFOPTEChoice::C_anon::get<FillBlipName>() const {
        return &_FillBlipName;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBlipName>() const {
        return _FillBlipName._data;
    }
    template <> const FillBlipFlags* OfficeArtFOPTEChoice::C_anon::get<FillBlipFlags>() const {
        return &_FillBlipFlags;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBlipFlags>() const {
        return _FillBlipFlags._data;
    }
    template <> const FillWidth* OfficeArtFOPTEChoice::C_anon::get<FillWidth>() const {
        return &_FillWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillWidth>() const {
        return _FillWidth._data;
    }
    template <> const FillHeight* OfficeArtFOPTEChoice::C_anon::get<FillHeight>() const {
        return &_FillHeight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillHeight>() const {
        return _FillHeight._data;
    }
    template <> const FillAngle* OfficeArtFOPTEChoice::C_anon::get<FillAngle>() const {
        return &_FillAngle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillAngle>() const {
        return _FillAngle._data;
    }
    template <> const FillFocus* OfficeArtFOPTEChoice::C_anon::get<FillFocus>() const {
        return &_FillFocus;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillFocus>() const {
        return _FillFocus._data;
    }
    template <> const FillToLeft* OfficeArtFOPTEChoice::C_anon::get<FillToLeft>() const {
        return &_FillToLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToLeft>() const {
        return _FillToLeft._data;
    }
    template <> const FillToTop* OfficeArtFOPTEChoice::C_anon::get<FillToTop>() const {
        return &_FillToTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToTop>() const {
        return _FillToTop._data;
    }
    template <> const FillToRight* OfficeArtFOPTEChoice::C_anon::get<FillToRight>() const {
        return &_FillToRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToRight>() const {
        return _FillToRight._data;
    }
    template <> const FillToBottom* OfficeArtFOPTEChoice::C_anon::get<FillToBottom>() const {
        return &_FillToBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillToBottom>() const {
        return _FillToBottom._data;
    }
    template <> const FillRectLeft* OfficeArtFOPTEChoice::C_anon::get<FillRectLeft>() const {
        return &_FillRectLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectLeft>() const {
        return _FillRectLeft._data;
    }
    template <> const FillRectTop* OfficeArtFOPTEChoice::C_anon::get<FillRectTop>() const {
        return &_FillRectTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectTop>() const {
        return _FillRectTop._data;
    }
    template <> const FillRectRight* OfficeArtFOPTEChoice::C_anon::get<FillRectRight>() const {
        return &_FillRectRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectRight>() const {
        return _FillRectRight._data;
    }
    template <> const FillRectBottom* OfficeArtFOPTEChoice::C_anon::get<FillRectBottom>() const {
        return &_FillRectBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillRectBottom>() const {
        return _FillRectBottom._data;
    }
    template <> const FillDztype* OfficeArtFOPTEChoice::C_anon::get<FillDztype>() const {
        return &_FillDztype;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillDztype>() const {
        return _FillDztype._data;
    }
    template <> const FillShadePreset* OfficeArtFOPTEChoice::C_anon::get<FillShadePreset>() const {
        return &_FillShadePreset;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShadePreset>() const {
        return _FillShadePreset._data;
    }
    template <> const FillShadeColors* OfficeArtFOPTEChoice::C_anon::get<FillShadeColors>() const {
        return &_FillShadeColors;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShadeColors>() const {
        return _FillShadeColors._data;
    }
    template <> const FillOriginX* OfficeArtFOPTEChoice::C_anon::get<FillOriginX>() const {
        return &_FillOriginX;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillOriginX>() const {
        return _FillOriginX._data;
    }
    template <> const FillOriginY* OfficeArtFOPTEChoice::C_anon::get<FillOriginY>() const {
        return &_FillOriginY;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillOriginY>() const {
        return _FillOriginY._data;
    }
    template <> const FillShapeOriginX* OfficeArtFOPTEChoice::C_anon::get<FillShapeOriginX>() const {
        return &_FillShapeOriginX;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShapeOriginX>() const {
        return _FillShapeOriginX._data;
    }
    template <> const FillShapeOriginY* OfficeArtFOPTEChoice::C_anon::get<FillShapeOriginY>() const {
        return &_FillShapeOriginY;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillShapeOriginY>() const {
        return _FillShapeOriginY._data;
    }
    template <> const FillColorExt* OfficeArtFOPTEChoice::C_anon::get<FillColorExt>() const {
        return &_FillColorExt;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillColorExt>() const {
        return _FillColorExt._data;
    }
    template <> const FillBackColorExt* OfficeArtFOPTEChoice::C_anon::get<FillBackColorExt>() const {
        return &_FillBackColorExt;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillBackColorExt>() const {
        return _FillBackColorExt._data;
    }
    template <> const FillStyleBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<FillStyleBooleanProperties>() const {
        return &_FillStyleBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<FillStyleBooleanProperties>() const {
        return _FillStyleBooleanProperties._data;
    }
    template <> const LineColor* OfficeArtFOPTEChoice::C_anon::get<LineColor>() const {
        return &_LineColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineColor>() const {
        return _LineColor._data;
    }
    template <> const LineOpacity* OfficeArtFOPTEChoice::C_anon::get<LineOpacity>() const {
        return &_LineOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineOpacity>() const {
        return _LineOpacity._data;
    }
    template <> const LineBackColor* OfficeArtFOPTEChoice::C_anon::get<LineBackColor>() const {
        return &_LineBackColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineBackColor>() const {
        return _LineBackColor._data;
    }
    template <> const LineFillBlip* OfficeArtFOPTEChoice::C_anon::get<LineFillBlip>() const {
        return &_LineFillBlip;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineFillBlip>() const {
        return _LineFillBlip._data;
    }
    template <> const LineWidth* OfficeArtFOPTEChoice::C_anon::get<LineWidth>() const {
        return &_LineWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineWidth>() const {
        return _LineWidth._data;
    }
    template <> const LineStyle* OfficeArtFOPTEChoice::C_anon::get<LineStyle>() const {
        return &_LineStyle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStyle>() const {
        return _LineStyle._data;
    }
    template <> const LineDashing* OfficeArtFOPTEChoice::C_anon::get<LineDashing>() const {
        return &_LineDashing;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineDashing>() const {
        return _LineDashing._data;
    }
    template <> const LineStartArrowhead* OfficeArtFOPTEChoice::C_anon::get<LineStartArrowhead>() const {
        return &_LineStartArrowhead;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStartArrowhead>() const {
        return _LineStartArrowhead._data;
    }
    template <> const LineEndArrowhead* OfficeArtFOPTEChoice::C_anon::get<LineEndArrowhead>() const {
        return &_LineEndArrowhead;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineEndArrowhead>() const {
        return _LineEndArrowhead._data;
    }
    template <> const LineStartArrowWidth* OfficeArtFOPTEChoice::C_anon::get<LineStartArrowWidth>() const {
        return &_LineStartArrowWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStartArrowWidth>() const {
        return _LineStartArrowWidth._data;
    }
    template <> const LineStartArrowLength* OfficeArtFOPTEChoice::C_anon::get<LineStartArrowLength>() const {
        return &_LineStartArrowLength;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStartArrowLength>() const {
        return _LineStartArrowLength._data;
    }
    template <> const LineEndArrowWidth* OfficeArtFOPTEChoice::C_anon::get<LineEndArrowWidth>() const {
        return &_LineEndArrowWidth;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineEndArrowWidth>() const {
        return _LineEndArrowWidth._data;
    }
    template <> const LineEndArrowLength* OfficeArtFOPTEChoice::C_anon::get<LineEndArrowLength>() const {
        return &_LineEndArrowLength;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineEndArrowLength>() const {
        return _LineEndArrowLength._data;
    }
    template <> const LineJoinStyle* OfficeArtFOPTEChoice::C_anon::get<LineJoinStyle>() const {
        return &_LineJoinStyle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineJoinStyle>() const {
        return _LineJoinStyle._data;
    }
    template <> const LineStyleBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<LineStyleBooleanProperties>() const {
        return &_LineStyleBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LineStyleBooleanProperties>() const {
        return _LineStyleBooleanProperties._data;
    }
    template <> const ShadowType* OfficeArtFOPTEChoice::C_anon::get<ShadowType>() const {
        return &_ShadowType;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowType>() const {
        return _ShadowType._data;
    }
    template <> const ShadowColor* OfficeArtFOPTEChoice::C_anon::get<ShadowColor>() const {
        return &_ShadowColor;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowColor>() const {
        return _ShadowColor._data;
    }
    template <> const ShadowOpacity* OfficeArtFOPTEChoice::C_anon::get<ShadowOpacity>() const {
        return &_ShadowOpacity;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowOpacity>() const {
        return _ShadowOpacity._data;
    }
    template <> const ShadowOffsetX* OfficeArtFOPTEChoice::C_anon::get<ShadowOffsetX>() const {
        return &_ShadowOffsetX;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowOffsetX>() const {
        return _ShadowOffsetX._data;
    }
    template <> const ShadowOffsetY* OfficeArtFOPTEChoice::C_anon::get<ShadowOffsetY>() const {
        return &_ShadowOffsetY;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowOffsetY>() const {
        return _ShadowOffsetY._data;
    }
    template <> const ShadowStyleBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<ShadowStyleBooleanProperties>() const {
        return &_ShadowStyleBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShadowStyleBooleanProperties>() const {
        return _ShadowStyleBooleanProperties._data;
    }
    template <> const HspMaster* OfficeArtFOPTEChoice::C_anon::get<HspMaster>() const {
        return &_HspMaster;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<HspMaster>() const {
        return _HspMaster._data;
    }
    template <> const Cxstyle* OfficeArtFOPTEChoice::C_anon::get<Cxstyle>() const {
        return &_Cxstyle;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Cxstyle>() const {
        return _Cxstyle._data;
    }
    template <> const BWMode* OfficeArtFOPTEChoice::C_anon::get<BWMode>() const {
        return &_BWMode;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<BWMode>() const {
        return _BWMode._data;
    }
    template <> const ShapeBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<ShapeBooleanProperties>() const {
        return &_ShapeBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<ShapeBooleanProperties>() const {
        return _ShapeBooleanProperties._data;
    }
    template <> const DxyCalloutGap* OfficeArtFOPTEChoice::C_anon::get<DxyCalloutGap>() const {
        return &_DxyCalloutGap;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxyCalloutGap>() const {
        return _DxyCalloutGap._data;
    }
    template <> const Spcoa* OfficeArtFOPTEChoice::C_anon::get<Spcoa>() const {
        return &_Spcoa;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Spcoa>() const {
        return _Spcoa._data;
    }
    template <> const Spcod* OfficeArtFOPTEChoice::C_anon::get<Spcod>() const {
        return &_Spcod;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<Spcod>() const {
        return _Spcod._data;
    }
    template <> const DxyCalloutDropSpecified* OfficeArtFOPTEChoice::C_anon::get<DxyCalloutDropSpecified>() const {
        return &_DxyCalloutDropSpecified;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxyCalloutDropSpecified>() const {
        return _DxyCalloutDropSpecified._data;
    }
    template <> const DxyCalloutLengthSpecified* OfficeArtFOPTEChoice::C_anon::get<DxyCalloutLengthSpecified>() const {
        return &_DxyCalloutLengthSpecified;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxyCalloutLengthSpecified>() const {
        return _DxyCalloutLengthSpecified._data;
    }
    template <> const CalloutBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<CalloutBooleanProperties>() const {
        return &_CalloutBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<CalloutBooleanProperties>() const {
        return _CalloutBooleanProperties._data;
    }
    template <> const PWrapPolygonVertices* OfficeArtFOPTEChoice::C_anon::get<PWrapPolygonVertices>() const {
        return &_PWrapPolygonVertices;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PWrapPolygonVertices>() const {
        return _PWrapPolygonVertices._data;
    }
    template <> const DxWrapDistLeft* OfficeArtFOPTEChoice::C_anon::get<DxWrapDistLeft>() const {
        return &_DxWrapDistLeft;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxWrapDistLeft>() const {
        return _DxWrapDistLeft._data;
    }
    template <> const DyWrapDistTop* OfficeArtFOPTEChoice::C_anon::get<DyWrapDistTop>() const {
        return &_DyWrapDistTop;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyWrapDistTop>() const {
        return _DyWrapDistTop._data;
    }
    template <> const DxWrapDistRight* OfficeArtFOPTEChoice::C_anon::get<DxWrapDistRight>() const {
        return &_DxWrapDistRight;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxWrapDistRight>() const {
        return _DxWrapDistRight._data;
    }
    template <> const DyWrapDistBottom* OfficeArtFOPTEChoice::C_anon::get<DyWrapDistBottom>() const {
        return &_DyWrapDistBottom;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DyWrapDistBottom>() const {
        return _DyWrapDistBottom._data;
    }
    template <> const LidRegroup* OfficeArtFOPTEChoice::C_anon::get<LidRegroup>() const {
        return &_LidRegroup;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<LidRegroup>() const {
        return _LidRegroup._data;
    }
    template <> const PosH* OfficeArtFOPTEChoice::C_anon::get<PosH>() const {
        return &_PosH;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosH>() const {
        return _PosH._data;
    }
    template <> const PosRelH* OfficeArtFOPTEChoice::C_anon::get<PosRelH>() const {
        return &_PosRelH;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosRelH>() const {
        return _PosRelH._data;
    }
    template <> const PosV* OfficeArtFOPTEChoice::C_anon::get<PosV>() const {
        return &_PosV;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosV>() const {
        return _PosV._data;
    }
    template <> const PosRelV* OfficeArtFOPTEChoice::C_anon::get<PosRelV>() const {
        return &_PosRelV;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PosRelV>() const {
        return _PosRelV._data;
    }
    template <> const PctHR* OfficeArtFOPTEChoice::C_anon::get<PctHR>() const {
        return &_PctHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<PctHR>() const {
        return _PctHR._data;
    }
    template <> const AlignHR* OfficeArtFOPTEChoice::C_anon::get<AlignHR>() const {
        return &_AlignHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<AlignHR>() const {
        return _AlignHR._data;
    }
    template <> const DxHeightHR* OfficeArtFOPTEChoice::C_anon::get<DxHeightHR>() const {
        return &_DxHeightHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxHeightHR>() const {
        return _DxHeightHR._data;
    }
    template <> const DxWidthHR* OfficeArtFOPTEChoice::C_anon::get<DxWidthHR>() const {
        return &_DxWidthHR;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DxWidthHR>() const {
        return _DxWidthHR._data;
    }
    template <> const GroupShapeBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<GroupShapeBooleanProperties>() const {
        return &_GroupShapeBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<GroupShapeBooleanProperties>() const {
        return _GroupShapeBooleanProperties._data;
    }
    template <> const WzFillId* OfficeArtFOPTEChoice::C_anon::get<WzFillId>() const {
        return &_WzFillId;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<WzFillId>() const {
        return _WzFillId._data;
    }
    template <> const DiagramBooleanProperties* OfficeArtFOPTEChoice::C_anon::get<DiagramBooleanProperties>() const {
        return &_DiagramBooleanProperties;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<DiagramBooleanProperties>() const {
        return _DiagramBooleanProperties._data;
    }
    template <> const OfficeArtFOPTE* OfficeArtFOPTEChoice::C_anon::get<OfficeArtFOPTE>() const {
        return &_OfficeArtFOPTE;
    }
    template <> bool OfficeArtFOPTEChoice::C_anon::is<OfficeArtFOPTE>() const {
        return _OfficeArtFOPTE._data;
    }
}
MSO::OfficeArtClientAnchor::OfficeArtClientAnchor(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._PptOfficeArtClientAnchor = PptOfficeArtClientAnchor(_d + _position, _maxsize - _position);
    _msize = anon._PptOfficeArtClientAnchor._size;
    if (_msize == 0) {
        anon._DocOfficeArtClientAnchor = DocOfficeArtClientAnchor(_d + _position);
        _msize = (anon._DocOfficeArtClientAnchor._data) ?DocOfficeArtClientAnchor::_size : 0;
    }
    if (_msize == 0) {
        anon._XlsOfficeArtClientAnchor = XlsOfficeArtClientAnchor(_d + _position, _maxsize - _position);
        _msize = anon._XlsOfficeArtClientAnchor._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const PptOfficeArtClientAnchor* OfficeArtClientAnchor::C_anon::get<PptOfficeArtClientAnchor>() const {
        return &_PptOfficeArtClientAnchor;
    }
    template <> bool OfficeArtClientAnchor::C_anon::is<PptOfficeArtClientAnchor>() const {
        return _PptOfficeArtClientAnchor._data;
    }
    template <> const DocOfficeArtClientAnchor* OfficeArtClientAnchor::C_anon::get<DocOfficeArtClientAnchor>() const {
        return &_DocOfficeArtClientAnchor;
    }
    template <> bool OfficeArtClientAnchor::C_anon::is<DocOfficeArtClientAnchor>() const {
        return _DocOfficeArtClientAnchor._data;
    }
    template <> const XlsOfficeArtClientAnchor* OfficeArtClientAnchor::C_anon::get<XlsOfficeArtClientAnchor>() const {
        return &_XlsOfficeArtClientAnchor;
    }
    template <> bool OfficeArtClientAnchor::C_anon::is<XlsOfficeArtClientAnchor>() const {
        return _XlsOfficeArtClientAnchor._data;
    }
}
MSO::PptOfficeArtClientData::PptOfficeArtClientData(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0xF011)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        shapeFlagsAtom = ShapeFlagsAtom(_d + _position, _maxsize - _position);
        _msize = (shapeFlagsAtom._data) ?shapeFlagsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shapeFlags10Atom = ShapeFlags10Atom(_d + _position, _maxsize - _position);
        _msize = (shapeFlags10Atom._data) ?shapeFlags10Atom._size :0;
        _position += _msize;
    }
    if (_position + 12 <= _maxsize) {
        exObjRefAtom = ExObjRefAtom(_d + _position);
        _msize = (exObjRefAtom._data) ?exObjRefAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        animationInfo = AnimationInfoContainer(_d + _position, _maxsize - _position);
        _msize = (animationInfo._data) ?animationInfo._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        mouseClickInteractiveInfo = MouseClickInteractiveInfoContainer(_d + _position, _maxsize - _position);
        _msize = (mouseClickInteractiveInfo._data) ?mouseClickInteractiveInfo._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        mouseOverInteractiveInfo = MouseOverInteractiveInfoContainer(_d + _position, _maxsize - _position);
        _msize = (mouseOverInteractiveInfo._data) ?mouseOverInteractiveInfo._size :0;
        _position += _msize;
    }
    rgShapeClientRoundtripData0 = MSOArray<ShapeClientRoundtripDataSubcontainerOrAtom>(_d + _position, _maxsize - _position);
    if (rgShapeClientRoundtripData0._data == 0) return;
        _msize = rgShapeClientRoundtripData0._size;
    _position += _msize;
    if (_position + 16 <= _maxsize) {
        placeholderAtom = PlaceholderAtom(_d + _position);
        _msize = (placeholderAtom._data) ?placeholderAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        recolorInfoAtom = RecolorInfoAtom(_d + _position, _maxsize - _position);
        _msize = (recolorInfoAtom._data) ?recolorInfoAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        unknown1 = UnknownOfficeArtClientDataChild(_d + _position, _maxsize - _position);
        _msize = (unknown1._data) ?unknown1._size :0;
        _position += _msize;
    }
    rgShapeClientRoundtripData = MSOArray<ShapeClientRoundtripDataSubcontainerOrAtom>(_d + _position, _maxsize - _position);
    if (rgShapeClientRoundtripData._data == 0) return;
        _msize = rgShapeClientRoundtripData._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        unknown2 = UnknownOfficeArtClientDataChild(_d + _position, _maxsize - _position);
        _msize = (unknown2._data) ?unknown2._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::ShapeProgBinaryTagContainer::ShapeProgBinaryTagContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x138A)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    rec = ShapeProgBinaryTagSubContainerOrAtom(_d + _position, _maxsize - _position);
    if (rec._data == 0) return;
    _msize = rec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::WordDocument::WordDocument(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    fib = Fib(_d + _position, _maxsize - _position);
    if (fib._data == 0) return;
    _msize = fib._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::Table::Table(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 468 > _maxsize) return;
    stsh = STSH(_d + _position, _maxsize - _position);
    if (stsh._data == 0) return;
    _msize = stsh._size;
    _position += _msize;
    if (_position + 20 > _maxsize) return;
    plcfSed = PlcfSed(_d + _position, _maxsize - _position);
    if (plcfSed._data == 0) return;
    _msize = plcfSed._size;
    _position += _msize;
    if (_position + 52 > _maxsize) return;
    plcfHdd = Plcfhdd(_d + _position);
    if (plcfHdd._data == 0) return;
    _msize = plcfHdd._size;
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    plcfBteChpx = PlcBteChpx(_d + _position);
    if (plcfBteChpx._data == 0) return;
    _msize = plcfBteChpx._size;
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    plcfBtePapx = PlcfBtePapx(_d + _position);
    if (plcfBtePapx._data == 0) return;
    _msize = plcfBtePapx._size;
    _position += _msize;
    if (_position + 12 > _maxsize) return;
    cmds = Tcg(_d + _position);
    if (cmds._data == 0) return;
    _msize = cmds._size;
    _position += _msize;
    if (_position + 21 > _maxsize) return;
    clx = Clx(_d + _position, _maxsize - _position);
    if (clx._data == 0) return;
    _msize = clx._size;
    _position += _msize;
    if (_position + 246 > _maxsize) return;
    sttbfFfn = SttbfFfn(_d + _position, _maxsize - _position);
    if (sttbfFfn._data == 0) return;
    _msize = sttbfFfn._size;
    _position += _msize;
    if (_position + 600 > _maxsize) return;
    dop = MSOCastArray<char>((const char*)(_d + _position), 600);
    _msize = (600)*1;
    _position += _msize;
    _size = _position;
    _data = _d;
}
const quint32 MSO::Pcd::_size = 8;
MSO::Pcd::Pcd(const char* _d, quint32/*ignored*/) :_data(0)
{
    quint32 _position = 0;
    quint32 _msize;
    fNoParaLast = readbit(_d + _position);
    _msize = 0;
    _position += _msize;
    fR1 = readbit_1(_d + _position);
    _msize = 0;
    _position += _msize;
    fDirtly = readbit_2(_d + _position);
    _msize = 0;
    if (!(((bool)fDirtly) == false)) {
         return;
    }
    _position += _msize;
    fR2 = readbit_3(_d + _position);
    _msize = 0;
    _position += _msize;
    fR3 = readuint12_4(_d + _position);
    _msize = 2;
    _position += _msize;
    fc = FCompressed(_d + _position);
    if (fc._data == 0) return;
    _msize = fc._size;
    _position += _msize;
    prm = Prm(_d + _position);
    if (prm._data == 0) return;
    _msize = prm._size;
    _position += _msize;
    _data = _d;
}
MSO::OfficeArtFBSE::OfficeArtFBSE(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x2)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1 || rh.recInstance == 2 || rh.recInstance == 3 || rh.recInstance == 4 || rh.recInstance == 5 || rh.recInstance == 6 || rh.recInstance == 7 || rh.recInstance == 0x11 || rh.recInstance == 0x12)) {
         return;
    }
    if (!(rh.recType == 0xF007)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    btWin32 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    btMacOS = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    rgbUid = MSOCastArray<char>((const char*)(_d + _position), 16);
    _msize = (16)*1;
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    tag = readuint16(_d + _position);
    _msize = 2;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    size = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    cRef = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 4 > _maxsize) return;
    foDelay = readuint32(_d + _position);
    _msize = 4;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    unused1 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    cbName = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    unused2 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    unused3 = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    _has_nameData = cbName>0;
    if (_has_nameData) {
        nameData = MSOCastArray<char>((const char*)(_d + _position), cbName);
        _msize = (cbName)*1;
        _position += _msize;
    }
    if (rh.recLen > 36 + cbName) {
        if (_position + 0 > _maxsize) return;
        embeddedBlip = OfficeArtBlip(_d + _position, _maxsize - _position);
        if (embeddedBlip._data == 0) return;
        _msize = embeddedBlip._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::OfficeArtBStoreContainerFileBlock::OfficeArtBStoreContainerFileBlock(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._OfficeArtFBSE = OfficeArtFBSE(_d + _position, _maxsize - _position);
    _msize = anon._OfficeArtFBSE._size;
    if (_msize == 0) {
        anon._OfficeArtBlip = OfficeArtBlip(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtBlip._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const OfficeArtFBSE* OfficeArtBStoreContainerFileBlock::C_anon::get<OfficeArtFBSE>() const {
        return &_OfficeArtFBSE;
    }
    template <> bool OfficeArtBStoreContainerFileBlock::C_anon::is<OfficeArtFBSE>() const {
        return _OfficeArtFBSE._data;
    }
    template <> const OfficeArtBlip* OfficeArtBStoreContainerFileBlock::C_anon::get<OfficeArtBlip>() const {
        return &_OfficeArtBlip;
    }
    template <> bool OfficeArtBStoreContainerFileBlock::C_anon::is<OfficeArtBlip>() const {
        return _OfficeArtBlip._data;
    }
}
MSO::SlideViewInfoInstance::SlideViewInfoInstance(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1)) {
         return;
    }
    if (!(rh.recType == 0x3FA)) {
         return;
    }
    _position += _msize;
    if (_position + 11 > _maxsize) return;
    slideViewInfoAtom = SlideViewInfoAtom(_d + _position);
    if (slideViewInfoAtom._data == 0) return;
    _msize = slideViewInfoAtom._size;
    _position += _msize;
    if (_position + 60 <= _maxsize) {
        zoomViewInfoAtom = ZoomViewInfoAtom(_d + _position);
        _msize = (zoomViewInfoAtom._data) ?zoomViewInfoAtom._size :0;
        _position += _msize;
    }
    rgGuideAtom = MSOArray<GuideAtom>(_d + _position, _maxsize - _position);
    if (rgGuideAtom._data == 0) return;
        _msize = rgGuideAtom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::DocProgBinaryTagSubContainerOrAtom::DocProgBinaryTagSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._PP9DocBinaryTagExtension = PP9DocBinaryTagExtension(_d + _position, _maxsize - _position);
    _msize = anon._PP9DocBinaryTagExtension._size;
    if (_msize == 0) {
        anon._PP10DocBinaryTagExtension = PP10DocBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP10DocBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._PP11DocBinaryTagExtension = PP11DocBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP11DocBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._PP12DocBinaryTagExtension = PP12DocBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP12DocBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._UnknownBinaryTag = UnknownBinaryTag(_d + _position, _maxsize - _position);
        _msize = anon._UnknownBinaryTag._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const PP9DocBinaryTagExtension* DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP9DocBinaryTagExtension>() const {
        return &_PP9DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP9DocBinaryTagExtension>() const {
        return _PP9DocBinaryTagExtension._data;
    }
    template <> const PP10DocBinaryTagExtension* DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP10DocBinaryTagExtension>() const {
        return &_PP10DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP10DocBinaryTagExtension>() const {
        return _PP10DocBinaryTagExtension._data;
    }
    template <> const PP11DocBinaryTagExtension* DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP11DocBinaryTagExtension>() const {
        return &_PP11DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP11DocBinaryTagExtension>() const {
        return _PP11DocBinaryTagExtension._data;
    }
    template <> const PP12DocBinaryTagExtension* DocProgBinaryTagSubContainerOrAtom::C_anon::get<PP12DocBinaryTagExtension>() const {
        return &_PP12DocBinaryTagExtension;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<PP12DocBinaryTagExtension>() const {
        return _PP12DocBinaryTagExtension._data;
    }
    template <> const UnknownBinaryTag* DocProgBinaryTagSubContainerOrAtom::C_anon::get<UnknownBinaryTag>() const {
        return &_UnknownBinaryTag;
    }
    template <> bool DocProgBinaryTagSubContainerOrAtom::C_anon::is<UnknownBinaryTag>() const {
        return _UnknownBinaryTag._data;
    }
}
MSO::TextMasterStyle9Atom::TextMasterStyle9Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1 || rh.recInstance == 2 || rh.recInstance == 3 || rh.recInstance == 4 || rh.recInstance == 5 || rh.recInstance == 6 || rh.recInstance == 7 || rh.recInstance == 8)) {
         return;
    }
    if (!(rh.recType == 0x0FAD)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cLevels = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cLevels)<=5)) {
         return;
    }
    _position += _msize;
    if (cLevels>0) {
        if (_position + 0 > _maxsize) return;
        lstLvl1 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (lstLvl1._data == 0) return;
        _msize = lstLvl1._size;
        _position += _msize;
    }
    if (cLevels>1) {
        if (_position + 0 > _maxsize) return;
        lstLvl2 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (lstLvl2._data == 0) return;
        _msize = lstLvl2._size;
        _position += _msize;
    }
    if (cLevels>2) {
        if (_position + 0 > _maxsize) return;
        lstLvl3 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (lstLvl3._data == 0) return;
        _msize = lstLvl3._size;
        _position += _msize;
    }
    if (cLevels>3) {
        if (_position + 0 > _maxsize) return;
        lstLvl4 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (lstLvl4._data == 0) return;
        _msize = lstLvl4._size;
        _position += _msize;
    }
    if (cLevels>4) {
        if (_position + 0 > _maxsize) return;
        lstLvl5 = TextMasterStyle9Level(_d + _position, _maxsize - _position);
        if (lstLvl5._data == 0) return;
        _msize = lstLvl5._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::BlipEntityAtom::BlipEntityAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0)) {
         return;
    }
    if (!(rh.recInstance<=128)) {
         return;
    }
    if (!(rh.recType == 0x07F9)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    winBlipType = readuint8(_d + _position);
    _msize = 1;
    if (!(((quint8)winBlipType) == 0x02 || ((quint8)winBlipType) == 0x03 || ((quint8)winBlipType) == 0x05 || ((quint8)winBlipType) == 0x06)) {
         return;
    }
    _position += _msize;
    if (_position + 1 > _maxsize) return;
    unused = readuint8(_d + _position);
    _msize = 1;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    blip = OfficeArtBStoreContainerFileBlock(_d + _position, _maxsize - _position);
    if (blip._data == 0) return;
    _msize = blip._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::TextMasterStyle10Atom::TextMasterStyle10Atom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0x0)) {
         return;
    }
    if (!(rh.recInstance == 0 || rh.recInstance == 1 || rh.recInstance == 2 || rh.recInstance == 3 || rh.recInstance == 4 || rh.recInstance == 5 || rh.recInstance == 6 || rh.recInstance == 7 || rh.recInstance == 8)) {
         return;
    }
    if (!(rh.recType == 0x0FB2)) {
         return;
    }
    _position += _msize;
    if (_position + 2 > _maxsize) return;
    cLevels = readuint16(_d + _position);
    _msize = 2;
    if (!(((quint16)cLevels)<=5)) {
         return;
    }
    _position += _msize;
    _has_lstLvl1level = cLevels>0 && rh.recInstance>=5;
    if (_has_lstLvl1level) {
        if (_position + 2 > _maxsize) return;
        lstLvl1level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>0) {
        if (_position + 0 > _maxsize) return;
        lstLvl1 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (lstLvl1._data == 0) return;
        _msize = lstLvl1._size;
        _position += _msize;
    }
    _has_lstLvl2level = cLevels>1 && rh.recInstance>=5;
    if (_has_lstLvl2level) {
        if (_position + 2 > _maxsize) return;
        lstLvl2level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>1) {
        if (_position + 0 > _maxsize) return;
        lstLvl2 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (lstLvl2._data == 0) return;
        _msize = lstLvl2._size;
        _position += _msize;
    }
    _has_lstLvl3level = cLevels>2 && rh.recInstance>=5;
    if (_has_lstLvl3level) {
        if (_position + 2 > _maxsize) return;
        lstLvl3level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>2) {
        if (_position + 0 > _maxsize) return;
        lstLvl3 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (lstLvl3._data == 0) return;
        _msize = lstLvl3._size;
        _position += _msize;
    }
    _has_lstLvl4level = cLevels>3 && rh.recInstance>=5;
    if (_has_lstLvl4level) {
        if (_position + 2 > _maxsize) return;
        lstLvl4level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>3) {
        if (_position + 0 > _maxsize) return;
        lstLvl4 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (lstLvl4._data == 0) return;
        _msize = lstLvl4._size;
        _position += _msize;
    }
    _has_lstLvl5level = cLevels>4 && rh.recInstance>=5;
    if (_has_lstLvl5level) {
        if (_position + 2 > _maxsize) return;
        lstLvl5level = readuint16(_d + _position);
        _msize = 2;
        _position += _msize;
    }
    if (cLevels>4) {
        if (_position + 0 > _maxsize) return;
        lstLvl5 = TextMasterStyle10Level(_d + _position, _maxsize - _position);
        if (lstLvl5._data == 0) return;
        _msize = lstLvl5._size;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::TextContainerInteractiveInfo::TextContainerInteractiveInfo(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    interactive._MouseClickTextInfo = MouseClickTextInfo(_d + _position, _maxsize - _position);
    _msize = interactive._MouseClickTextInfo._size;
    if (_msize == 0) {
        interactive._MouseOverTextInfo = MouseOverTextInfo(_d + _position, _maxsize - _position);
        _msize = interactive._MouseOverTextInfo._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const MouseClickTextInfo* TextContainerInteractiveInfo::C_interactive::get<MouseClickTextInfo>() const {
        return &_MouseClickTextInfo;
    }
    template <> bool TextContainerInteractiveInfo::C_interactive::is<MouseClickTextInfo>() const {
        return _MouseClickTextInfo._data;
    }
    template <> const MouseOverTextInfo* TextContainerInteractiveInfo::C_interactive::get<MouseOverTextInfo>() const {
        return &_MouseOverTextInfo;
    }
    template <> bool TextContainerInteractiveInfo::C_interactive::is<MouseOverTextInfo>() const {
        return _MouseOverTextInfo._data;
    }
}
MSO::DocumentTextInfoContainer::DocumentTextInfoContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x03F2)) {
         return;
    }
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        kinsoku = KinsokuContainer(_d + _position, _maxsize - _position);
        _msize = (kinsoku._data) ?kinsoku._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        fontCollection = FontCollectionContainer(_d + _position, _maxsize - _position);
        _msize = (fontCollection._data) ?fontCollection._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        textCFDefaultsAtom = TextCFExceptionAtom(_d + _position, _maxsize - _position);
        _msize = (textCFDefaultsAtom._data) ?textCFDefaultsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        textPFDefaultsAtom = TextPFExceptionAtom(_d + _position, _maxsize - _position);
        _msize = (textPFDefaultsAtom._data) ?textPFDefaultsAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        defaultRulerAtom = DefaultRulerAtom(_d + _position, _maxsize - _position);
        _msize = (defaultRulerAtom._data) ?defaultRulerAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    textSIDefaultsAtom = TextSIExceptionAtom(_d + _position, _maxsize - _position);
    if (textSIDefaultsAtom._data == 0) return;
    _msize = textSIDefaultsAtom._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    textMasterStyleAtom = TextMasterStyleAtom(_d + _position, _maxsize - _position);
    if (textMasterStyleAtom._data == 0) return;
    _msize = textMasterStyleAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        textMasterStyleAtom2 = TextMasterStyleAtom(_d + _position, _maxsize - _position);
        _msize = (textMasterStyleAtom2._data) ?textMasterStyleAtom2._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::SlideProgBinaryTagSubContainerOrAtom::SlideProgBinaryTagSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._PP9SlideBinaryTagExtension = PP9SlideBinaryTagExtension(_d + _position, _maxsize - _position);
    _msize = anon._PP9SlideBinaryTagExtension._size;
    if (_msize == 0) {
        anon._PP12SlideBinaryTagExtension = PP12SlideBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP12SlideBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._PP10SlideBinaryTagExtension = PP10SlideBinaryTagExtension(_d + _position, _maxsize - _position);
        _msize = anon._PP10SlideBinaryTagExtension._size;
    }
    if (_msize == 0) {
        anon._UnknownBinaryTag = UnknownBinaryTag(_d + _position, _maxsize - _position);
        _msize = anon._UnknownBinaryTag._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const PP9SlideBinaryTagExtension* SlideProgBinaryTagSubContainerOrAtom::C_anon::get<PP9SlideBinaryTagExtension>() const {
        return &_PP9SlideBinaryTagExtension;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<PP9SlideBinaryTagExtension>() const {
        return _PP9SlideBinaryTagExtension._data;
    }
    template <> const PP12SlideBinaryTagExtension* SlideProgBinaryTagSubContainerOrAtom::C_anon::get<PP12SlideBinaryTagExtension>() const {
        return &_PP12SlideBinaryTagExtension;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<PP12SlideBinaryTagExtension>() const {
        return _PP12SlideBinaryTagExtension._data;
    }
    template <> const PP10SlideBinaryTagExtension* SlideProgBinaryTagSubContainerOrAtom::C_anon::get<PP10SlideBinaryTagExtension>() const {
        return &_PP10SlideBinaryTagExtension;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<PP10SlideBinaryTagExtension>() const {
        return _PP10SlideBinaryTagExtension._data;
    }
    template <> const UnknownBinaryTag* SlideProgBinaryTagSubContainerOrAtom::C_anon::get<UnknownBinaryTag>() const {
        return &_UnknownBinaryTag;
    }
    template <> bool SlideProgBinaryTagSubContainerOrAtom::C_anon::is<UnknownBinaryTag>() const {
        return _UnknownBinaryTag._data;
    }
}
MSO::DrawingGroupContainer::DrawingGroupContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x040B)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    OfficeArtDgg = OfficeArtDggContainer(_d + _position, _maxsize - _position);
    if (OfficeArtDgg._data == 0) return;
    _msize = OfficeArtDgg._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtClientData::OfficeArtClientData(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._DocOfficeArtClientData = DocOfficeArtClientData(_d + _position);
    _msize = (anon._DocOfficeArtClientData._data) ?DocOfficeArtClientData::_size : 0;
    if (_msize == 0) {
        anon._PptOfficeArtClientData = PptOfficeArtClientData(_d + _position, _maxsize - _position);
        _msize = anon._PptOfficeArtClientData._size;
    }
    if (_msize == 0) {
        anon._XlsOfficeArtClientData = XlsOfficeArtClientData(_d + _position);
        _msize = (anon._XlsOfficeArtClientData._data) ?XlsOfficeArtClientData::_size : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const DocOfficeArtClientData* OfficeArtClientData::C_anon::get<DocOfficeArtClientData>() const {
        return &_DocOfficeArtClientData;
    }
    template <> bool OfficeArtClientData::C_anon::is<DocOfficeArtClientData>() const {
        return _DocOfficeArtClientData._data;
    }
    template <> const PptOfficeArtClientData* OfficeArtClientData::C_anon::get<PptOfficeArtClientData>() const {
        return &_PptOfficeArtClientData;
    }
    template <> bool OfficeArtClientData::C_anon::is<PptOfficeArtClientData>() const {
        return _PptOfficeArtClientData._data;
    }
    template <> const XlsOfficeArtClientData* OfficeArtClientData::C_anon::get<XlsOfficeArtClientData>() const {
        return &_XlsOfficeArtClientData;
    }
    template <> bool OfficeArtClientData::C_anon::is<XlsOfficeArtClientData>() const {
        return _XlsOfficeArtClientData._data;
    }
}
MSO::ShapeProgTagsSubContainerOrAtom::ShapeProgTagsSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._ProgStringTagContainer = ProgStringTagContainer(_d + _position, _maxsize - _position);
    _msize = anon._ProgStringTagContainer._size;
    if (_msize == 0) {
        anon._ShapeProgBinaryTagContainer = ShapeProgBinaryTagContainer(_d + _position, _maxsize - _position);
        _msize = anon._ShapeProgBinaryTagContainer._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const ProgStringTagContainer* ShapeProgTagsSubContainerOrAtom::C_anon::get<ProgStringTagContainer>() const {
        return &_ProgStringTagContainer;
    }
    template <> bool ShapeProgTagsSubContainerOrAtom::C_anon::is<ProgStringTagContainer>() const {
        return _ProgStringTagContainer._data;
    }
    template <> const ShapeProgBinaryTagContainer* ShapeProgTagsSubContainerOrAtom::C_anon::get<ShapeProgBinaryTagContainer>() const {
        return &_ShapeProgBinaryTagContainer;
    }
    template <> bool ShapeProgTagsSubContainerOrAtom::C_anon::is<ShapeProgBinaryTagContainer>() const {
        return _ShapeProgBinaryTagContainer._data;
    }
}
MSO::DocumentContainer::DocumentContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x03E8)) {
         return;
    }
    _position += _msize;
    if (_position + 48 > _maxsize) return;
    documentAtom = DocumentAtom(_d + _position);
    if (documentAtom._data == 0) return;
    _msize = documentAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        exObjList = ExObjListContainer(_d + _position, _maxsize - _position);
        _msize = (exObjList._data) ?exObjList._size :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    documentTextInfo = DocumentTextInfoContainer(_d + _position, _maxsize - _position);
    if (documentTextInfo._data == 0) return;
    _msize = documentTextInfo._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        soundCollection = SoundCollectionContainer(_d + _position, _maxsize - _position);
        _msize = (soundCollection._data) ?soundCollection._size :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    drawingGroup = DrawingGroupContainer(_d + _position, _maxsize - _position);
    if (drawingGroup._data == 0) return;
    _msize = drawingGroup._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    masterList = MasterListWithTextContainer(_d + _position, _maxsize - _position);
    if (masterList._data == 0) return;
    _msize = masterList._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        docInfoList = DocInfoListContainer(_d + _position, _maxsize - _position);
        _msize = (docInfoList._data) ?docInfoList._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideHF = SlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (slideHF._data) ?slideHF._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        notesHF = NotesHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (notesHF._data) ?notesHF._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideList = SlideListWithTextContainer(_d + _position, _maxsize - _position);
        _msize = (slideList._data) ?slideList._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideHF2 = SlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (slideHF2._data) ?slideHF2._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        notesList = NotesListWithTextContainer(_d + _position, _maxsize - _position);
        _msize = (notesList._data) ?notesList._size :0;
        _position += _msize;
    }
    if (_position + 88 <= _maxsize) {
        slideShowDocInfoAtom = SlideShowDocInfoAtom(_d + _position);
        _msize = (slideShowDocInfoAtom._data) ?slideShowDocInfoAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        namedShows = NamedShowsContainer(_d + _position, _maxsize - _position);
        _msize = (namedShows._data) ?namedShows._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        summary = SummaryContainer(_d + _position, _maxsize - _position);
        _msize = (summary._data) ?summary._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        docRoutingSlipAtom = DocRoutingSlipAtom(_d + _position, _maxsize - _position);
        _msize = (docRoutingSlipAtom._data) ?docRoutingSlipAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        printOptionsAtom = PrintOptionsAtom(_d + _position, _maxsize - _position);
        _msize = (printOptionsAtom._data) ?printOptionsAtom._size :0;
        _position += _msize;
    }
    unknown0 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (unknown0._data == 0) return;
        _msize = unknown0._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        rtCustomTableStylesAtom1 = RoundTripCustomTableStyles12Atom(_d + _position, _maxsize - _position);
        _msize = (rtCustomTableStylesAtom1._data) ?rtCustomTableStylesAtom1._size :0;
        _position += _msize;
    }
    unknown1 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (unknown1._data == 0) return;
        _msize = unknown1._size;
    _position += _msize;
    if (_position + 8 > _maxsize) return;
    endDocumentAtom = EndDocumentAtom(_d + _position);
    if (endDocumentAtom._data == 0) return;
    _msize = endDocumentAtom._size;
    _position += _msize;
    unknown2 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (unknown2._data == 0) return;
        _msize = unknown2._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        rtCustomTableStylesAtom2 = RoundTripCustomTableStyles12Atom(_d + _position, _maxsize - _position);
        _msize = (rtCustomTableStylesAtom2._data) ?rtCustomTableStylesAtom2._size :0;
        _position += _msize;
    }
    unknown4 = MSOArray<UnknownDocumentContainerChild>(_d + _position, _maxsize - _position);
    if (unknown4._data == 0) return;
        _msize = unknown4._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        unknown5 = TextMasterStyle10Atom(_d + _position, _maxsize - _position);
        _msize = (unknown5._data) ?unknown5._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::DocInfoListSubContainerOrAtom::DocInfoListSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._DocProgTagsContainer = DocProgTagsContainer(_d + _position, _maxsize - _position);
    _msize = anon._DocProgTagsContainer._size;
    if (_msize == 0) {
        anon._NormalViewSetInfoContainer = NormalViewSetInfoContainer(_d + _position);
        _msize = (anon._NormalViewSetInfoContainer._data) ?NormalViewSetInfoContainer::_size : 0;
    }
    if (_msize == 0) {
        anon._NotesTextViewInfoContainer = NotesTextViewInfoContainer(_d + _position);
        _msize = (anon._NotesTextViewInfoContainer._data) ?NotesTextViewInfoContainer::_size : 0;
    }
    if (_msize == 0) {
        anon._OutlineViewInfoContainer = OutlineViewInfoContainer(_d + _position);
        _msize = (anon._OutlineViewInfoContainer._data) ?OutlineViewInfoContainer::_size : 0;
    }
    if (_msize == 0) {
        anon._SlideViewInfoInstance = SlideViewInfoInstance(_d + _position, _maxsize - _position);
        _msize = anon._SlideViewInfoInstance._size;
    }
    if (_msize == 0) {
        anon._SorterViewInfoContainer = SorterViewInfoContainer(_d + _position, _maxsize - _position);
        _msize = anon._SorterViewInfoContainer._size;
    }
    if (_msize == 0) {
        anon._VBAInfoContainer = VBAInfoContainer(_d + _position);
        _msize = (anon._VBAInfoContainer._data) ?VBAInfoContainer::_size : 0;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const DocProgTagsContainer* DocInfoListSubContainerOrAtom::C_anon::get<DocProgTagsContainer>() const {
        return &_DocProgTagsContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<DocProgTagsContainer>() const {
        return _DocProgTagsContainer._data;
    }
    template <> const NormalViewSetInfoContainer* DocInfoListSubContainerOrAtom::C_anon::get<NormalViewSetInfoContainer>() const {
        return &_NormalViewSetInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<NormalViewSetInfoContainer>() const {
        return _NormalViewSetInfoContainer._data;
    }
    template <> const NotesTextViewInfoContainer* DocInfoListSubContainerOrAtom::C_anon::get<NotesTextViewInfoContainer>() const {
        return &_NotesTextViewInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<NotesTextViewInfoContainer>() const {
        return _NotesTextViewInfoContainer._data;
    }
    template <> const OutlineViewInfoContainer* DocInfoListSubContainerOrAtom::C_anon::get<OutlineViewInfoContainer>() const {
        return &_OutlineViewInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<OutlineViewInfoContainer>() const {
        return _OutlineViewInfoContainer._data;
    }
    template <> const SlideViewInfoInstance* DocInfoListSubContainerOrAtom::C_anon::get<SlideViewInfoInstance>() const {
        return &_SlideViewInfoInstance;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<SlideViewInfoInstance>() const {
        return _SlideViewInfoInstance._data;
    }
    template <> const SorterViewInfoContainer* DocInfoListSubContainerOrAtom::C_anon::get<SorterViewInfoContainer>() const {
        return &_SorterViewInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<SorterViewInfoContainer>() const {
        return _SorterViewInfoContainer._data;
    }
    template <> const VBAInfoContainer* DocInfoListSubContainerOrAtom::C_anon::get<VBAInfoContainer>() const {
        return &_VBAInfoContainer;
    }
    template <> bool DocInfoListSubContainerOrAtom::C_anon::is<VBAInfoContainer>() const {
        return _VBAInfoContainer._data;
    }
}
MSO::DocProgBinaryTagContainer::DocProgBinaryTagContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x138A)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    rec = DocProgBinaryTagSubContainerOrAtom(_d + _position, _maxsize - _position);
    if (rec._data == 0) return;
    _msize = rec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::SlideProgBinaryTagContainer::SlideProgBinaryTagContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x138A)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    rec = SlideProgBinaryTagSubContainerOrAtom(_d + _position, _maxsize - _position);
    if (rec._data == 0) return;
    _msize = rec._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::OfficeArtSpContainer::OfficeArtSpContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x0F004)) {
         return;
    }
    _position += _msize;
    if (_position + 24 <= _maxsize) {
        shapeGroup = OfficeArtFSPGR(_d + _position);
        _msize = (shapeGroup._data) ?shapeGroup._size :0;
        _position += _msize;
    }
    if (_position + 16 > _maxsize) return;
    shapeProp = OfficeArtFSP(_d + _position);
    if (shapeProp._data == 0) return;
    _msize = shapeProp._size;
    _position += _msize;
    if (_position + 12 <= _maxsize) {
        deletedshape = OfficeArtFPSPL(_d + _position);
        _msize = (deletedshape._data) ?deletedshape._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shapePrimaryOptions = OfficeArtFOPT(_d + _position, _maxsize - _position);
        _msize = (shapePrimaryOptions._data) ?shapePrimaryOptions._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shapeSecondaryOptions1 = OfficeArtSecondaryFOPT(_d + _position, _maxsize - _position);
        _msize = (shapeSecondaryOptions1._data) ?shapeSecondaryOptions1._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shapeTertiaryOptions1 = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (shapeTertiaryOptions1._data) ?shapeTertiaryOptions1._size :0;
        _position += _msize;
    }
    if (_position + 24 <= _maxsize) {
        childAnchor = OfficeArtChildAnchor(_d + _position);
        _msize = (childAnchor._data) ?childAnchor._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        clientAnchor = OfficeArtClientAnchor(_d + _position, _maxsize - _position);
        _msize = (clientAnchor._data) ?clientAnchor._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        clientData = OfficeArtClientData(_d + _position, _maxsize - _position);
        _msize = (clientData._data) ?clientData._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        clientTextbox = OfficeArtClientTextBox(_d + _position, _maxsize - _position);
        _msize = (clientTextbox._data) ?clientTextbox._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shapeSecondaryOptions2 = OfficeArtSecondaryFOPT(_d + _position, _maxsize - _position);
        _msize = (shapeSecondaryOptions2._data) ?shapeSecondaryOptions2._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shapeTertiaryOptions2 = OfficeArtTertiaryFOPT(_d + _position, _maxsize - _position);
        _msize = (shapeTertiaryOptions2._data) ?shapeTertiaryOptions2._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        unknown = UnknownTextContainerChild(_d + _position, _maxsize - _position);
        _msize = (unknown._data) ?unknown._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::OfficeArtInlineSpContainer::OfficeArtInlineSpContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    shape = OfficeArtSpContainer(_d + _position, _maxsize - _position);
    if (shape._data == 0) return;
    _msize = shape._size;
    _position += _msize;
    rgfb = MSOArray<OfficeArtBStoreContainerFileBlock>(_d + _position, _maxsize - _position);
    if (rgfb._data == 0) return;
        _msize = rgfb._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::DocProgTagsSubContainerOrAtom::DocProgTagsSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._ProgStringTagContainer = ProgStringTagContainer(_d + _position, _maxsize - _position);
    _msize = anon._ProgStringTagContainer._size;
    if (_msize == 0) {
        anon._DocProgBinaryTagContainer = DocProgBinaryTagContainer(_d + _position, _maxsize - _position);
        _msize = anon._DocProgBinaryTagContainer._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const ProgStringTagContainer* DocProgTagsSubContainerOrAtom::C_anon::get<ProgStringTagContainer>() const {
        return &_ProgStringTagContainer;
    }
    template <> bool DocProgTagsSubContainerOrAtom::C_anon::is<ProgStringTagContainer>() const {
        return _ProgStringTagContainer._data;
    }
    template <> const DocProgBinaryTagContainer* DocProgTagsSubContainerOrAtom::C_anon::get<DocProgBinaryTagContainer>() const {
        return &_DocProgBinaryTagContainer;
    }
    template <> bool DocProgTagsSubContainerOrAtom::C_anon::is<DocProgBinaryTagContainer>() const {
        return _DocProgBinaryTagContainer._data;
    }
}
MSO::SlideProgTagsSubContainerOrAtom::SlideProgTagsSubContainerOrAtom(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._ProgStringTagContainer = ProgStringTagContainer(_d + _position, _maxsize - _position);
    _msize = anon._ProgStringTagContainer._size;
    if (_msize == 0) {
        anon._SlideProgBinaryTagContainer = SlideProgBinaryTagContainer(_d + _position, _maxsize - _position);
        _msize = anon._SlideProgBinaryTagContainer._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const ProgStringTagContainer* SlideProgTagsSubContainerOrAtom::C_anon::get<ProgStringTagContainer>() const {
        return &_ProgStringTagContainer;
    }
    template <> bool SlideProgTagsSubContainerOrAtom::C_anon::is<ProgStringTagContainer>() const {
        return _ProgStringTagContainer._data;
    }
    template <> const SlideProgBinaryTagContainer* SlideProgTagsSubContainerOrAtom::C_anon::get<SlideProgBinaryTagContainer>() const {
        return &_SlideProgBinaryTagContainer;
    }
    template <> bool SlideProgTagsSubContainerOrAtom::C_anon::is<SlideProgBinaryTagContainer>() const {
        return _SlideProgBinaryTagContainer._data;
    }
}
MSO::OfficeArtDgContainer::OfficeArtDgContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = OfficeArtRecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0xF002)) {
         return;
    }
    _position += _msize;
    if (_position + 16 <= _maxsize) {
        drawingData = OfficeArtFDG(_d + _position);
        _msize = (drawingData._data) ?drawingData._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        regroupItems = OfficeArtFRITContainer(_d + _position, _maxsize - _position);
        _msize = (regroupItems._data) ?regroupItems._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        groupShape = OfficeArtSpgrContainer(_d + _position, _maxsize - _position);
        _msize = (groupShape._data) ?groupShape._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        shape = OfficeArtSpContainer(_d + _position, _maxsize - _position);
        _msize = (shape._data) ?shape._size :0;
        _position += _msize;
    }
    deletedShapes = MSOArray<OfficeArtSpgrContainerFileBlock>(_d + _position, _maxsize - _position);
    if (deletedShapes._data == 0) return;
        _msize = deletedShapes._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        solvers = OfficeArtSolverContainer(_d + _position, _maxsize - _position);
        _msize = (solvers._data) ?solvers._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::OfficeArtSpgrContainerFileBlock::OfficeArtSpgrContainerFileBlock(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._OfficeArtSpContainer = OfficeArtSpContainer(_d + _position, _maxsize - _position);
    _msize = anon._OfficeArtSpContainer._size;
    if (_msize == 0) {
        anon._OfficeArtSpgrContainer = OfficeArtSpgrContainer(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtSpgrContainer._size;
    }
    if (_msize == 0) {
        anon._OfficeArtFSP = OfficeArtFSP(_d + _position);
        _msize = (anon._OfficeArtFSP._data) ?OfficeArtFSP::_size : 0;
    }
    if (_msize == 0) {
        anon._OfficeArtFSPGR = OfficeArtFSPGR(_d + _position);
        _msize = (anon._OfficeArtFSPGR._data) ?OfficeArtFSPGR::_size : 0;
    }
    if (_msize == 0) {
        anon._OfficeArtClientAnchor = OfficeArtClientAnchor(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtClientAnchor._size;
    }
    if (_msize == 0) {
        anon._OfficeArtClientData = OfficeArtClientData(_d + _position, _maxsize - _position);
        _msize = anon._OfficeArtClientData._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const OfficeArtSpContainer* OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtSpContainer>() const {
        return &_OfficeArtSpContainer;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtSpContainer>() const {
        return _OfficeArtSpContainer._data;
    }
    template <> const OfficeArtSpgrContainer* OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtSpgrContainer>() const {
        return &_OfficeArtSpgrContainer;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtSpgrContainer>() const {
        return _OfficeArtSpgrContainer._data;
    }
    template <> const OfficeArtFSP* OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtFSP>() const {
        return &_OfficeArtFSP;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtFSP>() const {
        return _OfficeArtFSP._data;
    }
    template <> const OfficeArtFSPGR* OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtFSPGR>() const {
        return &_OfficeArtFSPGR;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtFSPGR>() const {
        return _OfficeArtFSPGR._data;
    }
    template <> const OfficeArtClientAnchor* OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtClientAnchor>() const {
        return &_OfficeArtClientAnchor;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtClientAnchor>() const {
        return _OfficeArtClientAnchor._data;
    }
    template <> const OfficeArtClientData* OfficeArtSpgrContainerFileBlock::C_anon::get<OfficeArtClientData>() const {
        return &_OfficeArtClientData;
    }
    template <> bool OfficeArtSpgrContainerFileBlock::C_anon::is<OfficeArtClientData>() const {
        return _OfficeArtClientData._data;
    }
}
MSO::DrawingContainer::DrawingContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x040C)) {
         return;
    }
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    OfficeArtDg = OfficeArtDgContainer(_d + _position, _maxsize - _position);
    if (OfficeArtDg._data == 0) return;
    _msize = OfficeArtDg._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::MainMasterContainer::MainMasterContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x03F8)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    slideAtom = SlideAtom(_d + _position);
    if (slideAtom._data == 0) return;
    _msize = slideAtom._size;
    _position += _msize;
    if (_position + 24 <= _maxsize) {
        unknown = SlideShowSlideInfoAtom(_d + _position);
        _msize = (unknown._data) ?unknown._size :0;
        _position += _msize;
    }
    rgSchemeListElementColorScheme = MSOArray<SchemeListElementColorSchemeAtom>(_d + _position, _maxsize - _position);
    if (rgSchemeListElementColorScheme._data == 0) return;
        _msize = rgSchemeListElementColorScheme._size;
    _position += _msize;
    rgTextMasterStyle = MSOArray<TextMasterStyleAtom>(_d + _position, _maxsize - _position);
    if (rgTextMasterStyle._data == 0) return;
        _msize = rgTextMasterStyle._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        roundTripOArtTextSTyles12Atom = RoundTripOArtTextStyles12Atom(_d + _position, _maxsize - _position);
        _msize = (roundTripOArtTextSTyles12Atom._data) ?roundTripOArtTextSTyles12Atom._size :0;
        _position += _msize;
    }
    if (_position + 24 <= _maxsize) {
        slideShowInfoAtom = SlideShowSlideInfoAtom(_d + _position);
        _msize = (slideShowInfoAtom._data) ?slideShowInfoAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        perSlideHeadersFootersContainer = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (perSlideHeadersFootersContainer._data) ?perSlideHeadersFootersContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    drawing = DrawingContainer(_d + _position, _maxsize - _position);
    if (drawing._data == 0) return;
    _msize = drawing._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    slideSchemeColorSchemeAtom = SlideSchemeColorSchemeAtom(_d + _position, _maxsize - _position);
    if (slideSchemeColorSchemeAtom._data == 0) return;
    _msize = slideSchemeColorSchemeAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        slideNameAtom = SlideNameAtom(_d + _position, _maxsize - _position);
        _msize = (slideNameAtom._data) ?slideNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideProgTagsContainer = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (slideProgTagsContainer._data) ?slideProgTagsContainer._size :0;
        _position += _msize;
    }
    rgRoundTripMainMaster = MSOArray<RoundTripMainMasterRecord>(_d + _position, _maxsize - _position);
    if (rgRoundTripMainMaster._data == 0) return;
        _msize = rgRoundTripMainMaster._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        templateNameAtom = TemplateNameAtom(_d + _position, _maxsize - _position);
        _msize = (templateNameAtom._data) ?templateNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        unknown3 = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (unknown3._data) ?unknown3._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::SlideContainer::SlideContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0x0)) {
         return;
    }
    if (!(rh.recType == 0x03EE)) {
         return;
    }
    _position += _msize;
    if (_position + 32 > _maxsize) return;
    slideAtom = SlideAtom(_d + _position);
    if (slideAtom._data == 0) return;
    _msize = slideAtom._size;
    _position += _msize;
    if (_position + 24 <= _maxsize) {
        slideShowSlideInfoAtom = SlideShowSlideInfoAtom(_d + _position);
        _msize = (slideShowSlideInfoAtom._data) ?slideShowSlideInfoAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        perSlideHFContainer = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (perSlideHFContainer._data) ?perSlideHFContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        rtSlideSyncInfo12 = RoundTripSlideSyncInfo12Container(_d + _position, _maxsize - _position);
        _msize = (rtSlideSyncInfo12._data) ?rtSlideSyncInfo12._size :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    drawing = DrawingContainer(_d + _position, _maxsize - _position);
    if (drawing._data == 0) return;
    _msize = drawing._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    slideSchemeColorSchemeAtom = SlideSchemeColorSchemeAtom(_d + _position, _maxsize - _position);
    if (slideSchemeColorSchemeAtom._data == 0) return;
    _msize = slideSchemeColorSchemeAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        slideNameAtom = SlideNameAtom(_d + _position, _maxsize - _position);
        _msize = (slideNameAtom._data) ?slideNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideProgTagsContainer = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (slideProgTagsContainer._data) ?slideProgTagsContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        unknown = UnknownSlideContainerChild(_d + _position, _maxsize - _position);
        _msize = (unknown._data) ?unknown._size :0;
        _position += _msize;
    }
    rgRoundTripSlide = MSOArray<RoundTripSlideRecord>(_d + _position, _maxsize - _position);
    if (rgRoundTripSlide._data == 0) return;
        _msize = rgRoundTripSlide._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        unknown2 = UnknownSlideContainerChild(_d + _position, _maxsize - _position);
        _msize = (unknown2._data) ?unknown2._size :0;
        _position += _msize;
    }
    _size = _position;
    _data = _d;
}
MSO::NotesContainer::NotesContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 8 > _maxsize) return;
    rh = RecordHeader(_d + _position);
    if (rh._data == 0) return;
    _msize = rh._size;
    if (!(rh.recVer == 0xF)) {
         return;
    }
    if (!(rh.recInstance == 0)) {
         return;
    }
    if (!(rh.recType == 0x03F0)) {
         return;
    }
    _position += _msize;
    if (_position + 16 > _maxsize) return;
    notesAtom = NotesAtom(_d + _position);
    if (notesAtom._data == 0) return;
    _msize = notesAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        perSlideHFContainer = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (perSlideHFContainer._data) ?perSlideHFContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 > _maxsize) return;
    drawing = DrawingContainer(_d + _position, _maxsize - _position);
    if (drawing._data == 0) return;
    _msize = drawing._size;
    _position += _msize;
    if (_position + 0 > _maxsize) return;
    slideSchemeColorSchemeAtom = SlideSchemeColorSchemeAtom(_d + _position, _maxsize - _position);
    if (slideSchemeColorSchemeAtom._data == 0) return;
    _msize = slideSchemeColorSchemeAtom._size;
    _position += _msize;
    if (_position + 0 <= _maxsize) {
        slideNameAtom = SlideNameAtom(_d + _position, _maxsize - _position);
        _msize = (slideNameAtom._data) ?slideNameAtom._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        slideProgTagsContainer = SlideProgTagsContainer(_d + _position, _maxsize - _position);
        _msize = (slideProgTagsContainer._data) ?slideProgTagsContainer._size :0;
        _position += _msize;
    }
    if (_position + 0 <= _maxsize) {
        perSlideHFContainer2 = PerSlideHeadersFootersContainer(_d + _position, _maxsize - _position);
        _msize = (perSlideHFContainer2._data) ?perSlideHFContainer2._size :0;
        _position += _msize;
    }
    rgNotesRoundTripAtom = MSOArray<NotesRoundTripAtom>(_d + _position, _maxsize - _position);
    if (rgNotesRoundTripAtom._data == 0) return;
        _msize = rgNotesRoundTripAtom._size;
    _position += _msize;
    _size = _position;
    _data = _d;
}
MSO::MasterOrSlideContainer::MasterOrSlideContainer(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._MainMasterContainer = MainMasterContainer(_d + _position, _maxsize - _position);
    _msize = anon._MainMasterContainer._size;
    if (_msize == 0) {
        anon._SlideContainer = SlideContainer(_d + _position, _maxsize - _position);
        _msize = anon._SlideContainer._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const MainMasterContainer* MasterOrSlideContainer::C_anon::get<MainMasterContainer>() const {
        return &_MainMasterContainer;
    }
    template <> bool MasterOrSlideContainer::C_anon::is<MainMasterContainer>() const {
        return _MainMasterContainer._data;
    }
    template <> const SlideContainer* MasterOrSlideContainer::C_anon::get<SlideContainer>() const {
        return &_SlideContainer;
    }
    template <> bool MasterOrSlideContainer::C_anon::is<SlideContainer>() const {
        return _SlideContainer._data;
    }
}
MSO::PowerPointStruct::PowerPointStruct(const char* _d, quint32 _maxsize) :_data(0), _size(0)
{
    quint32 _position = 0;
    quint32 _msize;
    if (_position + 0 > _maxsize) return;
    anon._DocumentContainer = DocumentContainer(_d + _position, _maxsize - _position);
    _msize = anon._DocumentContainer._size;
    if (_msize == 0) {
        anon._MasterOrSlideContainer = MasterOrSlideContainer(_d + _position, _maxsize - _position);
        _msize = anon._MasterOrSlideContainer._size;
    }
    if (_msize == 0) {
        anon._PersistDirectoryAtom = PersistDirectoryAtom(_d + _position, _maxsize - _position);
        _msize = anon._PersistDirectoryAtom._size;
    }
    if (_msize == 0) {
        anon._NotesContainer = NotesContainer(_d + _position, _maxsize - _position);
        _msize = anon._NotesContainer._size;
    }
    if (_msize == 0) {
        anon._HandoutContainer = HandoutContainer(_d + _position, _maxsize - _position);
        _msize = anon._HandoutContainer._size;
    }
    if (_msize == 0) {
        anon._SlideContainer = SlideContainer(_d + _position, _maxsize - _position);
        _msize = anon._SlideContainer._size;
    }
    if (_msize == 0) {
        anon._ExOleObjStg = ExOleObjStg(_d + _position, _maxsize - _position);
        _msize = anon._ExOleObjStg._size;
    }
    if (_msize == 0) {
        anon._ExControlStg = ExControlStg(_d + _position, _maxsize - _position);
        _msize = anon._ExControlStg._size;
    }
    if (_msize == 0) {
        anon._VbaProjectStg = VbaProjectStg(_d + _position, _maxsize - _position);
        _msize = anon._VbaProjectStg._size;
    }
    if (_msize == 0) {
        anon._UserEditAtom = UserEditAtom(_d + _position, _maxsize - _position);
        _msize = anon._UserEditAtom._size;
    }
    if (_msize == 0) return;
    _position += _msize;
    _size = _position;
    _data = _d;
}
namespace MSO {
    template <> const DocumentContainer* PowerPointStruct::C_anon::get<DocumentContainer>() const {
        return &_DocumentContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<DocumentContainer>() const {
        return _DocumentContainer._data;
    }
    template <> const MasterOrSlideContainer* PowerPointStruct::C_anon::get<MasterOrSlideContainer>() const {
        return &_MasterOrSlideContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<MasterOrSlideContainer>() const {
        return _MasterOrSlideContainer._data;
    }
    template <> const PersistDirectoryAtom* PowerPointStruct::C_anon::get<PersistDirectoryAtom>() const {
        return &_PersistDirectoryAtom;
    }
    template <> bool PowerPointStruct::C_anon::is<PersistDirectoryAtom>() const {
        return _PersistDirectoryAtom._data;
    }
    template <> const NotesContainer* PowerPointStruct::C_anon::get<NotesContainer>() const {
        return &_NotesContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<NotesContainer>() const {
        return _NotesContainer._data;
    }
    template <> const HandoutContainer* PowerPointStruct::C_anon::get<HandoutContainer>() const {
        return &_HandoutContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<HandoutContainer>() const {
        return _HandoutContainer._data;
    }
    template <> const SlideContainer* PowerPointStruct::C_anon::get<SlideContainer>() const {
        return &_SlideContainer;
    }
    template <> bool PowerPointStruct::C_anon::is<SlideContainer>() const {
        return _SlideContainer._data;
    }
    template <> const ExOleObjStg* PowerPointStruct::C_anon::get<ExOleObjStg>() const {
        return &_ExOleObjStg;
    }
    template <> bool PowerPointStruct::C_anon::is<ExOleObjStg>() const {
        return _ExOleObjStg._data;
    }
    template <> const ExControlStg* PowerPointStruct::C_anon::get<ExControlStg>() const {
        return &_ExControlStg;
    }
    template <> bool PowerPointStruct::C_anon::is<ExControlStg>() const {
        return _ExControlStg._data;
    }
    template <> const VbaProjectStg* PowerPointStruct::C_anon::get<VbaProjectStg>() const {
        return &_VbaProjectStg;
    }
    template <> bool PowerPointStruct::C_anon::is<VbaProjectStg>() const {
        return _VbaProjectStg._data;
    }
    template <> const UserEditAtom* PowerPointStruct::C_anon::get<UserEditAtom>() const {
        return &_UserEditAtom;
    }
    template <> bool PowerPointStruct::C_anon::is<UserEditAtom>() const {
        return _UserEditAtom._data;
    }
}
